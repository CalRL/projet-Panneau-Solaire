CCS PCM C Compiler, Version 3.212, 26421               31-août-05 13:38

               Filename: C:\Dossier MAT Electronique\Programmes PIC applications MAT\Panneau solaire\source modules pic (version 2)\carte energie\main.LST

               ROM used: 1954 words (24%)
                         Largest free fragment is 2048
               RAM used: 70 (19%) at main() level
                         115 (32%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  00
0002:  MOVWF  0A
0003:  GOTO   74F
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  MOVLW  8C
001A:  MOVWF  04
001B:  BTFSS  00.1
001C:  GOTO   01F
001D:  BTFSC  0C.1
001E:  GOTO   032
001F:  MOVF   22,W
0020:  MOVWF  04
0021:  MOVF   23,W
0022:  MOVWF  77
0023:  MOVF   24,W
0024:  MOVWF  78
0025:  MOVF   25,W
0026:  MOVWF  79
0027:  MOVF   26,W
0028:  MOVWF  7A
0029:  MOVF   27,W
002A:  MOVWF  7B
002B:  MOVF   20,W
002C:  MOVWF  0A
002D:  SWAPF  21,W
002E:  MOVWF  03
002F:  SWAPF  7F,F
0030:  SWAPF  7F,W
0031:  RETFIE
0032:  BCF    0A.3
0033:  BCF    0A.4
0034:  GOTO   035
....................  // version V2.0 du 27/08/2005  
.................... // maj : nouvelle valeur pour le calcul des tension PANSOL et VBAT  
....................   
.................... #include <16F876a.h> //mettre #include <16F876.h> si PIC16F876-04 // 
....................  //////// Standard Header file for the PIC16F876A device ////////////////  
.................... #device PIC16F876A  
.................... #list  
....................  
.................... #device ICD=TRUE  
.................... #device *=16  
.................... #device ADC=10  
.................... #use delay(clock=2500000)  
*
004B:  MOVLW  62
004C:  MOVWF  04
004D:  BCF    03.7
004E:  MOVF   00,W
004F:  BTFSC  03.2
0050:  GOTO   057
0051:  MOVLW  CF
0052:  MOVWF  77
0053:  DECFSZ 77,F
0054:  GOTO   053
0055:  DECFSZ 00,F
0056:  GOTO   051
0057:  BCF    0A.3
0058:  BCF    0A.4
0059:  GOTO   20A (RETURN)
.................... #fuses XT, NOPROTECT, BROWNOUT, NOWDT  
.................... #zero_ram                           //remet la ram a 0 (initialise les variables a 0)  
....................   
.................... #include "can.c"                    //driver can a consulter pour bits utilises 
....................  /////////////////////////////////////////////////////////////////////////  
.................... ////                        can-mcp2510.c                            ////  
.................... //// CAN Library routines for Microchip's MCP2510 (and compatable)   ////  
.................... //// CAN IO expanders.                                               ////  
.................... ////                                                                 ////  
.................... //// This library provides the following functions:                  ////  
.................... ////  (for more information on these functions see the comment       ////  
.................... ////   header above each function)                                   ////  
.................... ////                                                                 ////  
.................... ////    can_init - Configures the MCP2510 CAN peripheral             ////  
.................... ////                                                                 ////  
.................... ////    can_set_baud - Sets the baud rate control registers          ////  
.................... ////                                                                 ////  
.................... ////    can_set_mode - Sets the CAN module into a specific mode      ////  
.................... ////                                                                 ////  
.................... ////    can_set_id - Sets the standard and extended ID               ////  
.................... ////                                                                 ////  
.................... ////    can_get_id - Gets the standard and extended ID               ////  
.................... ////                                                                 ////  
.................... ////    can_putd - Sends a message/request with specified ID         ////  
.................... ////                                                                 ////  
.................... ////    can_getd - Returns specifid message/request and ID           ////  
.................... ////                                                                 ////  
.................... ////    can_kbhit - Returns true if there is data in one of the      ////  
.................... ////                receive buffers                                  ////  
.................... ////                                                                 ////  
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    ////  
.................... ////              send more data                                     ////  
.................... ////                                                                 ////  
.................... ////    can_abort - Aborts all pending transmissions                 ////  
.................... ////                                                                 ////  
.................... //// You will need a CAN transeiver to connect CANRX and CANTX       ////  
.................... //// pins to CANH and CANL bus lines.                                ////  
.................... ////                                                                 ////  
.................... //// CCS provides an example, ex_can_ccs_b.c, which shows how to use ////  
.................... //// this library with CCS's CAN Prototype board.                    ////  
.................... ////                                                                 ////  
.................... /////////////////////////////////////////////////////////////////////////  
.................... ////                                                                 ////  
.................... //// Version History                                                 ////  
.................... ////                                                                 ////  
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     ////  
.................... ////              setting all RX filters to extended.                ////  
.................... ////                                                                 ////  
.................... ////  Apr 20 04 - Fixed a compling problem.                          ////  
.................... ////                                                                 ////  
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 ////  
.................... ////                                                                 ////  
.................... /////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         ////  
.................... //// This source code may only be used by licensed users of the CCS  ////  
.................... //// C compiler.  This source code may only be distributed to other  ////  
.................... //// licensed users of the CCS C compiler.  No other use,            ////  
.................... //// reproduction or distribution is permitted without written       ////  
.................... //// permission.  Derivative programs created using this software    ////  
.................... //// in object code form are not restricted in any way.              ////  
.................... /////////////////////////////////////////////////////////////////////////  
....................   
.................... #include <can.h> 
....................  /////////////////////////////////////////////////////////////////////////  
.................... ////                        can-mcp2510.h                            ////  
.................... ////                                                                 ////  
.................... //// Prototypes, definitions, defines and macros used for and with   ////  
.................... //// the CCS CAN library for the MCP2510 (and compatable) CAN IO     ////  
.................... //// expanders.                                                      ////  
.................... ////                                                                 ////  
.................... //// (see can-mcp2510.c)                                             ////  
.................... ////                                                                 ////  
.................... /////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         ////  
.................... //// This source code may only be used by licensed users of the CCS  ////  
.................... //// C compiler.  This source code may only be distributed to other  ////  
.................... //// licensed users of the CCS C compiler.  No other use,            ////  
.................... //// reproduction or distribution is permitted without written       ////  
.................... //// permission.  Derivative programs created using this software    ////  
.................... //// in object code form are not restricted in any way.              ////  
.................... /////////////////////////////////////////////////////////////////////////  
....................   
....................   
.................... #ifndef CAN_DO_DEBUG  
....................  #define CAN_DO_DEBUG FALSE  
.................... #endif  
....................   
.................... #IFNDEF CAN_USE_EXTENDED_ID  
....................   #define CAN_USE_EXTENDED_ID         TRUE  
.................... #ENDIF  
....................   
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH  
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq)  
.................... #ENDIF  
....................   
.................... #IFNDEF CAN_BRG_PRESCALAR  
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc )  
.................... #ENDIF  
....................   
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS  
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable)  
.................... #endif  
....................   
.................... #ifndef CAN_BRG_SAM  
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point)  
.................... #endif  
....................   
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1  
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq)  
.................... #endif  
....................   
.................... #ifndef CAN_BRG_PROPAGATION_TIME  
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq)  
.................... #endif  
....................   
.................... #ifndef CAN_BRG_WAKE_FILTER  
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit  
.................... #endif  
....................   
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2  
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq)  
.................... #endif  
....................   
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER  
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data  
.................... #endif  
....................   
.................... #ifndef CAN_ENABLE_DRIVE_HIGH  
....................  #define CAN_ENABLE_DRIVE_HIGH 0  
.................... #endif  
....................   
.................... #ifndef CAN_ENABLE_CAN_CAPTURE  
....................  #define CAN_ENABLE_CAN_CAPTURE 0  
.................... #endif  
....................   
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_SLEEP=1, CAN_OP_NORMAL=0};  
....................   
.................... //can control  
.................... struct struct_CANCTRL {  
....................    int  clkpre:2; //0:1 //clkout pin prescalar  
....................    int1 clken; //2   //clkout pin enable  
....................    int1 void3; //3  
....................    int1 abat;  //4   //abort all pending transmissions  
....................    CAN_OP_MODE reqop:3; //5:7 //request operation mode  
.................... };  
.................... #define CANCTRL   0x0F  //or 1f, or 2f, or 3f ... or 7f  
....................   
.................... enum CAN_INT_CODE {CAN_INT_RX1=7, CAN_INT_RX0=6, CAN_INT_TX2=5, CAN_INT_TX1=4, CAN_INT_TX0=3, CAN_INT_WAKEUP=2, CAN_INT_ERROR=1, CAN_INT_NO=0};  
....................   
.................... //can status register READ-ONLY  
.................... struct struct_CANSTAT {  
.................... 	int1 void0;	//0  
.................... 	CAN_INT_CODE icode:3;	//1:3	//interrupt code  
.................... 	int1 void4;	//4  
.................... 	CAN_OP_MODE opmode:3;	//5:7	//operation mode status  
.................... };  
.................... #define CANSTAT 0x0E //or 1e, or 2e ... or 7e  
....................   
.................... //error flag register  
.................... struct struct_EFLG {  
.................... 	int1 ewarn;		//0 //error warning  
.................... 	int1 rxwar;		//1 //receiver warning  
.................... 	int1 txwar;		//2 //transmitter warning  
.................... 	int1 rxep;	//3 //receive error passive flag  
.................... 	int1 txep;	//4 //transmit error passive flag  
.................... 	int1 txbo;	//5	//bus off error flag  
.................... 	int1 rx0ovr;	//6	//receive buffer 0 overflow  
.................... 	int1 rx1ovr;	//7	//receive buffer 1 overflow  
.................... };  
.................... #define EFLG   0x2D  
....................   
.................... //interupt enable register  
.................... struct struct_CANINTE {  
....................    int1 rx0ie; //0   //receive buffer 0 full interrupt enable  
....................    int1 rx1ie; //1   //receive buffer 1 full interrupt enable  
....................    int1 tx0ie; //2   //transmit buffer 0 embty interrupt enable  
....................    int1 tx1ie; //3   //transmit buffer 1 embty interrupt enable  
....................    int1 tx2ie; //4   //transmit buffer 2 embty interrupt enable  
....................    int1 errie; //5   //error interrupt enable  
....................    int1 wakie; //6   //wakeup interrupt  enable  
....................    int1 merre; //7   //message error interrupt enable  
.................... };  
.................... #define CANINTE   0x2B  
....................   
.................... //interupt enable register  
.................... struct struct_CANINTF {  
....................    int1 rx0if; //0   //receive buffer 0 full interrupt flag  
....................    int1 rx1if; //1   //receive buffer 1 full interrupt flag  
....................    int1 tx0if; //2   //transmit buffer 0 embty interrupt flag  
....................    int1 tx1if; //3   //transmit buffer 1 embty interrupt flag  
....................    int1 tx2if; //4   //transmit buffer 2 embty interrupt flag  
....................    int1 errif; //5   //error interrupt flag  
....................    int1 wakif; //6   //wakeup interrupt flag  
....................    int1 merrf; //7   //message error interrupt flag  
.................... };  
.................... #define CANINTF   0x2C  
....................   
....................   
.................... //error counters  
.................... #define TEC    0x1C  
.................... #define REC    0x1D  
....................   
.................... //baud rate control register 1  
.................... struct struct_CNF1 {  
.................... 	int brp:6;	//0:5	//baud rate prescalar  
.................... 	int sjw:2;	//6:7	//synchronized jump width  
.................... };  
.................... #define CNF1   0x2A  
....................   
.................... //baud rate control register 2  
.................... struct struct_CNF2 {  
.................... 	int prseg:3; //0:2 //propagation time select  
.................... 	int phseg1:3; //3:5 //phase segment 1  
.................... 	int1 sam; //6 //sample of the can bus line  
.................... 	int1 btlmode; //7 //phase segment 2 bit time length  
.................... };  
.................... #define CNF2   0x29  
....................   
.................... //baud rate control register 3  
.................... struct struct_CNF3 {  
.................... 	int phseg2:3;	//0:2	//phase segment 2 time select  
.................... 	int void543:3;	//3:5  
.................... 	int1 wakfil;	//6 //selects can bus line filter for wake-up  
.................... 	int1 void7;	//7  
.................... };  
.................... #define CNF3   0x28  
.................... //can i/o control register  
....................   
.................... //transmit buffer n control register  
.................... struct txbNctrl_struct {  
.................... 	int  txpri:2;	//0:1	//transmit priority bits  
.................... 	int1 void2; //2  
.................... 	int1 txreq;	//3	//transmit request status (clear to request message abort)  
.................... 	int1 txerr;	//4	//transmission error detected  
.................... 	int1 mloa;	//5	//message lost arbitration  
.................... 	int1 abtf;	//6	//message was aborted / or transmitted succesfully  
.................... 	int1 void7;  
.................... };  
.................... #define TXB0CTRL  0x30  
.................... #define TXB1CTRL  0x40  
.................... #define TXB2CTRL  0x50  
....................   
.................... //TXnRTS pin control and status register  
.................... struct struct_TXRTSCTRL {  
....................    int1 b0rtsm; //0  //1=request message trans, 0=digital  
....................    int1 b1rtsm; //1  //1=request message trans, 0=digital  
....................    int1 b2rtsm; //2  //1=request message trans, 0=digital  
....................    int1 b0rts; //3   //reads as tx2rts when in digital, 0 when in rts  
....................    int1 b1rts; //4   //reads as tx2rts when in digital, 0 when in rts mode  
....................    int1 b2rts; //5  //reads as tx2rts when in digital, 0 when in rts mode  
....................    int  void67:2; //6:7  
.................... };  
.................... #define TXRTSCTRL 0x0D  
....................   
.................... //transmit buffer n standard identifier  
.................... #define TXB0SIDH 0x31  
.................... #define TXB0SIDL 0x32  
.................... #define TXB1SIDH 0x41  
.................... #define TXB1SIDL 0x42  
.................... #define TXB2SIDH 0x51  
.................... #define TXB2SIDL 0x52  
....................   
.................... //transmit buffer n extended identifier  
.................... #define TXB0EIDH 0x33  
.................... #define TXB0EIDL 0x34  
.................... #define TXB1EIDH 0x43  
.................... #define TXB1EIDL 0x44  
.................... #define TXB2EIDH 0x53  
.................... #define TXB2EIDL 0x54  
....................   
.................... //transmit buffer n data byte m  
.................... #define TXB0D0 0x36  
.................... #define TXB0D7 0x3D  
....................   
.................... #define TXB1D0 0x46  
.................... #define TXB1D7 0x4D  
....................   
.................... #define TXB2D0 0x56  
.................... #define TXB2D7 0x5D  
....................   
.................... //transmit buffer n data length  
.................... struct txbNdlc_struct {  
.................... 	int dlc:4;	//0:3  
.................... 	int void54:2; //4:5  
.................... 	int1 rtr; //6 //transmission frame remote tranmission  
.................... 	int1 void7; //7  
.................... };  
.................... #define TXB0DLC 0x35  
.................... #define TXB1DLC 0x45  
.................... #define TXB2DLC 0x55  
....................   
.................... //#byte TXBaDLC=0xF65  //txbXdlc when in the access bank  
....................   
....................   
.................... //transmit error count register  
.................... #byte TXERRCNT=0xF76  
....................   
....................   
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0};  
....................   
.................... //receive buffer 0 control register  
.................... struct struct_RXB0CTRL {  
.................... 	int1 filhit0;	//0 //filter hit  
.................... 	int1 bukt1;	//1 //read only copy of bukt bit (used internally by mcp2510)  
.................... 	int1 bukt;	//2 //rollover enable  
.................... 	int1 rxrtr;	//3 //receive remote transfer request  
.................... 	int1 void4;	//4  
.................... 	CAN_RX_MODE rxm:2;	//5:6 //receiver buffer mode  
.................... 	int1 void7;	//7 //receive full status  
.................... };  
.................... #define RXB0CTRL  0x60  
....................   
.................... //receive buffer 1 control register  
.................... struct struct_RXB1CTRL {  
.................... 	int filhit0:3;	//0:2  
.................... 	int1 rxrtr;	//3 //receive remote transfer request  
.................... 	int1 void4;	//4  
.................... 	CAN_RX_MODE rxm:2;	//5:6 //receive buffer mode  
.................... 	int1 void7;	//7  
.................... };  
.................... #define RXB1CTRL 0x70  
....................   
.................... //RXnBF pint control and status register  
.................... struct struct_BFPCTRL {  
....................    int1  b0bfm; //0   //1=pin is interrupt when message loaded into rxb0, 0=digital  
....................    int1  b1bfm; //1   //1=pin is interrupt when message loaded into rxb1, 0=digital  
....................    int1  b0bfe; //2   //rx0bf pin function enable  
....................    int1  b1bfe; //3   //rx1bf pin function enable  
....................    int1  b0bfs; //4   //rx0bf pin state  
....................    int1  b1bfs; //5   //rx1bf pin state  
.................... };  
....................   
.................... //receive buffer n standard identifier  
.................... #define	RXB0SIDH  0x61  
.................... #define	RXB0SIDL  0x62  
....................   
.................... #define	RXB1SIDH  0x71  
.................... #define	RXB1SIDL  0x72  
....................   
.................... //receive buffer n extended identifier  
.................... #define	RXB0EID8  0x63  
.................... #define	RXB0EID0  0x64  
....................   
.................... #define	RXB1EID8  0x73  
.................... #define	RXB1EID0  0x74  
....................   
.................... struct struct_TXRXBaSIDL {  
....................    int void012:3; //0:2  
....................    int1 ext;      //3 //extendid id  
....................    int1 srr;      //4 //substitute remove request bit  
....................    int void567:3; //5:7  
.................... };  
....................   
.................... //receive buffer n data length code register  
.................... struct rxbNdlc_struct {  
.................... 	int dlc:4;	//0:3 //data length code  
.................... 	int1 rb0;   //4   //reserved  
.................... 	int1 rb1;	//5   //reserved  
.................... 	int1 rtr;	//6   //receiver remote transmission request bit  
.................... 	int1 void7;	//7  
.................... };  
.................... #define	RXB0DLC   0x65  
.................... #define	RXB1DLC   0x75  
....................   
.................... //receive buffer n data field byte m register  
.................... #define RXB0D0    0x66  
.................... #define RXB0D7    0x6D  
....................   
.................... #define RXB1D0    0x76  
.................... #define RXB1D7    0x7D  
....................   
....................   
.................... //receive acceptance filter n standard indifier  
.................... #define RXF0SIDH  0x00  
.................... #define RXF0SIDL  0x01  
.................... #define RXF1SIDH  0x04  
.................... #define RXF1SIDL  0x05  
.................... #define RXF2SIDH  0x08  
.................... #define RXF2SIDL  0x09  
.................... #define RXF3SIDH  0x10  
.................... #define RXF3SIDL  0x11  
.................... #define RXF4SIDH  0x14  
.................... #define RXF4SIDL  0x15  
.................... #define RXF5SIDH  0x18  
.................... #define RXF5SIDL  0x19  
....................   
.................... //receive acceptance filter n extended indifier  
.................... #define RXF0EIDH  0x02  
.................... #define RXF0EIDL  0x03  
.................... #define RXF1EIDH  0x06  
.................... #define RXF1EIDL  0x07  
.................... #define RXF2EIDH  0x0a  
.................... #define RXF2EIDL  0x0b  
.................... #define RXF3EIDH  0x12  
.................... #define RXF3EIDL  0x13  
.................... #define RXF4EIDH  0x16  
.................... #define RXF4EIDL  0x17  
.................... #define RXF5EIDH  0x1a  
.................... #define RXF5EIDL  0x1b  
....................   
.................... //receive acceptance mask n standard identifer mask  
.................... #define RXM0SIDH  0x20  
.................... #define RXM0SIDL  0x21  
.................... #define RXM1SIDH  0x24  
.................... #define RXM1SIDL  0x25  
....................   
.................... //receive acceptance mask n extended identifer mask  
.................... #define RXM0EIDH  0x22  
.................... #define RXM0EIDL  0x23  
.................... #define RXM1EIDH  0x26  
.................... #define RXM1EIDL  0x27  
....................   
.................... #define RX0MASK       RXM0EIDL   //rxm0eidl  
.................... #define RX1MASK       RXM1EIDL   //rxm1eidl  
.................... #define RX0FILTER0    RXF0EIDL   //rxf0eidl  
.................... #define RX0FILTER1    RXF1EIDL   //rxf1eidl  
.................... #define RX1FILTER2    RXF2EIDL   //rxf2eidl  
.................... #define RX1FILTER3    RXF3EIDL   //rxf3eidl  
.................... #define RX1FILTER4    RXF4EIDL   //rxf4eidl  
.................... #define RX1FILTER5    RXF5EIDL   //rxf5eidl  
.................... #define RXB0ID        RXB0EIDL   //rxb0eidl  
.................... #define RXB1ID        RXB1EIDL   //rxb1eidl  
.................... #define TXB0ID        TXB0EIDL   //txb0eidl  
.................... #define TXB1ID        TXB1EIDL   //txb1eidl  
.................... #define TXB2ID        TXB2EIDL   //tsb2eidl  
....................   
.................... //value to put in mask field to accept all incoming id's  
.................... #define CAN_MASK_ACCEPT_ALL   0  
....................   
....................   
.................... //PROTOTYPES and MACROS  
....................   
.................... struct rx_stat {  
....................    int1 err_ovfl;  
....................    int filthit:3;  
....................    int1 buffer;  
....................    int1 rtr;  
....................    int1 ext;  
....................    int1 inv;  
.................... };  
....................   
.................... /* variables bus can */  
.................... int32 crx_id;  
.................... int crxbuf[8];  
.................... int ctxbuf[8];  
.................... int ic,crx_len;  
.................... struct rx_stat rxstat;  
....................   
....................   
.................... void  can_init(void);  
.................... void  can_set_baud(void);  
.................... void  can_set_mode(CAN_OP_MODE mode);  
.................... void can_set_id(int addr, int32 id, int1 ext);  
.................... int32 can_get_id(int addr, int1 ext);  
.................... int   can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr);  
.................... int1  can_getd(int32 & id, int * data, int & len, struct rx_stat & stat);  
....................   
.................... void mcp2510_init();  
.................... void mcp2510_command(int command);  
.................... void mcp2510_write(int address, int data);  
.................... int mcp2510_status(void);  
.................... int mcp2510_read(int address);  
....................   
....................   
....................  
....................   
.................... //IO pins connected to MCP2510  
.................... #ifndef EXT_CAN_CS  
....................    #define EXT_CAN_CS   PIN_B3  
....................    #define EXT_CAN_SI   PIN_C5  
....................    #define EXT_CAN_SO   PIN_C4  
....................    #define EXT_CAN_SCK  PIN_C3  
.................... //   #define EXT_CAN_RESET   PIN_B5 //CCS library does not use this pin by default  
.................... //   #define EXT_CAN_TX0RTS  PIN_C4 //CCS library does not use this pin by default  
.................... //   #define EXT_CAN_TX1RTS  PIN_B4 //CCS library does not use this pin by default  
.................... //   #define EXT_CAN_TX2RTS  PIN_C2 //CCS library does not use this pin by default  
.................... #endif  
....................   
.................... #if CAN_DO_DEBUG  
....................  #define can_debug printf  
.................... #else  
....................  #define can_debug  
.................... #endif  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_init()  
.................... //  
.................... // Initializes MCP2510 CAN peripheral.  Sets the RX filter and masks so the  
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers  
.................... // to only accept valid valid messages (as opposed to all messages, or all  
.................... // extended message, or all standard messages).  
.................... //  
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH,  
.................... // CAN_ENABLE_CAN_CAPTURE, etc) are given a default define in the can-mcp2510.h file.  
.................... // These default values can be overwritten in the main code, but most  
.................... // applications will be fine with these defaults.  
.................... //  
.................... //////////////////////////////////////////////////////////////////////////////  
.................... void can_init(void) {  
....................    struct struct_RXB0CTRL b_rxb0ctrl;  
....................   
....................    mcp2510_init();  
....................   
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set  
*
020B:  MOVLW  04
020C:  MOVWF  62
020D:  CALL   0E5
....................    can_set_baud();  
....................   
....................    b_rxb0ctrl=0;  
*
0240:  CLRF   61
....................    b_rxb0ctrl.rxm=CAN_RX_VALID;  
0241:  MOVLW  9F
0242:  ANDWF  61,W
0243:  MOVWF  61
....................    b_rxb0ctrl.bukt=CAN_USE_RX_DOUBLE_BUFFER;  
0244:  BSF    61.2
....................    mcp2510_write(RXB0CTRL, (int)b_rxb0ctrl);  
0245:  MOVLW  60
0246:  BSF    03.5
0247:  MOVWF  2C
0248:  BCF    03.5
0249:  MOVF   61,W
024A:  BSF    03.5
024B:  MOVWF  2D
024C:  BCF    03.5
024D:  CALL   0B1
....................    mcp2510_write(RXB1CTRL, (int)b_rxb0ctrl);  
024E:  MOVLW  70
024F:  BSF    03.5
0250:  MOVWF  2C
0251:  BCF    03.5
0252:  MOVF   61,W
0253:  BSF    03.5
0254:  MOVWF  2D
0255:  BCF    03.5
0256:  CALL   0B1
....................   
....................    //if you want to configure the TXnRTS pins, do it here.  default is off  
....................   
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 (RX BUFFER 0)  
0257:  MOVLW  23
0258:  MOVWF  7C
0259:  BSF    03.5
025A:  CLRF   23
025B:  CLRF   22
025C:  CLRF   21
025D:  CLRF   20
025E:  MOVLW  01
025F:  MOVWF  7D
0260:  BCF    03.5
0261:  CALL   10E
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 (RX BUFFER 0)  
0262:  MOVLW  03
0263:  MOVWF  7C
0264:  BSF    03.5
0265:  CLRF   23
0266:  CLRF   22
0267:  CLRF   21
0268:  CLRF   20
0269:  MOVLW  01
026A:  MOVWF  7D
026B:  BCF    03.5
026C:  CALL   10E
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 (RX BUFFER 0)  
026D:  MOVLW  07
026E:  MOVWF  7C
026F:  BSF    03.5
0270:  CLRF   23
0271:  CLRF   22
0272:  CLRF   21
0273:  CLRF   20
0274:  MOVLW  01
0275:  MOVWF  7D
0276:  BCF    03.5
0277:  CALL   10E
....................   
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 (RX BUFFER 1)  
0278:  MOVLW  27
0279:  MOVWF  7C
027A:  BSF    03.5
027B:  CLRF   23
027C:  CLRF   22
027D:  CLRF   21
027E:  CLRF   20
027F:  MOVLW  01
0280:  MOVWF  7D
0281:  BCF    03.5
0282:  CALL   10E
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 (RX BUFFER 1)  
0283:  MOVLW  0B
0284:  MOVWF  7C
0285:  BSF    03.5
0286:  CLRF   23
0287:  CLRF   22
0288:  CLRF   21
0289:  CLRF   20
028A:  MOVLW  01
028B:  MOVWF  7D
028C:  BCF    03.5
028D:  CALL   10E
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 (RX BUFFER 1)  
028E:  MOVLW  13
028F:  MOVWF  7C
0290:  BSF    03.5
0291:  CLRF   23
0292:  CLRF   22
0293:  CLRF   21
0294:  CLRF   20
0295:  MOVLW  01
0296:  MOVWF  7D
0297:  BCF    03.5
0298:  CALL   10E
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 (RX BUFFER 1)  
0299:  MOVLW  17
029A:  MOVWF  7C
029B:  BSF    03.5
029C:  CLRF   23
029D:  CLRF   22
029E:  CLRF   21
029F:  CLRF   20
02A0:  MOVLW  01
02A1:  MOVWF  7D
02A2:  BCF    03.5
02A3:  CALL   10E
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 (RX BUFFER 1)  
02A4:  MOVLW  1B
02A5:  MOVWF  7C
02A6:  BSF    03.5
02A7:  CLRF   23
02A8:  CLRF   22
02A9:  CLRF   21
02AA:  CLRF   20
02AB:  MOVLW  01
02AC:  MOVWF  7D
02AD:  BCF    03.5
02AE:  CALL   10E
....................   
....................    can_set_mode(CAN_OP_NORMAL);  
02AF:  CLRF   62
02B0:  CALL   0E5
02B1:  NOP
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_set_baud()  
.................... //  
.................... // Configures the baud rate control registers.  All the defines here  
.................... // are defaulted in the can-mcp2510.h file.  These defaults can, and  
.................... // probably should, be overwritten in the main code.  
.................... //  
.................... // Current defaults are set to work with CCS's CAN Prototype board and  
.................... // Microchip's MCP250xxx CAN Developers Kit if this PIC is running at 20Mhz.  
.................... //  
.................... ////////////////////////////////////////////////////////////////////////  
.................... void can_set_baud(void) {  
....................    struct struct_CNF1 new_CNF1;  
....................    struct struct_CNF2 new_CNF2;  
....................    struct struct_CNF3 new_CNF3;  
....................   
....................   
....................    new_CNF1.brp=CAN_BRG_PRESCALAR;  
*
020E:  MOVLW  C0
020F:  ANDWF  62,W
0210:  IORLW  04
0211:  MOVWF  62
....................    new_CNF1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH;  
0212:  MOVLW  3F
0213:  ANDWF  62,W
0214:  MOVWF  62
....................   
....................    new_CNF2.prseg=CAN_BRG_PROPAGATION_TIME;  
0215:  MOVLW  F8
0216:  ANDWF  63,W
0217:  IORLW  02
0218:  MOVWF  63
....................    new_CNF2.phseg1=CAN_BRG_PHASE_SEGMENT_1;  
0219:  MOVLW  C7
021A:  ANDWF  63,W
021B:  IORLW  28
021C:  MOVWF  63
....................    new_CNF2.sam=CAN_BRG_SAM;  
021D:  BCF    63.6
....................    new_CNF2.btlmode=CAN_BRG_SEG_2_PHASE_TS;  
021E:  BSF    63.7
....................   
....................    new_CNF3.phseg2=CAN_BRG_PHASE_SEGMENT_2;  
021F:  MOVLW  F8
0220:  ANDWF  64,W
0221:  IORLW  05
0222:  MOVWF  64
....................    new_CNF3.wakfil=CAN_BRG_WAKE_FILTER;  
0223:  BCF    64.6
....................   
....................    mcp2510_write(CNF1, (int)new_CNF1);  
0224:  MOVLW  2A
0225:  BSF    03.5
0226:  MOVWF  2C
0227:  BCF    03.5
0228:  MOVF   62,W
0229:  BSF    03.5
022A:  MOVWF  2D
022B:  BCF    03.5
022C:  CALL   0B1
....................    mcp2510_write(CNF2, (int)new_CNF2);  
022D:  MOVLW  29
022E:  BSF    03.5
022F:  MOVWF  2C
0230:  BCF    03.5
0231:  MOVF   63,W
0232:  BSF    03.5
0233:  MOVWF  2D
0234:  BCF    03.5
0235:  CALL   0B1
....................    mcp2510_write(CNF3, (int)new_CNF3);  
0236:  MOVLW  28
0237:  BSF    03.5
0238:  MOVWF  2C
0239:  BCF    03.5
023A:  MOVF   64,W
023B:  BSF    03.5
023C:  MOVWF  2D
023D:  BCF    03.5
023E:  CALL   0B1
023F:  NOP
.................... }  
....................   
.................... void can_set_mode(CAN_OP_MODE mode) {  
....................    struct struct_CANCTRL old_CANCTRL;  
....................   
....................    old_CANCTRL=mcp2510_read(CANCTRL);  
*
00E5:  MOVLW  0F
00E6:  BSF    03.5
00E7:  MOVWF  2B
00E8:  BCF    03.5
00E9:  CALL   05A
00EA:  MOVF   78,W
00EB:  MOVWF  63
....................   
....................    old_CANCTRL.reqop=mode;  
00EC:  SWAPF  62,W
00ED:  ANDLW  70
00EE:  MOVWF  77
00EF:  BCF    03.0
00F0:  RLF    77,F
00F1:  MOVLW  1F
00F2:  ANDWF  63,W
00F3:  IORWF  77,W
00F4:  MOVWF  63
....................   
....................    mcp2510_write(CANCTRL, (int)old_CANCTRL);  
00F5:  MOVLW  0F
00F6:  BSF    03.5
00F7:  MOVWF  2C
00F8:  BCF    03.5
00F9:  MOVF   63,W
00FA:  BSF    03.5
00FB:  MOVWF  2D
00FC:  BCF    03.5
00FD:  CALL   0B1
....................   
....................    do {  
....................       old_CANCTRL=mcp2510_read(CANCTRL);  
00FE:  MOVLW  0F
00FF:  BSF    03.5
0100:  MOVWF  2B
0101:  BCF    03.5
0102:  CALL   05A
0103:  MOVF   78,W
0104:  MOVWF  63
....................    } while (old_CANCTRL.reqop != mode);  
0105:  MOVF   63,W
0106:  MOVWF  77
0107:  SWAPF  77,F
0108:  RRF    77,W
0109:  ANDLW  07
010A:  SUBWF  62,W
010B:  BTFSS  03.2
010C:  GOTO   0FE
.................... }  
010D:  RETLW  00
....................   
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_set_id()  
.................... //  
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to  
.................... // configure the defined buffer to use the specified ID  
.................... //  
.................... //   Paramaters:  
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL.  
.................... //            For example, a pointer to RXM1EIDL  
.................... //     id - ID to set buffer to  
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not  
.................... //  
.................... ////////////////////////////////////////////////////////////////////////  
.................... void can_set_id(int addr, int32 id, int1 ext) {  
....................    int converted_id[4];  
....................    int *ptr;  
....................   
....................    ptr=&converted_id[3];   //3=eidl, 2=eidh, 1=sidl, 0=sidh  
010E:  BSF    03.5
010F:  CLRF   29
0110:  MOVLW  A7
0111:  MOVWF  28
....................   
....................    if (ext) {  //extended  
0112:  MOVF   7D,F
0113:  BTFSC  03.2
0114:  GOTO   16E
....................       //eidl  
....................       *ptr=make8(id,0); //0:7  
0115:  MOVF   28,W
0116:  MOVWF  04
0117:  BCF    03.7
0118:  BTFSC  29.0
0119:  BSF    03.7
011A:  MOVF   20,W
011B:  MOVWF  00
....................   
....................       //eidh  
....................       ptr--;  
011C:  MOVF   28,W
011D:  BTFSC  03.2
011E:  DECF   29,F
011F:  DECF   28,F
....................       *ptr=make8(id,1); //8:15  
0120:  MOVF   28,W
0121:  MOVWF  04
0122:  BCF    03.7
0123:  BTFSC  29.0
0124:  BSF    03.7
0125:  MOVF   21,W
0126:  MOVWF  00
....................   
....................       //sidl  
....................       ptr--;  
0127:  MOVF   28,W
0128:  BTFSC  03.2
0129:  DECF   29,F
012A:  DECF   28,F
....................       *ptr=make8(id,2) & 0x03;   //16:17  
012B:  MOVF   28,W
012C:  MOVWF  04
012D:  BCF    03.7
012E:  BTFSC  29.0
012F:  BSF    03.7
0130:  MOVF   22,W
0131:  ANDLW  03
0132:  MOVWF  00
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20  
0133:  MOVF   28,W
0134:  MOVWF  04
0135:  BCF    03.7
0136:  BTFSC  29.0
0137:  BSF    03.7
0138:  MOVF   22,W
0139:  MOVWF  77
013A:  RLF    77,F
013B:  RLF    77,F
013C:  RLF    77,F
013D:  MOVLW  F8
013E:  ANDWF  77,F
013F:  MOVF   77,W
0140:  ANDLW  E0
0141:  IORWF  00,W
0142:  MOVWF  00
....................       *ptr|=0x08;  
0143:  MOVF   28,W
0144:  MOVWF  04
0145:  BCF    03.7
0146:  BTFSC  29.0
0147:  BSF    03.7
0148:  MOVF   00,W
0149:  IORLW  08
014A:  MOVWF  00
....................   
....................   
....................       //sidh  
....................       ptr--;  
014B:  MOVF   28,W
014C:  BTFSC  03.2
014D:  DECF   29,F
014E:  DECF   28,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23  
014F:  MOVF   28,W
0150:  MOVWF  04
0151:  BCF    03.7
0152:  BTFSC  29.0
0153:  BSF    03.7
0154:  MOVF   22,W
0155:  MOVWF  77
0156:  SWAPF  77,F
0157:  RRF    77,F
0158:  MOVLW  07
0159:  ANDWF  77,F
015A:  MOVF   77,W
015B:  ANDLW  07
015C:  MOVWF  00
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28  
015D:  MOVF   28,W
015E:  MOVWF  04
015F:  BCF    03.7
0160:  BTFSC  29.0
0161:  BSF    03.7
0162:  MOVF   23,W
0163:  MOVWF  77
0164:  RLF    77,F
0165:  RLF    77,F
0166:  RLF    77,F
0167:  MOVLW  F8
0168:  ANDWF  77,F
0169:  MOVF   77,W
016A:  ANDLW  F8
016B:  IORWF  00,W
016C:  MOVWF  00
....................    }  
....................    else {   //standard  
016D:  GOTO   1B2
....................       //eidl  
....................       *ptr=0;  
016E:  MOVF   28,W
016F:  MOVWF  04
0170:  BCF    03.7
0171:  BTFSC  29.0
0172:  BSF    03.7
0173:  CLRF   00
....................   
....................       //eidh  
....................       ptr--;  
0174:  MOVF   28,W
0175:  BTFSC  03.2
0176:  DECF   29,F
0177:  DECF   28,F
....................       *ptr=0;  
0178:  MOVF   28,W
0179:  MOVWF  04
017A:  BCF    03.7
017B:  BTFSC  29.0
017C:  BSF    03.7
017D:  CLRF   00
....................   
....................       //sidl  
....................       ptr--;  
017E:  MOVF   28,W
017F:  BTFSC  03.2
0180:  DECF   29,F
0181:  DECF   28,F
....................       *ptr=(make8(id,0) << 5) & 0xE0;  
0182:  MOVF   28,W
0183:  MOVWF  04
0184:  BCF    03.7
0185:  BTFSC  29.0
0186:  BSF    03.7
0187:  MOVF   20,W
0188:  MOVWF  77
0189:  SWAPF  77,F
018A:  RLF    77,F
018B:  MOVLW  E0
018C:  ANDWF  77,F
018D:  MOVF   77,W
018E:  ANDLW  E0
018F:  MOVWF  00
....................   
....................       //sidh  
....................       ptr--;  
0190:  MOVF   28,W
0191:  BTFSC  03.2
0192:  DECF   29,F
0193:  DECF   28,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F;  
0194:  MOVF   28,W
0195:  MOVWF  04
0196:  BCF    03.7
0197:  BTFSC  29.0
0198:  BSF    03.7
0199:  MOVF   20,W
019A:  MOVWF  77
019B:  RRF    77,F
019C:  RRF    77,F
019D:  RRF    77,F
019E:  MOVLW  1F
019F:  ANDWF  77,F
01A0:  MOVF   77,W
01A1:  ANDLW  1F
01A2:  MOVWF  00
....................       *ptr|=(make8(id,1) << 5) & 0xE0;  
01A3:  MOVF   28,W
01A4:  MOVWF  04
01A5:  BCF    03.7
01A6:  BTFSC  29.0
01A7:  BSF    03.7
01A8:  MOVF   21,W
01A9:  MOVWF  77
01AA:  SWAPF  77,F
01AB:  RLF    77,F
01AC:  MOVLW  E0
01AD:  ANDWF  77,F
01AE:  MOVF   77,W
01AF:  ANDLW  E0
01B0:  IORWF  00,W
01B1:  MOVWF  00
....................    }  
....................   
....................    //0=eidl, 1=eidh, 2=sidl, 3=sidh  
....................    mcp2510_write(addr--, converted_id[3]);  
01B2:  MOVF   7C,W
01B3:  DECF   7C,F
01B4:  MOVWF  2A
01B5:  MOVWF  2C
01B6:  MOVF   27,W
01B7:  MOVWF  2D
01B8:  BCF    03.5
01B9:  CALL   0B1
....................    mcp2510_write(addr--, converted_id[2]);  
01BA:  MOVF   7C,W
01BB:  DECF   7C,F
01BC:  BSF    03.5
01BD:  MOVWF  2A
01BE:  MOVWF  2C
01BF:  MOVF   26,W
01C0:  MOVWF  2D
01C1:  BCF    03.5
01C2:  CALL   0B1
....................    mcp2510_write(addr--, converted_id[1]);  
01C3:  MOVF   7C,W
01C4:  DECF   7C,F
01C5:  BSF    03.5
01C6:  MOVWF  2A
01C7:  MOVWF  2C
01C8:  MOVF   25,W
01C9:  MOVWF  2D
01CA:  BCF    03.5
01CB:  CALL   0B1
....................    mcp2510_write(addr, converted_id[0]);  
01CC:  MOVF   7C,W
01CD:  BSF    03.5
01CE:  MOVWF  2C
01CF:  MOVF   24,W
01D0:  MOVWF  2D
01D1:  BCF    03.5
01D2:  CALL   0B1
.................... }  
01D3:  RETLW  00
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_get_id()  
.................... //  
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id())  
.................... // This is used after receiving a message, to see which ID sent the message.  
.................... //  
.................... //   Paramaters:  
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL.  
.................... //            For example, a pointer to RXM1EIDL  
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not  
.................... //  
.................... //   Returns:  
.................... //     The ID of the buffer  
.................... //  
.................... ////////////////////////////////////////////////////////////////////////  
.................... int32 can_get_id(int addr, int1 ext) {  
....................    int32 ret;  
....................    int * ptr;  
....................    int converted_id[4];  
....................   
....................    ptr=&converted_id[3];   //3=eidl, 2=eidh, 1=sidl, 0=sidh  
*
0504:  CLRF   7E
0505:  MOVLW  A7
0506:  MOVWF  7D
....................   
....................    converted_id[3]=mcp2510_read(addr--);  
0507:  MOVF   76,W
0508:  DECF   76,F
0509:  BSF    03.5
050A:  MOVWF  28
050B:  MOVWF  2B
050C:  BCF    03.5
050D:  CALL   05A
050E:  MOVF   78,W
050F:  BSF    03.5
0510:  MOVWF  27
....................    converted_id[2]=mcp2510_read(addr--);  
0511:  MOVF   76,W
0512:  DECF   76,F
0513:  MOVWF  28
0514:  MOVWF  2B
0515:  BCF    03.5
0516:  CALL   05A
0517:  MOVF   78,W
0518:  BSF    03.5
0519:  MOVWF  26
....................    converted_id[1]=mcp2510_read(addr--);  
051A:  MOVF   76,W
051B:  DECF   76,F
051C:  MOVWF  28
051D:  MOVWF  2B
051E:  BCF    03.5
051F:  CALL   05A
0520:  MOVF   78,W
0521:  BSF    03.5
0522:  MOVWF  25
....................    converted_id[0]=mcp2510_read(addr);  
0523:  MOVF   76,W
0524:  MOVWF  2B
0525:  BCF    03.5
0526:  CALL   05A
0527:  MOVF   78,W
0528:  BSF    03.5
0529:  MOVWF  24
....................   
....................    ret=0;  
052A:  CLRF   23
052B:  CLRF   22
052C:  CLRF   21
052D:  CLRF   20
....................   
....................   
....................    if (ext) {  
052E:  MOVF   7C,F
052F:  BTFSC  03.2
0530:  GOTO   5D8
....................       ret=*ptr;  //eidl  
0531:  MOVF   7E,W
0532:  MOVWF  7A
0533:  MOVF   7D,W
0534:  MOVWF  04
0535:  BCF    03.7
0536:  BTFSC  7E.0
0537:  BSF    03.7
0538:  MOVF   00,W
0539:  MOVWF  77
053A:  CLRF   78
053B:  CLRF   79
053C:  CLRF   7A
053D:  MOVF   7A,W
053E:  MOVWF  23
053F:  MOVF   79,W
0540:  MOVWF  22
0541:  MOVF   78,W
0542:  MOVWF  21
0543:  MOVF   77,W
0544:  MOVWF  20
....................   
....................       ptr--;     //eidh  
0545:  MOVF   7D,W
0546:  BTFSC  03.2
0547:  DECF   7E,F
0548:  DECF   7D,F
....................       ret|=((int32)*ptr << 8);  
0549:  MOVF   7D,W
054A:  MOVWF  04
054B:  BCF    03.7
054C:  BTFSC  7E.0
054D:  BSF    03.7
054E:  MOVF   00,W
054F:  CLRF   2B
0550:  CLRF   2A
0551:  CLRF   29
0552:  MOVWF  28
0553:  CLRF   77
0554:  MOVF   77,W
0555:  IORWF  20,F
0556:  MOVF   28,W
0557:  IORWF  21,F
0558:  MOVF   29,W
0559:  IORWF  22,F
055A:  MOVF   2A,W
055B:  IORWF  23,F
....................   
....................       ptr--;     //sidl  
055C:  MOVF   7D,W
055D:  BTFSC  03.2
055E:  DECF   7E,F
055F:  DECF   7D,F
....................       ret|=((int32)*ptr & 0x03) << 16;  
0560:  MOVF   7D,W
0561:  MOVWF  04
0562:  BCF    03.7
0563:  BTFSC  7E.0
0564:  BSF    03.7
0565:  MOVF   00,W
0566:  CLRF   2B
0567:  CLRF   2A
0568:  CLRF   29
0569:  MOVWF  28
056A:  ANDLW  03
056B:  MOVWF  2C
056C:  MOVF   29,W
056D:  ANDLW  00
056E:  MOVWF  2D
056F:  MOVF   2A,W
0570:  ANDLW  00
0571:  MOVWF  2E
0572:  MOVF   2B,W
0573:  ANDLW  00
0574:  MOVWF  2F
0575:  CLRF   77
0576:  CLRF   78
0577:  MOVF   77,W
0578:  IORWF  20,F
0579:  MOVF   78,W
057A:  IORWF  21,F
057B:  MOVF   2C,W
057C:  IORWF  22,F
057D:  MOVF   2D,W
057E:  IORWF  23,F
....................       ret|=((int32)*ptr & 0xE0) << 13;  
057F:  MOVF   7D,W
0580:  MOVWF  04
0581:  BCF    03.7
0582:  BTFSC  7E.0
0583:  BSF    03.7
0584:  MOVF   00,W
0585:  CLRF   2B
0586:  CLRF   2A
0587:  CLRF   29
0588:  MOVWF  28
0589:  ANDLW  E0
058A:  MOVWF  2C
058B:  MOVF   29,W
058C:  ANDLW  00
058D:  MOVWF  2D
058E:  MOVF   2A,W
058F:  ANDLW  00
0590:  MOVWF  2E
0591:  MOVF   2B,W
0592:  ANDLW  00
0593:  MOVWF  2F
0594:  CLRF   77
0595:  RLF    2C,W
0596:  MOVWF  78
0597:  RLF    2D,W
0598:  MOVWF  79
0599:  RLF    2E,W
059A:  MOVWF  7A
059B:  RLF    78,F
059C:  RLF    79,F
059D:  RLF    7A,F
059E:  RLF    78,F
059F:  RLF    79,F
05A0:  RLF    7A,F
05A1:  RLF    78,F
05A2:  RLF    79,F
05A3:  RLF    7A,F
05A4:  RLF    78,F
05A5:  RLF    79,F
05A6:  RLF    7A,F
05A7:  MOVLW  E0
05A8:  ANDWF  78,F
05A9:  MOVF   77,W
05AA:  IORWF  20,F
05AB:  MOVF   78,W
05AC:  IORWF  21,F
05AD:  MOVF   79,W
05AE:  IORWF  22,F
05AF:  MOVF   7A,W
05B0:  IORWF  23,F
....................   
....................       ptr--;     //sidh  
05B1:  MOVF   7D,W
05B2:  BTFSC  03.2
05B3:  DECF   7E,F
05B4:  DECF   7D,F
....................       ret|=((int32)*ptr << 21);  
05B5:  MOVF   7D,W
05B6:  MOVWF  04
05B7:  BCF    03.7
05B8:  BTFSC  7E.0
05B9:  BSF    03.7
05BA:  MOVF   00,W
05BB:  CLRF   2B
05BC:  CLRF   2A
05BD:  CLRF   29
05BE:  MOVWF  28
05BF:  CLRF   77
05C0:  CLRF   78
05C1:  RLF    28,W
05C2:  MOVWF  79
05C3:  RLF    29,W
05C4:  MOVWF  7A
05C5:  RLF    79,F
05C6:  RLF    7A,F
05C7:  RLF    79,F
05C8:  RLF    7A,F
05C9:  RLF    79,F
05CA:  RLF    7A,F
05CB:  RLF    79,F
05CC:  RLF    7A,F
05CD:  MOVLW  E0
05CE:  ANDWF  79,F
05CF:  MOVF   77,W
05D0:  IORWF  20,F
05D1:  MOVF   78,W
05D2:  IORWF  21,F
05D3:  MOVF   79,W
05D4:  IORWF  22,F
05D5:  MOVF   7A,W
05D6:  IORWF  23,F
....................    }  
....................    else {  
05D7:  GOTO   635
....................       ptr-=2;    //sidl  
05D8:  MOVLW  02
05D9:  SUBWF  7D,F
05DA:  MOVLW  00
05DB:  BTFSS  03.0
05DC:  MOVLW  01
05DD:  SUBWF  7E,F
....................       ret=((int32)*ptr & 0xE0) >> 5;  
05DE:  MOVF   7D,W
05DF:  MOVWF  04
05E0:  BCF    03.7
05E1:  BTFSC  7E.0
05E2:  BSF    03.7
05E3:  MOVF   00,W
05E4:  CLRF   2B
05E5:  CLRF   2A
05E6:  CLRF   29
05E7:  MOVWF  28
05E8:  ANDLW  E0
05E9:  MOVWF  2C
05EA:  MOVF   29,W
05EB:  ANDLW  00
05EC:  MOVWF  2D
05ED:  MOVF   2A,W
05EE:  ANDLW  00
05EF:  MOVWF  2E
05F0:  MOVF   2B,W
05F1:  ANDLW  00
05F2:  MOVWF  2F
05F3:  RRF    2F,W
05F4:  MOVWF  23
05F5:  RRF    2E,W
05F6:  MOVWF  22
05F7:  RRF    2D,W
05F8:  MOVWF  21
05F9:  RRF    2C,W
05FA:  MOVWF  20
05FB:  RRF    23,F
05FC:  RRF    22,F
05FD:  RRF    21,F
05FE:  RRF    20,F
05FF:  RRF    23,F
0600:  RRF    22,F
0601:  RRF    21,F
0602:  RRF    20,F
0603:  RRF    23,F
0604:  RRF    22,F
0605:  RRF    21,F
0606:  RRF    20,F
0607:  RRF    23,F
0608:  RRF    22,F
0609:  RRF    21,F
060A:  RRF    20,F
060B:  MOVLW  07
060C:  ANDWF  23,F
....................   
....................       ptr--;     //sidh  
060D:  MOVF   7D,W
060E:  BTFSC  03.2
060F:  DECF   7E,F
0610:  DECF   7D,F
....................       ret|=((int32)*ptr << 3);  
0611:  MOVF   7D,W
0612:  MOVWF  04
0613:  BCF    03.7
0614:  BTFSC  7E.0
0615:  BSF    03.7
0616:  MOVF   00,W
0617:  CLRF   2B
0618:  CLRF   2A
0619:  CLRF   29
061A:  MOVWF  28
061B:  RLF    28,W
061C:  MOVWF  77
061D:  RLF    29,W
061E:  MOVWF  78
061F:  RLF    2A,W
0620:  MOVWF  79
0621:  RLF    2B,W
0622:  MOVWF  7A
0623:  RLF    77,F
0624:  RLF    78,F
0625:  RLF    79,F
0626:  RLF    7A,F
0627:  RLF    77,F
0628:  RLF    78,F
0629:  RLF    79,F
062A:  RLF    7A,F
062B:  MOVLW  F8
062C:  ANDWF  77,F
062D:  MOVF   77,W
062E:  IORWF  20,F
062F:  MOVF   78,W
0630:  IORWF  21,F
0631:  MOVF   79,W
0632:  IORWF  22,F
0633:  MOVF   7A,W
0634:  IORWF  23,F
....................    }  
....................   
....................    return(ret);  
0635:  MOVF   20,W
0636:  MOVWF  77
0637:  MOVF   21,W
0638:  MOVWF  78
0639:  MOVF   22,W
063A:  MOVWF  79
063B:  MOVF   23,W
063C:  MOVWF  7A
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_putd()  
.................... //  
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will  
.................... // send when the CAN bus becomes available.  
.................... //  
.................... //    Paramaters:  
.................... //       id - ID to transmit data as  
.................... //       data - pointer to data to send  
.................... //       len - length of data to send  
.................... //       priority - priority of message.  The higher the number, the  
.................... //                  sooner the CAN peripheral will send the message.  
.................... //                  Numbers 0 through 3 are valid.  
.................... //       ext - TRUE to use an extended ID, FALSE if not  
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT  
.................... //  
.................... //    Returns:  
.................... //       If successful, it will return TRUE  
.................... //       If un-successful, will return FALSE  
.................... //  
.................... ////////////////////////////////////////////////////////////////////////  
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr) {  
....................    int i;  
....................    int port;  
....................   
....................    int TXRXBaD0;  
....................    int TXBaCTRL;  
....................    int TXRXBaEIDL;  
....................    int TXBaDLC;  
....................   
....................    struct txbNctrl_struct b_TXBaCTRL;  
....................    struct rxbNdlc_struct b_TXBaDLC;  
....................    struct txbNctrl_struct b_TXB0CTRL, b_TXB1CTRL, b_TXB2CTRL;  
....................   
....................    b_TXB0CTRL=mcp2510_read(TXB0CTRL);  
*
06AB:  MOVLW  30
06AC:  BSF    03.5
06AD:  MOVWF  2B
06AE:  BCF    03.5
06AF:  CALL   05A
06B0:  MOVF   78,W
06B1:  MOVWF  74
....................    b_TXB1CTRL=mcp2510_read(TXB1CTRL);  
06B2:  MOVLW  40
06B3:  BSF    03.5
06B4:  MOVWF  2B
06B5:  BCF    03.5
06B6:  CALL   05A
06B7:  MOVF   78,W
06B8:  MOVWF  75
....................    b_TXB2CTRL=mcp2510_read(TXB2CTRL);  
06B9:  MOVLW  50
06BA:  BSF    03.5
06BB:  MOVWF  2B
06BC:  BCF    03.5
06BD:  CALL   05A
06BE:  MOVF   78,W
06BF:  MOVWF  76
....................   
....................     // find emtpy transmitter  
....................     //map access bank addresses to empty transmitter  
....................    if (!b_TXB0CTRL.txreq) {  
06C0:  BTFSC  74.3
06C1:  GOTO   6CC
....................       TXRXBaD0=TXB0D0;  
06C2:  MOVLW  36
06C3:  MOVWF  6D
....................       TXBaCTRL=TXB0CTRL;  
06C4:  MOVLW  30
06C5:  MOVWF  6E
....................       TXRXBaEIDL=TXB0EIDL;  
06C6:  MOVLW  34
06C7:  MOVWF  6F
....................       TXBaDLC=TXB0DLC;  
06C8:  MOVLW  35
06C9:  MOVWF  71
....................       port=0;  
06CA:  CLRF   6C
....................    }  
....................    else if (!b_TXB1CTRL.txreq) {  
06CB:  GOTO   6E9
06CC:  BTFSC  75.3
06CD:  GOTO   6D9
....................       TXRXBaD0=TXB1D0;  
06CE:  MOVLW  46
06CF:  MOVWF  6D
....................       TXBaCTRL=TXB1CTRL;  
06D0:  MOVLW  40
06D1:  MOVWF  6E
....................       TXRXBaEIDL=TXB1EIDL;  
06D2:  MOVLW  44
06D3:  MOVWF  6F
....................       TXBaDLC=TXB1DLC;  
06D4:  MOVLW  45
06D5:  MOVWF  71
....................       port=1;  
06D6:  MOVLW  01
06D7:  MOVWF  6C
....................    }  
....................    else if (!b_TXB2CTRL.txreq) {  
06D8:  GOTO   6E9
06D9:  BTFSC  76.3
06DA:  GOTO   6E6
....................       TXRXBaD0=TXB2D0;  
06DB:  MOVLW  56
06DC:  MOVWF  6D
....................       TXBaCTRL=TXB2CTRL;  
06DD:  MOVLW  50
06DE:  MOVWF  6E
....................       TXRXBaEIDL=TXB2EIDL;  
06DF:  MOVLW  54
06E0:  MOVWF  6F
....................       TXBaDLC=TXB2DLC;  
06E1:  MOVLW  55
06E2:  MOVWF  71
....................       port=2;  
06E3:  MOVLW  02
06E4:  MOVWF  6C
....................    }  
....................    else {  
06E5:  GOTO   6E9
....................       #if CAN_DO_DEBUG  
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n");  
....................       #endif  
....................       return(0);  
06E6:  MOVLW  00
06E7:  MOVWF  78
06E8:  GOTO   74C
....................    }  
....................   
....................    //set priority.  
....................    b_TXBaCTRL=mcp2510_read(TXBaCTRL);  
06E9:  MOVF   6E,W
06EA:  BSF    03.5
06EB:  MOVWF  2B
06EC:  BCF    03.5
06ED:  CALL   05A
06EE:  MOVF   78,W
06EF:  MOVWF  72
....................    b_TXBaCTRL.txpri=priority;  
06F0:  MOVF   68,W
06F1:  ANDLW  03
06F2:  MOVWF  77
06F3:  MOVLW  FC
06F4:  ANDWF  72,W
06F5:  IORWF  77,W
06F6:  MOVWF  72
....................    mcp2510_write(TXBaCTRL, (int)b_TXBaCTRL);  
06F7:  MOVF   6E,W
06F8:  BSF    03.5
06F9:  MOVWF  2C
06FA:  MOVF   72,W
06FB:  MOVWF  2D
06FC:  BCF    03.5
06FD:  CALL   0B1
....................   
....................    //set tx mask  
....................    can_set_id(TXRXBaEIDL, id, ext);  
06FE:  MOVF   6F,W
06FF:  MOVWF  7C
0700:  MOVF   64,W
0701:  BSF    03.5
0702:  MOVWF  23
0703:  BCF    03.5
0704:  MOVF   63,W
0705:  BSF    03.5
0706:  MOVWF  22
0707:  BCF    03.5
0708:  MOVF   62,W
0709:  BSF    03.5
070A:  MOVWF  21
070B:  BCF    03.5
070C:  MOVF   61,W
070D:  BSF    03.5
070E:  MOVWF  20
070F:  BCF    03.5
0710:  MOVF   69,W
0711:  MOVWF  7D
0712:  CALL   10E
....................   
....................    //set tx data count  
....................    b_TXBaDLC=len;  
0713:  MOVF   67,W
0714:  MOVWF  73
....................    b_TXBaDLC.rtr=rtr;  
0715:  BCF    73.6
0716:  BTFSC  6A.0
0717:  BSF    73.6
....................    mcp2510_write(TXBaDLC, (int)b_TXBaDLC);  
0718:  MOVF   71,W
0719:  BSF    03.5
071A:  MOVWF  2C
071B:  MOVF   73,W
071C:  MOVWF  2D
071D:  BCF    03.5
071E:  CALL   0B1
....................   
....................    //write to buffer  
....................     for (i=TXRXBaD0; i<(TXRXBaD0 + len); i++) {  
071F:  MOVF   6D,W
0720:  MOVWF  6B
0721:  MOVF   67,W
0722:  ADDWF  6D,W
0723:  SUBWF  6B,W
0724:  BTFSC  03.0
0725:  GOTO   73B
....................       mcp2510_write(i,*data);  
0726:  MOVF   66,W
0727:  MOVWF  7A
0728:  MOVF   65,W
0729:  MOVWF  04
072A:  BCF    03.7
072B:  BTFSC  66.0
072C:  BSF    03.7
072D:  MOVF   00,W
072E:  MOVWF  7C
072F:  MOVF   6B,W
0730:  BSF    03.5
0731:  MOVWF  2C
0732:  MOVF   7C,W
0733:  MOVWF  2D
0734:  BCF    03.5
0735:  CALL   0B1
....................       data++;  
0736:  INCF   65,F
0737:  BTFSC  03.2
0738:  INCF   66,F
....................     }  
0739:  INCF   6B,F
073A:  GOTO   721
....................   
....................    //enable transmission  
....................    b_TXBaCTRL=mcp2510_read(TXBaCTRL);  
073B:  MOVF   6E,W
073C:  BSF    03.5
073D:  MOVWF  2B
073E:  BCF    03.5
073F:  CALL   05A
0740:  MOVF   78,W
0741:  MOVWF  72
....................    b_TXBaCTRL.txreq=1;  
0742:  BSF    72.3
....................    mcp2510_write(TXBaCTRL, (int)b_TXBaCTRL);  
0743:  MOVF   6E,W
0744:  BSF    03.5
0745:  MOVWF  2C
0746:  MOVF   72,W
0747:  MOVWF  2D
0748:  BCF    03.5
0749:  CALL   0B1
....................   
....................    #if CAN_DO_DEBUG  
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr);  
....................             if ((len)&&(!rtr)) {  
....................                data-=len;  
....................                can_debug("  DATA = ");  
....................                for (i=0;i<len;i++) {  
....................                   can_debug("%X ",*data);  
....................                   data++;  
....................                }  
....................                can_debug("\r\n");  
....................             }  
....................    #endif  
....................   
....................    return(1);  
074A:  MOVLW  01
074B:  MOVWF  78
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_getd()  
.................... //  
.................... // Gets data from a receive buffer, if the data exists  
.................... //  
.................... //    Returns:  
.................... //      id - ID who sent message  
.................... //      data - pointer to array of data  
.................... //      len - length of received data  
.................... //      stat - structure holding some information (such as which buffer  
.................... //             recieved it, ext or standard, etc)  
.................... //  
.................... //    Returns:  
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE  
.................... //      if there was none.  
.................... //  
.................... ////////////////////////////////////////////////////////////////////////  
.................... int1 can_getd(int32 & id, int * data, int & len, struct rx_stat & stat)  
.................... {  
....................     int i;  
....................   
....................    struct struct_RXB0CTRL b_RXB0CTRL;  
....................    struct struct_RXB1CTRL b_RXB1CTRL;  
....................    struct struct_EFLG b_EFLG;  
....................   
....................    int RXBaDLC;  
....................    struct rxbNdlc_struct b_RXBaDLC;  
....................   
....................    int TXRXBaSIDL;  
....................    struct struct_TXRXBaSIDL b_TXRXBaSIDL;  
....................   
....................   
....................    int RXBaD0;  
....................    struct struct_CANINTF b_CANINTF;  
....................   
....................    b_CANINTF=mcp2510_read(CANINTF);  
*
047E:  MOVLW  2C
047F:  BSF    03.5
0480:  MOVWF  2B
0481:  BCF    03.5
0482:  CALL   05A
0483:  MOVF   78,W
0484:  MOVWF  6C
....................   
....................    b_RXB0CTRL=mcp2510_read(RXB0CTRL);  
0485:  MOVLW  60
0486:  BSF    03.5
0487:  MOVWF  2B
0488:  BCF    03.5
0489:  CALL   05A
048A:  MOVF   78,W
048B:  MOVWF  64
....................    b_RXB1CTRL=mcp2510_read(RXB1CTRL);  
048C:  MOVLW  70
048D:  BSF    03.5
048E:  MOVWF  2B
048F:  BCF    03.5
0490:  CALL   05A
0491:  MOVF   78,W
0492:  MOVWF  65
....................    b_EFLG=mcp2510_read(EFLG);  
0493:  MOVLW  2D
0494:  BSF    03.5
0495:  MOVWF  2B
0496:  BCF    03.5
0497:  CALL   05A
0498:  MOVF   78,W
0499:  MOVWF  66
....................   
....................     if (b_CANINTF.rx0if) {  
049A:  BTFSS  6C.0
049B:  GOTO   4BE
....................         stat.buffer=0;  
049C:  BCF    3E.4
....................   
....................         stat.err_ovfl=b_EFLG.rx0ovr;  
049D:  BCF    3E.0
049E:  BTFSC  66.6
049F:  BSF    3E.0
....................         b_EFLG.rx0ovr=0;  
04A0:  BCF    66.6
....................         mcp2510_write(EFLG, (int)b_EFLG);  
04A1:  MOVLW  2D
04A2:  BSF    03.5
04A3:  MOVWF  2C
04A4:  BCF    03.5
04A5:  MOVF   66,W
04A6:  BSF    03.5
04A7:  MOVWF  2D
04A8:  BCF    03.5
04A9:  CALL   0B1
....................   
....................         if (b_RXB0CTRL.bukt) {  
04AA:  BTFSS  64.2
04AB:  GOTO   4B7
....................          stat.filthit=b_RXB0CTRL.filhit0;  
04AC:  MOVLW  00
04AD:  BTFSC  64.0
04AE:  MOVLW  01
04AF:  ANDLW  07
04B0:  MOVWF  77
04B1:  BCF    03.0
04B2:  RLF    77,F
04B3:  MOVLW  F1
04B4:  ANDWF  3E,W
04B5:  IORWF  77,W
04B6:  MOVWF  3E
....................         }  
....................   
....................         RXBaDLC=RXB0DLC;  
04B7:  MOVLW  65
04B8:  MOVWF  67
....................         TXRXBaSIDL=RXB0SIDL;  
04B9:  MOVLW  62
04BA:  MOVWF  69
....................         RXBaD0=RXB0D0;  
04BB:  MOVLW  66
04BC:  MOVWF  6B
....................     }  
....................     else if (b_CANINTF.rx1if)  
04BD:  GOTO   4E2
04BE:  BTFSS  6C.1
04BF:  GOTO   4DF
....................     {  
....................         stat.buffer=1;  
04C0:  BSF    3E.4
....................   
....................         stat.err_ovfl=b_EFLG.rx1ovr;  
04C1:  BCF    3E.0
04C2:  BTFSC  66.7
04C3:  BSF    3E.0
....................         b_EFLG.rx1ovr=0;  
04C4:  BCF    66.7
....................         mcp2510_write(EFLG, (int)b_EFLG);  
04C5:  MOVLW  2D
04C6:  BSF    03.5
04C7:  MOVWF  2C
04C8:  BCF    03.5
04C9:  MOVF   66,W
04CA:  BSF    03.5
04CB:  MOVWF  2D
04CC:  BCF    03.5
04CD:  CALL   0B1
....................   
....................   
....................         stat.filthit=b_RXB1CTRL.filhit0;  
04CE:  MOVF   65,W
04CF:  ANDLW  07
04D0:  ANDLW  07
04D1:  MOVWF  77
04D2:  BCF    03.0
04D3:  RLF    77,F
04D4:  MOVLW  F1
04D5:  ANDWF  3E,W
04D6:  IORWF  77,W
04D7:  MOVWF  3E
....................         RXBaDLC=RXB1DLC;  
04D8:  MOVLW  75
04D9:  MOVWF  67
....................         TXRXBaSIDL=RXB1SIDL;  
04DA:  MOVLW  72
04DB:  MOVWF  69
....................         RXBaD0=RXB1D0;  
04DC:  MOVLW  76
04DD:  MOVWF  6B
....................     }  
....................     else {  
04DE:  GOTO   4E2
....................       #if CAN_DO_DEBUG  
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n");  
....................       #endif  
....................       return (0);  
04DF:  MOVLW  00
04E0:  MOVWF  78
04E1:  GOTO   67A
....................     }  
....................   
....................    //get count  
....................     b_RXBaDLC=mcp2510_read(RXBaDLC);  
04E2:  MOVF   67,W
04E3:  BSF    03.5
04E4:  MOVWF  2B
04E5:  BCF    03.5
04E6:  CALL   05A
04E7:  MOVF   78,W
04E8:  MOVWF  68
....................     len = b_RXBaDLC.dlc;  
04E9:  MOVF   68,W
04EA:  ANDLW  0F
04EB:  MOVWF  3D
....................     stat.rtr=b_RXBaDLC.rtr;  
04EC:  BCF    3E.5
04ED:  BTFSC  68.6
04EE:  BSF    3E.5
....................   
....................    //was it extended or standard? 
....................     b_TXRXBaSIDL=mcp2510_read(TXRXBaSIDL);  
04EF:  MOVF   69,W
04F0:  BSF    03.5
04F1:  MOVWF  2B
04F2:  BCF    03.5
04F3:  CALL   05A
04F4:  MOVF   78,W
04F5:  MOVWF  6A
....................     stat.ext=b_TXRXBaSIDL.ext;  
04F6:  BCF    3E.6
04F7:  BTFSC  6A.3
04F8:  BSF    3E.6
....................     id=can_get_id(TXRXBaSIDL + 2,stat.ext);  
04F9:  MOVLW  02
04FA:  ADDWF  69,W
04FB:  MOVWF  6D
04FC:  MOVLW  00
04FD:  BTFSC  3E.6
04FE:  MOVLW  01
04FF:  MOVWF  6E
0500:  MOVF   6D,W
0501:  MOVWF  76
0502:  MOVF   6E,W
0503:  MOVWF  7C
*
063D:  MOVF   7A,W
063E:  BCF    03.5
063F:  MOVWF  2B
0640:  MOVF   79,W
0641:  MOVWF  2A
0642:  MOVF   78,W
0643:  MOVWF  29
0644:  MOVF   77,W
0645:  MOVWF  28
....................   
....................    //get data  
....................     for ( i = RXBaD0; i < (RXBaD0 + len); i++ ) {  
0646:  MOVF   6B,W
0647:  MOVWF  63
0648:  MOVF   3D,W
0649:  ADDWF  6B,W
064A:  SUBWF  63,W
064B:  BTFSC  03.0
064C:  GOTO   664
....................          *data=mcp2510_read(i);  
064D:  MOVF   62,W
064E:  MOVWF  7A
064F:  MOVF   61,W
0650:  MOVWF  6D
0651:  MOVF   62,W
0652:  MOVWF  6E
0653:  MOVF   63,W
0654:  BSF    03.5
0655:  MOVWF  2B
0656:  BCF    03.5
0657:  CALL   05A
0658:  MOVF   6D,W
0659:  MOVWF  04
065A:  BCF    03.7
065B:  BTFSC  6E.0
065C:  BSF    03.7
065D:  MOVF   78,W
065E:  MOVWF  00
....................         data++;  
065F:  INCF   61,F
0660:  BTFSC  03.2
0661:  INCF   62,F
....................     }  
0662:  INCF   63,F
0663:  GOTO   648
....................   
....................     stat.inv=b_CANINTF.merrf;  
0664:  BCF    3E.7
0665:  BTFSC  6C.7
0666:  BSF    3E.7
....................     if (b_CANINTF.merrf) {  
0667:  BTFSS  6C.7
0668:  GOTO   66A
....................       b_CANINTF.merrf=0;  
0669:  BCF    6C.7
....................     }  
....................   
....................     if (stat.buffer) {  
066A:  BTFSS  3E.4
066B:  GOTO   66E
....................       b_CANINTF.rx1if=0;  
066C:  BCF    6C.1
....................     }  
....................     else {  
066D:  GOTO   66F
....................       b_CANINTF.rx0if=0;  
066E:  BCF    6C.0
....................     }  
....................     mcp2510_write(CANINTF, (int)b_CANINTF);  
066F:  MOVLW  2C
0670:  BSF    03.5
0671:  MOVWF  2C
0672:  BCF    03.5
0673:  MOVF   6C,W
0674:  BSF    03.5
0675:  MOVWF  2D
0676:  BCF    03.5
0677:  CALL   0B1
....................   
....................     #if CAN_DO_DEBUG  
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl);  
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv);  
....................        if ((len)&&(!stat.rtr)) {  
....................           data-=len;  
....................           can_debug("\r\n    DATA = ");  
....................           for (i=0;i<len;i++) {  
....................             can_debug("%X ",*data);  
....................             data++;  
....................           }  
....................        }  
....................        can_debug("\r\n");  
....................     #endif  
....................   
....................     return(1);  
0678:  MOVLW  01
0679:  MOVWF  78
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_kbhit()  
.................... //  
.................... // Returns TRUE if there is data in the receive buffers  
.................... //  
.................... //////////////////////////////////////////////////////////////////////////////  
.................... int1 can_kbhit(void) {  
....................    struct struct_CANINTF b_CANINTF;  
....................   
....................    b_CANINTF=mcp2510_read(CANINTF);  
*
0468:  MOVLW  2C
0469:  BSF    03.5
046A:  MOVWF  2B
046B:  BCF    03.5
046C:  CALL   05A
046D:  MOVF   78,W
046E:  MOVWF  61
....................    if (b_CANINTF.rx0if || b_CANINTF.rx1if)  
046F:  BTFSC  61.0
0470:  GOTO   473
0471:  BTFSS  61.1
0472:  GOTO   476
....................       {return(1);}  
0473:  MOVLW  01
0474:  MOVWF  78
0475:  GOTO   478
....................   
....................    return(0);  
0476:  MOVLW  00
0477:  MOVWF  78
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_tbe()  
.................... //  
.................... // Returns TRUE if the transmit buffers are empty and ready to transmit data  
.................... //  
.................... //////////////////////////////////////////////////////////////////////////////  
.................... int1 can_tbe(void) {  
....................    struct txbNctrl_struct b_TXB0CTRL, b_TXB1CTRL, b_TXB2CTRL;  
....................   
....................    b_TXB0CTRL=mcp2510_read(TXB0CTRL);  
....................    b_TXB1CTRL=mcp2510_read(TXB1CTRL);  
....................    b_TXB2CTRL=mcp2510_read(TXB2CTRL);  
....................   
....................    if (!b_TXB0CTRL.txreq || !b_TXB1CTRL.txreq || !b_TXB2CTRL.txreq)  
....................       {return(1);}  
....................   
....................    return(0);  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_abort()  
.................... //  
.................... // Aborts all pending tranmissions.  
.................... //  
.................... //////////////////////////////////////////////////////////////////////////////  
.................... void can_abort(void) {  
....................    struct struct_CANCTRL b_CANCTRL;  
....................   
....................    b_CANCTRL=mcp2510_read(CANCTRL);  
....................    b_CANCTRL.abat=1;  
....................    mcp2510_write(CANCTRL, (int)b_CANCTRL);  
....................   
....................    delay_ms(5);  
....................    b_CANCTRL.abat=0;  
....................    mcp2510_write(CANCTRL, (int)b_CANCTRL);  
.................... }  
....................   
....................   
....................   
....................   
.................... ///////////////////  
.................... ///  
.................... //  
.................... // SPI CODE  
.................... //  
.................... ///  
.................... //////////////////  
....................   
.................... //data clocked in on rising edge  
.................... //data driven out on falling edge  
.................... int mcp2510_read(int address) {  
....................    int command[2];  
....................    int i;  
....................    int data;  
....................   
....................    command[1]=0x03;  
*
005A:  MOVLW  03
005B:  BSF    03.5
005C:  MOVWF  2D
....................    command[0]=address;  
005D:  MOVF   2B,W
005E:  MOVWF  2C
....................   
....................    output_low(EXT_CAN_CS);  
005F:  BCF    06.3
0060:  BCF    03.5
0061:  BCF    06.3
....................   
....................    for (i=0;i<16;i++) {  
0062:  BSF    03.5
0063:  CLRF   2E
0064:  MOVF   2E,W
0065:  SUBLW  0F
0066:  BTFSS  03.0
0067:  GOTO   087
....................       output_bit(EXT_CAN_SI, shift_left(&command[0],2,0));  
0068:  BCF    03.0
0069:  RLF    2C,F
006A:  RLF    2D,F
006B:  BTFSC  03.0
006C:  GOTO   071
006D:  BCF    03.5
006E:  BCF    07.5
006F:  GOTO   073
0070:  BSF    03.5
0071:  BCF    03.5
0072:  BSF    07.5
0073:  BCF    3F.5
0074:  MOVF   3F,W
0075:  BSF    03.5
0076:  MOVWF  07
*
0795:  MOVLW  FF
0796:  MOVWF  3F
....................       output_high(EXT_CAN_SCK);  
*
0077:  BCF    03.5
0078:  BCF    3F.3
0079:  MOVF   3F,W
007A:  BSF    03.5
007B:  MOVWF  07
007C:  BCF    03.5
007D:  BSF    07.3
....................       output_low(EXT_CAN_SCK);  
007E:  BCF    3F.3
007F:  MOVF   3F,W
0080:  BSF    03.5
0081:  MOVWF  07
0082:  BCF    03.5
0083:  BCF    07.3
....................    }  
0084:  BSF    03.5
0085:  INCF   2E,F
0086:  GOTO   064
....................    for (i=0;i<8;i++) {  
0087:  CLRF   2E
0088:  MOVF   2E,W
0089:  SUBLW  07
008A:  BTFSS  03.0
008B:  GOTO   0A9
....................       shift_left(&data,1,input(EXT_CAN_SO));  
008C:  BCF    03.5
008D:  BSF    3F.4
008E:  MOVF   3F,W
008F:  BSF    03.5
0090:  MOVWF  07
0091:  BCF    03.5
0092:  BTFSC  07.4
0093:  GOTO   096
0094:  BCF    03.0
0095:  GOTO   097
0096:  BSF    03.0
0097:  BSF    03.5
0098:  RLF    2F,F
....................       output_high(EXT_CAN_SCK);  
0099:  BCF    03.5
009A:  BCF    3F.3
009B:  MOVF   3F,W
009C:  BSF    03.5
009D:  MOVWF  07
009E:  BCF    03.5
009F:  BSF    07.3
....................       output_low(EXT_CAN_SCK);  
00A0:  BCF    3F.3
00A1:  MOVF   3F,W
00A2:  BSF    03.5
00A3:  MOVWF  07
00A4:  BCF    03.5
00A5:  BCF    07.3
....................    }  
00A6:  BSF    03.5
00A7:  INCF   2E,F
00A8:  GOTO   088
....................   
....................    output_high(EXT_CAN_CS);  
00A9:  BCF    06.3
00AA:  BCF    03.5
00AB:  BSF    06.3
....................   
....................    return(data);  
00AC:  BSF    03.5
00AD:  MOVF   2F,W
00AE:  MOVWF  78
.................... }  
00AF:  BCF    03.5
00B0:  RETLW  00
....................   
.................... int mcp2510_status(void) {  
....................    int command;  
....................    int data;  
....................    int i;  
....................   
....................    command=0xA0;  
....................   
....................    output_low(EXT_CAN_CS);  
....................   
....................    for (i=0;i<8;i++) {  
....................       output_bit(EXT_CAN_SI, shift_left(&command,1,0));  
....................       output_high(EXT_CAN_SCK);  
....................       output_low(EXT_CAN_SCK);  
....................    }  
....................    for (i=0;i<8;i++) {  
....................       shift_left(&data,1,input(EXT_CAN_SO));  
....................       output_high(EXT_CAN_SCK);  
....................       output_low(EXT_CAN_SCK);  
....................    }  
....................    for (i=0;i<8;i++) {  
....................       output_high(EXT_CAN_SCK);  
....................       output_low(EXT_CAN_SCK);  
....................    }  
....................   
....................    output_high(EXT_CAN_CS);  
....................   
....................    return(data);  
.................... }  
....................   
....................   
.................... void mcp2510_write(int address, int data) {  
....................    int command[3];  
....................    int i;  
....................   
....................    command[2]=0x02;  
00B1:  MOVLW  02
00B2:  BSF    03.5
00B3:  MOVWF  30
....................    command[1]=address;  
00B4:  MOVF   2C,W
00B5:  MOVWF  2F
....................    command[0]=data;  
00B6:  MOVF   2D,W
00B7:  MOVWF  2E
....................   
....................    output_low(EXT_CAN_CS);  
00B8:  BCF    06.3
00B9:  BCF    03.5
00BA:  BCF    06.3
....................   
....................    for (i=0;i<24;i++) {  
00BB:  BSF    03.5
00BC:  CLRF   31
00BD:  MOVF   31,W
00BE:  SUBLW  17
00BF:  BTFSS  03.0
00C0:  GOTO   0E1
....................       output_bit(EXT_CAN_SI, shift_left(&command[0],3,0));  
00C1:  BCF    03.0
00C2:  RLF    2E,F
00C3:  RLF    2F,F
00C4:  RLF    30,F
00C5:  BTFSC  03.0
00C6:  GOTO   0CB
00C7:  BCF    03.5
00C8:  BCF    07.5
00C9:  GOTO   0CD
00CA:  BSF    03.5
00CB:  BCF    03.5
00CC:  BSF    07.5
00CD:  BCF    3F.5
00CE:  MOVF   3F,W
00CF:  BSF    03.5
00D0:  MOVWF  07
....................       output_high(EXT_CAN_SCK);  
00D1:  BCF    03.5
00D2:  BCF    3F.3
00D3:  MOVF   3F,W
00D4:  BSF    03.5
00D5:  MOVWF  07
00D6:  BCF    03.5
00D7:  BSF    07.3
....................       output_low(EXT_CAN_SCK);  
00D8:  BCF    3F.3
00D9:  MOVF   3F,W
00DA:  BSF    03.5
00DB:  MOVWF  07
00DC:  BCF    03.5
00DD:  BCF    07.3
....................    }  
00DE:  BSF    03.5
00DF:  INCF   31,F
00E0:  GOTO   0BD
....................   
....................    output_high(EXT_CAN_CS);  
00E1:  BCF    06.3
00E2:  BCF    03.5
00E3:  BSF    06.3
.................... }  
00E4:  RETLW  00
....................   
.................... void mcp2510_command(int command) {  
....................    int i;  
....................   
....................    output_low(EXT_CAN_CS);  
*
01E0:  BSF    03.5
01E1:  BCF    06.3
01E2:  BCF    03.5
01E3:  BCF    06.3
....................   
....................    for (i=0;i<8;i++) {  
01E4:  CLRF   63
01E5:  MOVF   63,W
01E6:  SUBLW  07
01E7:  BTFSS  03.0
01E8:  GOTO   203
....................       output_bit(EXT_CAN_SI, shift_left(&command,1,0));  
01E9:  BCF    03.0
01EA:  RLF    62,F
01EB:  BTFSC  03.0
01EC:  GOTO   1EF
01ED:  BCF    07.5
01EE:  GOTO   1F0
01EF:  BSF    07.5
01F0:  BCF    3F.5
01F1:  MOVF   3F,W
01F2:  BSF    03.5
01F3:  MOVWF  07
....................       output_high(EXT_CAN_SCK);  
01F4:  BCF    03.5
01F5:  BCF    3F.3
01F6:  MOVF   3F,W
01F7:  BSF    03.5
01F8:  MOVWF  07
01F9:  BCF    03.5
01FA:  BSF    07.3
....................       output_low(EXT_CAN_SCK);  
01FB:  BCF    3F.3
01FC:  MOVF   3F,W
01FD:  BSF    03.5
01FE:  MOVWF  07
01FF:  BCF    03.5
0200:  BCF    07.3
....................    }  
0201:  INCF   63,F
0202:  GOTO   1E5
....................   
....................    output_high(EXT_CAN_CS);  
0203:  BSF    03.5
0204:  BCF    06.3
0205:  BCF    03.5
0206:  BSF    06.3
.................... }  
....................   
.................... void mcp2510_init(void) {  
....................    output_high(EXT_CAN_CS);  
*
01D4:  BSF    03.5
01D5:  BCF    06.3
01D6:  BCF    03.5
01D7:  BSF    06.3
....................    output_low(EXT_CAN_SCK);  
01D8:  BCF    3F.3
01D9:  MOVF   3F,W
01DA:  BSF    03.5
01DB:  MOVWF  07
01DC:  BCF    03.5
01DD:  BCF    07.3
....................   
....................    #ifdef EXT_CAN_TX0RTS  
....................     output_high(EXT_CAN_TX0RTS);  
....................    #endif  
....................    #ifdef EXT_CAN_TX1RTS  
....................     output_high(EXT_CAN_TX1RTS);  
....................    #endif  
....................    #ifdef EXT_CAN_TX2RTS  
....................     output_high(EXT_CAN_TX2RTS);  
....................    #endif  
....................   
....................   #ifdef EXT_CAN_TX0RTS  
....................    output_high(EXT_CAN_RESET);  
....................    output_low(EXT_CAN_RESET);  
....................    output_high(EXT_CAN_RESET);  
....................    delay_ms(5);  
....................   #endif  
....................   
....................    mcp2510_command(0xC0);   //reset  
01DE:  MOVLW  C0
01DF:  MOVWF  62
....................    delay_ms(5);  
*
0207:  MOVLW  05
0208:  MOVWF  62
0209:  GOTO   04B
020A:  NOP
.................... }  
....................  
....................   
.................... /* identifiants bus can */  
.................... #define i_ren    0x301              //emission vers le module de controle  
.................... #define i_rmain  0x300              //reception depuis le module de controle  
....................   
.................... /* variables du systeme */  
.................... int16 en_ve;                         //tension d'entree  
.................... int16 en_vs;                         //tension de sortie  
.................... int16 en_ie;                         //courant d'entree  
.................... int16 en_is;                         //courant de sortie  
.................... int charge;                          //indicateur de charge  
.................... int full;                            //indicateur de charge complete  
.................... int empty;                           //indicateur de decharge  
....................   
.................... /* indicateurs des taches activees periodiquement */  
.................... int1 mes_flag;                       //indicateur pour mesure  
.................... int1 calc_flag;                      //indicateur pour calcul  
.................... int16 mst;  
....................   
.................... int j;                              //compteurs de boucle  
.................... int table[18];  
....................   
.................... /* declaration des fonctions */  
.................... void init();  
.................... void gest_can();  
.................... void gest_bat();  
.................... void mesure();  
.................... void calcul();  
....................   
.................... /* timer des taches appele par interruption */  
.................... #int_timer2  
.................... void isr_timer2(void) {  
....................    mst++;                               //timer qui est appele toutes les ms par une interruption du timer2  
*
0035:  INCF   4C,F
0036:  BTFSC  03.2
0037:  INCF   4D,F
....................    if (mst == 500){mes_flag = 1;}  
0038:  MOVF   4C,W
0039:  SUBLW  F4
003A:  BTFSS  03.2
003B:  GOTO   03F
003C:  DECFSZ 4D,W
003D:  GOTO   03F
003E:  BSF    4B.0
....................    if (mst == 500){mst = 0;}  
003F:  MOVF   4C,W
0040:  SUBLW  F4
0041:  BTFSS  03.2
0042:  GOTO   047
0043:  DECFSZ 4D,W
0044:  GOTO   047
0045:  CLRF   4D
0046:  CLRF   4C
.................... }  
....................   
.................... #define led_on output_high(PIN_B1)  
.................... #define led_off output_low(PIN_B1)  
.................... #define ON output_low(PIN_A5)  
.................... #define OFF output_high(PIN_A5)  
....................   
.................... /* programme principal */  
0047:  BCF    0C.1
0048:  BCF    0A.3
0049:  BCF    0A.4
004A:  GOTO   01F
.................... void main()  
.................... {  
*
074F:  MOVLW  1F
0750:  ANDWF  03,F
0751:  MOVLW  50
0752:  MOVWF  77
0753:  MOVLW  20
0754:  MOVWF  04
0755:  BCF    03.7
0756:  CLRF   00
0757:  INCF   04,F
0758:  CLRWDT
0759:  DECFSZ 77,F
075A:  GOTO   756
075B:  CLRF   71
075C:  CLRF   72
075D:  CLRF   73
075E:  CLRF   74
075F:  CLRF   75
0760:  CLRF   76
0761:  CLRF   78
0762:  CLRF   79
0763:  CLRF   7A
0764:  CLRF   7B
0765:  CLRF   7C
0766:  CLRF   7D
0767:  CLRF   7E
0768:  MOVLW  50
0769:  MOVWF  77
076A:  MOVLW  A0
076B:  MOVWF  04
076C:  BCF    03.7
076D:  CLRF   00
076E:  INCF   04,F
076F:  CLRWDT
0770:  DECFSZ 77,F
0771:  GOTO   76D
0772:  MOVLW  60
0773:  MOVWF  77
0774:  MOVLW  10
0775:  MOVWF  04
0776:  BSF    03.7
0777:  CLRF   00
0778:  INCF   04,F
0779:  CLRWDT
077A:  DECFSZ 77,F
077B:  GOTO   777
077C:  BCF    03.7
077D:  MOVLW  59
077E:  MOVWF  77
077F:  MOVLW  90
0780:  MOVWF  04
0781:  BSF    03.7
0782:  CLRF   00
0783:  INCF   04,F
0784:  CLRWDT
0785:  DECFSZ 77,F
0786:  GOTO   782
0787:  BCF    03.7
0788:  CLRF   20
0789:  CLRF   04
078A:  BCF    03.7
078B:  MOVLW  1F
078C:  ANDWF  03,F
078D:  BSF    03.5
078E:  BSF    1F.0
078F:  BSF    1F.1
0790:  BSF    1F.2
0791:  BCF    1F.3
0792:  MOVLW  07
0793:  BCF    03.5
0794:  MOVWF  1F
....................    init();  
*
0797:  GOTO   1D4
....................    while (1)  
....................    {  
....................       led_off;  
0798:  BSF    03.5
0799:  BCF    06.1
079A:  BCF    03.5
079B:  BCF    06.1
....................       gest_bat();  
079C:  GOTO   2CD
....................       mesure();  
079D:  GOTO   33C
....................       calcul();  
079E:  GOTO   3FB
....................       gest_can();  
079F:  GOTO   468
....................    }  
07A0:  GOTO   798
.................... }  
....................   
.................... /* definitions des fonctions */  
....................   
.................... void gest_bat(){  
....................       if (en_vs > 137){  
*
02CD:  MOVF   43,F
02CE:  BTFSS  03.2
02CF:  GOTO   2D4
02D0:  MOVF   42,W
02D1:  SUBLW  89
02D2:  BTFSC  03.0
02D3:  GOTO   2D6
*
07A1:  GOTO   7A1
....................          full = 1;  
*
02D4:  MOVLW  01
02D5:  MOVWF  49
....................          //OFF;         //limitation de la charge de la batterie  
....................       }  
....................       if (en_vs < 134) {  
02D6:  MOVF   43,F
02D7:  BTFSS  03.2
02D8:  GOTO   2DE
02D9:  MOVF   42,W
02DA:  SUBLW  85
02DB:  BTFSS  03.0
02DC:  GOTO   2DE
....................          full = 0;  
02DD:  CLRF   49
....................          //ON;          //activation de la charge  
....................       }  
....................       if (en_ie > (en_is+1)){charge = 1;}  
02DE:  MOVLW  01
02DF:  ADDWF  46,W
02E0:  MOVWF  78
02E1:  MOVF   47,W
02E2:  MOVWF  7A
02E3:  BTFSC  03.0
02E4:  INCF   7A,F
02E5:  MOVF   7A,W
02E6:  SUBWF  45,W
02E7:  BTFSS  03.0
02E8:  GOTO   2F2
02E9:  BTFSS  03.2
02EA:  GOTO   2EF
02EB:  MOVF   44,W
02EC:  SUBWF  78,W
02ED:  BTFSC  03.0
02EE:  GOTO   2F2
02EF:  MOVLW  01
02F0:  MOVWF  48
....................       else {charge = 0;}  
02F1:  GOTO   2F3
02F2:  CLRF   48
....................   
....................       if (en_vs < 114){empty = 1;}  
02F3:  MOVF   43,F
02F4:  BTFSS  03.2
02F5:  GOTO   2FD
02F6:  MOVF   42,W
02F7:  SUBLW  71
02F8:  BTFSS  03.0
02F9:  GOTO   2FD
02FA:  MOVLW  01
02FB:  MOVWF  4A
....................       else {empty = 0;}  
02FC:  GOTO   2FE
02FD:  CLRF   4A
.................... }  
02FE:  BCF    0A.3
02FF:  BCF    0A.4
0300:  GOTO   79D (RETURN)
....................   
.................... void mesure(){  
....................    int16 a;  
....................   
....................    if (mes_flag==1){  
*
033C:  BTFSS  4B.0
033D:  GOTO   3F8
....................   
....................       set_adc_channel(0);  
033E:  MOVLW  00
033F:  MOVWF  78
0340:  MOVF   1F,W
0341:  ANDLW  C7
0342:  IORWF  78,W
0343:  MOVWF  1F
....................       delay_us(100);  
0344:  MOVLW  14
0345:  MOVWF  77
0346:  DECFSZ 77,F
0347:  GOTO   346
0348:  NOP
....................       a=read_adc();  
0349:  BSF    1F.2
034A:  BTFSC  1F.2
034B:  GOTO   34A
034C:  BSF    03.5
034D:  MOVF   1E,W
034E:  BCF    03.5
034F:  MOVWF  61
0350:  MOVF   1E,W
0351:  MOVWF  62
....................       a = (a*20)/100;      //en_ve  
0352:  MOVF   62,W
0353:  MOVWF  64
0354:  MOVF   61,W
0355:  MOVWF  63
0356:  CLRF   66
0357:  MOVLW  14
0358:  MOVWF  65
0359:  CALL   301
035A:  MOVF   79,W
035B:  MOVWF  64
035C:  MOVF   78,W
035D:  MOVWF  63
035E:  MOVF   79,W
035F:  MOVWF  66
0360:  MOVF   78,W
0361:  MOVWF  65
0362:  CLRF   68
0363:  MOVLW  64
0364:  MOVWF  67
0365:  CALL   316
0366:  MOVF   79,W
0367:  MOVWF  62
0368:  MOVF   78,W
0369:  MOVWF  61
....................       table[j] = a;  
036A:  MOVLW  4F
036B:  ADDWF  4E,W
036C:  MOVWF  04
036D:  BCF    03.7
036E:  MOVF   61,W
036F:  MOVWF  00
....................   
....................       set_adc_channel(1);  
0370:  MOVLW  08
0371:  MOVWF  78
0372:  MOVF   1F,W
0373:  ANDLW  C7
0374:  IORWF  78,W
0375:  MOVWF  1F
....................       delay_us(100);  
0376:  MOVLW  14
0377:  MOVWF  77
0378:  DECFSZ 77,F
0379:  GOTO   378
037A:  NOP
....................       a=read_adc();  
037B:  BSF    1F.2
037C:  BTFSC  1F.2
037D:  GOTO   37C
037E:  BSF    03.5
037F:  MOVF   1E,W
0380:  BCF    03.5
0381:  MOVWF  61
0382:  MOVF   1E,W
0383:  MOVWF  62
....................       a = (a*1)/3;       //en_ie  
0384:  MOVF   62,W
0385:  MOVWF  66
0386:  MOVF   61,W
0387:  MOVWF  65
0388:  CLRF   68
0389:  MOVLW  03
038A:  MOVWF  67
038B:  CALL   316
038C:  MOVF   79,W
038D:  MOVWF  62
038E:  MOVF   78,W
038F:  MOVWF  61
....................       table[j+4] = a;  
0390:  MOVLW  04
0391:  ADDWF  4E,W
0392:  ADDLW  4F
0393:  MOVWF  04
0394:  BCF    03.7
0395:  MOVF   61,W
0396:  MOVWF  00
....................   
....................       set_adc_channel(2);  
0397:  MOVLW  10
0398:  MOVWF  78
0399:  MOVF   1F,W
039A:  ANDLW  C7
039B:  IORWF  78,W
039C:  MOVWF  1F
....................       delay_us(100);  
039D:  MOVLW  14
039E:  MOVWF  77
039F:  DECFSZ 77,F
03A0:  GOTO   39F
03A1:  NOP
....................       a=read_adc();  
03A2:  BSF    1F.2
03A3:  BTFSC  1F.2
03A4:  GOTO   3A3
03A5:  BSF    03.5
03A6:  MOVF   1E,W
03A7:  BCF    03.5
03A8:  MOVWF  61
03A9:  MOVF   1E,W
03AA:  MOVWF  62
....................       a = (a*20)/100;      //en_vs  
03AB:  MOVF   62,W
03AC:  MOVWF  64
03AD:  MOVF   61,W
03AE:  MOVWF  63
03AF:  CLRF   66
03B0:  MOVLW  14
03B1:  MOVWF  65
03B2:  CALL   301
03B3:  MOVF   79,W
03B4:  MOVWF  64
03B5:  MOVF   78,W
03B6:  MOVWF  63
03B7:  MOVF   79,W
03B8:  MOVWF  66
03B9:  MOVF   78,W
03BA:  MOVWF  65
03BB:  CLRF   68
03BC:  MOVLW  64
03BD:  MOVWF  67
03BE:  CALL   316
03BF:  MOVF   79,W
03C0:  MOVWF  62
03C1:  MOVF   78,W
03C2:  MOVWF  61
....................       table[j+8] = a;  
03C3:  MOVLW  08
03C4:  ADDWF  4E,W
03C5:  ADDLW  4F
03C6:  MOVWF  04
03C7:  BCF    03.7
03C8:  MOVF   61,W
03C9:  MOVWF  00
....................   
....................       set_adc_channel(3);  
03CA:  MOVLW  18
03CB:  MOVWF  78
03CC:  MOVF   1F,W
03CD:  ANDLW  C7
03CE:  IORWF  78,W
03CF:  MOVWF  1F
....................       delay_us(100);  
03D0:  MOVLW  14
03D1:  MOVWF  77
03D2:  DECFSZ 77,F
03D3:  GOTO   3D2
03D4:  NOP
....................       a=read_adc();  
03D5:  BSF    1F.2
03D6:  BTFSC  1F.2
03D7:  GOTO   3D6
03D8:  BSF    03.5
03D9:  MOVF   1E,W
03DA:  BCF    03.5
03DB:  MOVWF  61
03DC:  MOVF   1E,W
03DD:  MOVWF  62
....................       a = (a*1)/3;        //en_is  
03DE:  MOVF   62,W
03DF:  MOVWF  66
03E0:  MOVF   61,W
03E1:  MOVWF  65
03E2:  CLRF   68
03E3:  MOVLW  03
03E4:  MOVWF  67
03E5:  CALL   316
03E6:  MOVF   79,W
03E7:  MOVWF  62
03E8:  MOVF   78,W
03E9:  MOVWF  61
....................       table[j+12] = a;  
03EA:  MOVLW  0C
03EB:  ADDWF  4E,W
03EC:  ADDLW  4F
03ED:  MOVWF  04
03EE:  BCF    03.7
03EF:  MOVF   61,W
03F0:  MOVWF  00
....................   
....................       j++;  
03F1:  INCF   4E,F
....................       if(j>=4){j=0;}  
03F2:  MOVF   4E,W
03F3:  SUBLW  03
03F4:  BTFSS  03.0
03F5:  CLRF   4E
....................   
....................       mes_flag=0;  
03F6:  BCF    4B.0
....................       calc_flag=1;                     //indicateur pour calcul  
03F7:  BSF    4B.1
....................    }  
.................... }  
03F8:  BCF    0A.3
03F9:  BCF    0A.4
03FA:  GOTO   79E (RETURN)
....................   
.................... void calcul(){  
....................    int16 somme;                    //variable pour calcul  
....................    int i;                          //compteurs de boucle  
....................   
....................    if (calc_flag==1){  
03FB:  BTFSS  4B.1
03FC:  GOTO   465
....................       somme=0;  
03FD:  CLRF   62
03FE:  CLRF   61
....................       for (i=0;i<=3;i++){somme=somme+table[i];}  
03FF:  CLRF   63
0400:  MOVF   63,W
0401:  SUBLW  03
0402:  BTFSS  03.0
0403:  GOTO   40E
0404:  MOVLW  4F
0405:  ADDWF  63,W
0406:  MOVWF  04
0407:  BCF    03.7
0408:  MOVF   00,W
0409:  ADDWF  61,F
040A:  BTFSC  03.0
040B:  INCF   62,F
040C:  INCF   63,F
040D:  GOTO   400
....................       en_ve=somme/4;  
040E:  RRF    62,W
040F:  MOVWF  41
0410:  RRF    61,W
0411:  MOVWF  40
0412:  RRF    41,F
0413:  RRF    40,F
0414:  MOVLW  3F
0415:  ANDWF  41,F
....................   
....................       somme=0;  
0416:  CLRF   62
0417:  CLRF   61
....................       for (i=4;i<=7;i++){somme=somme+table[i];}  
0418:  MOVLW  04
0419:  MOVWF  63
041A:  MOVF   63,W
041B:  SUBLW  07
041C:  BTFSS  03.0
041D:  GOTO   428
041E:  MOVLW  4F
041F:  ADDWF  63,W
0420:  MOVWF  04
0421:  BCF    03.7
0422:  MOVF   00,W
0423:  ADDWF  61,F
0424:  BTFSC  03.0
0425:  INCF   62,F
0426:  INCF   63,F
0427:  GOTO   41A
....................       en_ie=somme/4;  
0428:  RRF    62,W
0429:  MOVWF  45
042A:  RRF    61,W
042B:  MOVWF  44
042C:  RRF    45,F
042D:  RRF    44,F
042E:  MOVLW  3F
042F:  ANDWF  45,F
....................   
....................       somme=0;  
0430:  CLRF   62
0431:  CLRF   61
....................       for (i=8;i<=11;i++){somme=somme+table[i];}  
0432:  MOVLW  08
0433:  MOVWF  63
0434:  MOVF   63,W
0435:  SUBLW  0B
0436:  BTFSS  03.0
0437:  GOTO   442
0438:  MOVLW  4F
0439:  ADDWF  63,W
043A:  MOVWF  04
043B:  BCF    03.7
043C:  MOVF   00,W
043D:  ADDWF  61,F
043E:  BTFSC  03.0
043F:  INCF   62,F
0440:  INCF   63,F
0441:  GOTO   434
....................       en_vs=somme/4;  
0442:  RRF    62,W
0443:  MOVWF  43
0444:  RRF    61,W
0445:  MOVWF  42
0446:  RRF    43,F
0447:  RRF    42,F
0448:  MOVLW  3F
0449:  ANDWF  43,F
....................   
....................       somme=0;  
044A:  CLRF   62
044B:  CLRF   61
....................       for (i=12;i<=15;i++){somme=somme+table[i];}  
044C:  MOVLW  0C
044D:  MOVWF  63
044E:  MOVF   63,W
044F:  SUBLW  0F
0450:  BTFSS  03.0
0451:  GOTO   45C
0452:  MOVLW  4F
0453:  ADDWF  63,W
0454:  MOVWF  04
0455:  BCF    03.7
0456:  MOVF   00,W
0457:  ADDWF  61,F
0458:  BTFSC  03.0
0459:  INCF   62,F
045A:  INCF   63,F
045B:  GOTO   44E
....................       en_is=somme/4;  
045C:  RRF    62,W
045D:  MOVWF  47
045E:  RRF    61,W
045F:  MOVWF  46
0460:  RRF    47,F
0461:  RRF    46,F
0462:  MOVLW  3F
0463:  ANDWF  47,F
....................   
....................       calc_flag=0;  
0464:  BCF    4B.1
....................    }  
.................... }  
0465:  BCF    0A.3
0466:  BCF    0A.4
0467:  GOTO   79F (RETURN)
....................   
....................   
.................... void gest_can(){  
....................    if ( can_kbhit() ){   //y a t il des donnees dans le buffer ?..  
*
0478:  MOVF   78,F
0479:  BTFSC  03.2
047A:  GOTO   74C
....................       if(can_getd(crx_id, &crxbuf[0], crx_len, rxstat)){ //...si oui lecture des donnees  
047B:  CLRF   62
047C:  MOVLW  2C
047D:  MOVWF  61
*
067A:  MOVF   78,F
067B:  BTFSC  03.2
067C:  GOTO   74C
....................          if (crx_id == i_rmain) {  
067D:  MOVF   28,F
067E:  BTFSS  03.2
067F:  GOTO   74C
0680:  MOVF   29,W
0681:  SUBLW  03
0682:  BTFSS  03.2
0683:  GOTO   74C
0684:  MOVF   2A,F
0685:  BTFSS  03.2
0686:  GOTO   74C
0687:  MOVF   2B,F
0688:  BTFSS  03.2
0689:  GOTO   74C
....................             led_on;             // change la LED system  
068A:  BSF    03.5
068B:  BCF    06.1
068C:  BCF    03.5
068D:  BSF    06.1
....................             ctxbuf[0]=en_ve;  
068E:  MOVF   40,W
068F:  MOVWF  34
....................             ctxbuf[1]=en_ie;  
0690:  MOVF   44,W
0691:  MOVWF  35
....................             ctxbuf[2]=en_is;  
0692:  MOVF   46,W
0693:  MOVWF  36
....................             ctxbuf[3]=en_vs;  
0694:  MOVF   42,W
0695:  MOVWF  37
....................             ctxbuf[4]=charge;  
0696:  MOVF   48,W
0697:  MOVWF  38
....................             ctxbuf[5]=full;  
0698:  MOVF   49,W
0699:  MOVWF  39
....................             ctxbuf[6]=empty;  
069A:  MOVF   4A,W
069B:  MOVWF  3A
....................             can_putd(i_ren, &ctxbuf[0], 7,1,1,0);       //reponse avec 7 octets de buffer  
069C:  CLRF   64
069D:  CLRF   63
069E:  MOVLW  03
069F:  MOVWF  62
06A0:  MOVLW  01
06A1:  MOVWF  61
06A2:  CLRF   66
06A3:  MOVLW  34
06A4:  MOVWF  65
06A5:  MOVLW  07
06A6:  MOVWF  67
06A7:  MOVLW  01
06A8:  MOVWF  68
06A9:  MOVWF  69
06AA:  CLRF   6A
....................          }  
....................       }  
....................    }  
.................... }  
*
074C:  BCF    0A.3
074D:  BCF    0A.4
074E:  GOTO   7A0 (RETURN)
....................   
.................... void init(){  
....................    can_init();  
....................    setup_adc_ports( ALL_ANALOG );  
*
02B2:  BSF    03.5
02B3:  BCF    1F.0
02B4:  BCF    1F.1
02B5:  BCF    1F.2
02B6:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_DIV_2);  
02B7:  BCF    1F.6
02B8:  BCF    03.5
02B9:  BCF    1F.6
02BA:  BCF    1F.7
02BB:  BSF    03.5
02BC:  BSF    1F.7
02BD:  BCF    03.5
02BE:  BSF    1F.0
....................    setup_timer_2(T2_DIV_BY_16,8,5);    // parametrage du timer 2  
02BF:  MOVLW  20
02C0:  MOVWF  78
02C1:  IORLW  06
02C2:  MOVWF  12
02C3:  MOVLW  08
02C4:  BSF    03.5
02C5:  MOVWF  12
....................    enable_interrupts(INT_TIMER2);      // autorisation interruption timer2  
02C6:  BSF    0C.1
....................    enable_interrupts(GLOBAL);          // autorisation de toutes les interruptions (afin de prendre en compte timer2)  
02C7:  MOVLW  C0
02C8:  BCF    03.5
02C9:  IORWF  0B,F
.................... }  
02CA:  BCF    0A.3
02CB:  BCF    0A.4
02CC:  GOTO   798 (RETURN)
....................  

Configuration Fuses:
   Word  1: 3731   XT NOWDT PUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
