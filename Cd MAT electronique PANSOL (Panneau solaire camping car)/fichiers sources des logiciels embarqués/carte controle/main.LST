CCS PCM C Compiler, Version 3.212, 26421               15-oct.-05 14:14

               Filename: C:\Dossier MAT Electronique\Programmes PIC applications MAT\Panneau solaire\source modules pic (version 2)\carte controle\main.LST

               ROM used: 6655 words (81%)
                         Largest free fragment is 1366
               RAM used: 151 (42%) at main() level
                         209 (58%) worst case
               Stack:    8 worst case (6 in main + 2 for interrupts)

*
0000:  NOP
0001:  MOVLW  18
0002:  MOVWF  0A
0003:  GOTO   000
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.3
001A:  GOTO   01D
001B:  BTFSC  0B.0
001C:  GOTO   03C
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.5
0020:  GOTO   023
0021:  BTFSC  0C.5
0022:  GOTO   03F
0023:  MOVLW  8C
0024:  MOVWF  04
0025:  BTFSS  00.1
0026:  GOTO   029
0027:  BTFSC  0C.1
0028:  GOTO   042
0029:  MOVF   22,W
002A:  MOVWF  04
002B:  MOVF   23,W
002C:  MOVWF  77
002D:  MOVF   24,W
002E:  MOVWF  78
002F:  MOVF   25,W
0030:  MOVWF  79
0031:  MOVF   26,W
0032:  MOVWF  7A
0033:  MOVF   27,W
0034:  MOVWF  7B
0035:  MOVF   20,W
0036:  MOVWF  0A
0037:  SWAPF  21,W
0038:  MOVWF  03
0039:  SWAPF  7F,F
003A:  SWAPF  7F,W
003B:  RETFIE
003C:  BCF    0A.3
003D:  BCF    0A.4
003E:  GOTO   3D1
003F:  BCF    0A.3
0040:  BCF    0A.4
0041:  GOTO   3A0
0042:  BCF    0A.3
0043:  BCF    0A.4
0044:  GOTO   2EA
....................  // version V2.1 du 15/10/2005   
.................... // maj : concerne la réception de la liaison série avec le paramètre DISABLE_INTS  
.................... //       contrôle des paquets multiples   
.................... //       rajout de l'instruction suivante port_b_pullups (TRUE);  
.................... //       qui polarise le port B (évite de partir en interruption à cause de RB7 et RB6  
....................   
.................... #include <16F876a.h> //mettre #include <16F876.h> si PIC16F876-04 // 
....................  //////// Standard Header file for the PIC16F876A device ////////////////  
.................... #device PIC16F876A  
.................... #list  
....................  
.................... #device ICD=TRUE  
.................... #device *=16  
.................... #zero_ram  
.................... #use delay(clock=2500000)  
*
0430:  MOVLW  DB
0431:  MOVWF  04
0432:  BCF    03.7
0433:  MOVF   00,W
0434:  BTFSC  03.2
0435:  GOTO   43C
0436:  MOVLW  CF
0437:  MOVWF  77
0438:  DECFSZ 77,F
0439:  GOTO   438
043A:  DECFSZ 00,F
043B:  GOTO   436
043C:  RETLW  00
.................... #fuses NOWDT,XT, NOPUT, NOPROTECT, NODEBUG, BROWNOUT, LVP, NOCPD, NOWRT  
....................   
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7,bits=8,DISABLE_INTS)  
*
0392:  BTFSS  0C.5
0393:  GOTO   392
0394:  MOVF   18,W
0395:  MOVWF  28
0396:  MOVF   1A,W
0397:  MOVWF  78
0398:  BTFSS  28.1
0399:  GOTO   39C
039A:  BCF    18.4
039B:  BSF    18.4
039C:  NOP
039D:  BCF    0A.3
039E:  BCF    0A.4
039F:  GOTO   3A1 (RETURN)
*
048A:  BTFSS  0C.4
048B:  GOTO   48A
048C:  BSF    03.5
048D:  MOVF   63,W
048E:  BCF    03.5
048F:  MOVWF  19
0490:  RETLW  00
*
184E:  CLRF   28
....................   
.................... #define led_on output_high(PIN_B1)  
.................... #define led_off output_low(PIN_B1)  
....................   
.................... /* variables du systeme */  
.................... int16 e,o,n,s;                         //mesure de luminosite recu du module HF sur 16 bits  
.................... int lum_est;                           //luminosite est  
.................... int lum_ouest;                         //luminosite ouest  
.................... int lum_nord;                          //luminosite nord  
.................... int lum_sud;                           //luminosite sud  
.................... int lum_m;                             //luminosite moyenne  
.................... int lum_eca;                           //ecart luminosite azimut  
.................... int lum_ece;                           //ecart luminosite elevation  
....................   
.................... int en_ve;                             //tension panneau solaire  
.................... int en_vs;                             //tension batterie  
.................... int en_ie;                             //intensite panneau  
.................... int en_is;                             //intensite batterie  
.................... int charge;                            //indicateur de charge  
.................... int full;                              //indicateur de charge complete  
.................... int empty;                             //indicateur de decharge  
....................   
.................... int ec_com;                            //indicateur eclairage  
.................... int ec_int;                            //niveau eclairage  
....................   
.................... int mo_ie;                             //courant moteur 1  
.................... int mo_ia;                             //courant moteur 2  
.................... int mo_ovle;                           //indicateur de surcharge elevation  
.................... int mo_ovla;                           //indicateur de surcharge azimut  
.................... int mot_e_sens;                        //sens de deplacement 0,1 ou 2  
.................... int mot_e_dure;                        //duree de deplacement en secondes  
.................... int mot_a_sens;                        //sens de deplacement 0,1 ou 2  
.................... int mot_a_dure;                        //duree de deplacement en secondes  
.................... int on;                                //indique un eventuel deplacement (0 pour arret)  
.................... int park;                              //indicateur pour demande parking  
.................... int mot_off;                           //indicateur de demande d'arret immediat des moteurs  
.................... int16 ang_azim;                        //angle azimut  
.................... int ang_elev;                          //angle elevation  
.................... int butee;                             //indicateur de butee  
....................   
.................... int cor_mode;                          //indique correction automatique si a 1 (0 pas de correction)  
.................... int cor_per;                           //periodicite en mn des corrections  
.................... int cor_seuil;                         //ecart de luminosite qui justifie une correction  
....................   
.................... int1 normal;                           //mode automatique  
.................... int1 manuel;                           //mode manuel  
.................... int nouvelle_trame_serie;  
....................   
.................... #include "can.c"                       //driver can a consulter pour bits utilises 
....................  /////////////////////////////////////////////////////////////////////////  
.................... ////                        can-mcp2510.c                            ////  
.................... //// CAN Library routines for Microchip's MCP2510 (and compatable)   ////  
.................... //// CAN IO expanders.                                               ////  
.................... ////                                                                 ////  
.................... //// This library provides the following functions:                  ////  
.................... ////  (for more information on these functions see the comment       ////  
.................... ////   header above each function)                                   ////  
.................... ////                                                                 ////  
.................... ////    can_init - Configures the MCP2510 CAN peripheral             ////  
.................... ////                                                                 ////  
.................... ////    can_set_baud - Sets the baud rate control registers          ////  
.................... ////                                                                 ////  
.................... ////    can_set_mode - Sets the CAN module into a specific mode      ////  
.................... ////                                                                 ////  
.................... ////    can_set_id - Sets the standard and extended ID               ////  
.................... ////                                                                 ////  
.................... ////    can_get_id - Gets the standard and extended ID               ////  
.................... ////                                                                 ////  
.................... ////    can_putd - Sends a message/request with specified ID         ////  
.................... ////                                                                 ////  
.................... ////    can_getd - Returns specifid message/request and ID           ////  
.................... ////                                                                 ////  
.................... ////    can_kbhit - Returns true if there is data in one of the      ////  
.................... ////                receive buffers                                  ////  
.................... ////                                                                 ////  
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    ////  
.................... ////              send more data                                     ////  
.................... ////                                                                 ////  
.................... ////    can_abort - Aborts all pending transmissions                 ////  
.................... ////                                                                 ////  
.................... //// You will need a CAN transeiver to connect CANRX and CANTX       ////  
.................... //// pins to CANH and CANL bus lines.                                ////  
.................... ////                                                                 ////  
.................... //// CCS provides an example, ex_can_ccs_b.c, which shows how to use ////  
.................... //// this library with CCS's CAN Prototype board.                    ////  
.................... ////                                                                 ////  
.................... /////////////////////////////////////////////////////////////////////////  
.................... ////                                                                 ////  
.................... //// Version History                                                 ////  
.................... ////                                                                 ////  
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     ////  
.................... ////              setting all RX filters to extended.                ////  
.................... ////                                                                 ////  
.................... ////  Apr 20 04 - Fixed a compling problem.                          ////  
.................... ////                                                                 ////  
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 ////  
.................... ////                                                                 ////  
.................... /////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         ////  
.................... //// This source code may only be used by licensed users of the CCS  ////  
.................... //// C compiler.  This source code may only be distributed to other  ////  
.................... //// licensed users of the CCS C compiler.  No other use,            ////  
.................... //// reproduction or distribution is permitted without written       ////  
.................... //// permission.  Derivative programs created using this software    ////  
.................... //// in object code form are not restricted in any way.              ////  
.................... /////////////////////////////////////////////////////////////////////////  
....................   
.................... #include <can.h> 
....................  /////////////////////////////////////////////////////////////////////////  
.................... ////                        can-mcp2510.h                            ////  
.................... ////                                                                 ////  
.................... //// Prototypes, definitions, defines and macros used for and with   ////  
.................... //// the CCS CAN library for the MCP2510 (and compatable) CAN IO     ////  
.................... //// expanders.                                                      ////  
.................... ////                                                                 ////  
.................... //// (see can-mcp2510.c)                                             ////  
.................... ////                                                                 ////  
.................... /////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         ////  
.................... //// This source code may only be used by licensed users of the CCS  ////  
.................... //// C compiler.  This source code may only be distributed to other  ////  
.................... //// licensed users of the CCS C compiler.  No other use,            ////  
.................... //// reproduction or distribution is permitted without written       ////  
.................... //// permission.  Derivative programs created using this software    ////  
.................... //// in object code form are not restricted in any way.              ////  
.................... /////////////////////////////////////////////////////////////////////////  
....................   
....................   
.................... #ifndef CAN_DO_DEBUG  
....................  #define CAN_DO_DEBUG FALSE  
.................... #endif  
....................   
.................... #IFNDEF CAN_USE_EXTENDED_ID  
....................   #define CAN_USE_EXTENDED_ID         TRUE  
.................... #ENDIF  
....................   
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH  
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq)  
.................... #ENDIF  
....................   
.................... #IFNDEF CAN_BRG_PRESCALAR  
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc )  
.................... #ENDIF  
....................   
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS  
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable)  
.................... #endif  
....................   
.................... #ifndef CAN_BRG_SAM  
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point)  
.................... #endif  
....................   
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1  
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq)  
.................... #endif  
....................   
.................... #ifndef CAN_BRG_PROPAGATION_TIME  
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq)  
.................... #endif  
....................   
.................... #ifndef CAN_BRG_WAKE_FILTER  
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit  
.................... #endif  
....................   
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2  
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq)  
.................... #endif  
....................   
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER  
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data  
.................... #endif  
....................   
.................... #ifndef CAN_ENABLE_DRIVE_HIGH  
....................  #define CAN_ENABLE_DRIVE_HIGH 0  
.................... #endif  
....................   
.................... #ifndef CAN_ENABLE_CAN_CAPTURE  
....................  #define CAN_ENABLE_CAN_CAPTURE 0  
.................... #endif  
....................   
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_SLEEP=1, CAN_OP_NORMAL=0};  
....................   
.................... //can control  
.................... struct struct_CANCTRL {  
....................    int  clkpre:2; //0:1 //clkout pin prescalar  
....................    int1 clken; //2   //clkout pin enable  
....................    int1 void3; //3  
....................    int1 abat;  //4   //abort all pending transmissions  
....................    CAN_OP_MODE reqop:3; //5:7 //request operation mode  
.................... };  
.................... #define CANCTRL   0x0F  //or 1f, or 2f, or 3f ... or 7f  
....................   
.................... enum CAN_INT_CODE {CAN_INT_RX1=7, CAN_INT_RX0=6, CAN_INT_TX2=5, CAN_INT_TX1=4, CAN_INT_TX0=3, CAN_INT_WAKEUP=2, CAN_INT_ERROR=1, CAN_INT_NO=0};  
....................   
.................... //can status register READ-ONLY  
.................... struct struct_CANSTAT {  
.................... 	int1 void0;	//0  
.................... 	CAN_INT_CODE icode:3;	//1:3	//interrupt code  
.................... 	int1 void4;	//4  
.................... 	CAN_OP_MODE opmode:3;	//5:7	//operation mode status  
.................... };  
.................... #define CANSTAT 0x0E //or 1e, or 2e ... or 7e  
....................   
.................... //error flag register  
.................... struct struct_EFLG {  
.................... 	int1 ewarn;		//0 //error warning  
.................... 	int1 rxwar;		//1 //receiver warning  
.................... 	int1 txwar;		//2 //transmitter warning  
.................... 	int1 rxep;	//3 //receive error passive flag  
.................... 	int1 txep;	//4 //transmit error passive flag  
.................... 	int1 txbo;	//5	//bus off error flag  
.................... 	int1 rx0ovr;	//6	//receive buffer 0 overflow  
.................... 	int1 rx1ovr;	//7	//receive buffer 1 overflow  
.................... };  
.................... #define EFLG   0x2D  
....................   
.................... //interupt enable register  
.................... struct struct_CANINTE {  
....................    int1 rx0ie; //0   //receive buffer 0 full interrupt enable  
....................    int1 rx1ie; //1   //receive buffer 1 full interrupt enable  
....................    int1 tx0ie; //2   //transmit buffer 0 embty interrupt enable  
....................    int1 tx1ie; //3   //transmit buffer 1 embty interrupt enable  
....................    int1 tx2ie; //4   //transmit buffer 2 embty interrupt enable  
....................    int1 errie; //5   //error interrupt enable  
....................    int1 wakie; //6   //wakeup interrupt  enable  
....................    int1 merre; //7   //message error interrupt enable  
.................... };  
.................... #define CANINTE   0x2B  
....................   
.................... //interupt enable register  
.................... struct struct_CANINTF {  
....................    int1 rx0if; //0   //receive buffer 0 full interrupt flag  
....................    int1 rx1if; //1   //receive buffer 1 full interrupt flag  
....................    int1 tx0if; //2   //transmit buffer 0 embty interrupt flag  
....................    int1 tx1if; //3   //transmit buffer 1 embty interrupt flag  
....................    int1 tx2if; //4   //transmit buffer 2 embty interrupt flag  
....................    int1 errif; //5   //error interrupt flag  
....................    int1 wakif; //6   //wakeup interrupt flag  
....................    int1 merrf; //7   //message error interrupt flag  
.................... };  
.................... #define CANINTF   0x2C  
....................   
....................   
.................... //error counters  
.................... #define TEC    0x1C  
.................... #define REC    0x1D  
....................   
.................... //baud rate control register 1  
.................... struct struct_CNF1 {  
.................... 	int brp:6;	//0:5	//baud rate prescalar  
.................... 	int sjw:2;	//6:7	//synchronized jump width  
.................... };  
.................... #define CNF1   0x2A  
....................   
.................... //baud rate control register 2  
.................... struct struct_CNF2 {  
.................... 	int prseg:3; //0:2 //propagation time select  
.................... 	int phseg1:3; //3:5 //phase segment 1  
.................... 	int1 sam; //6 //sample of the can bus line  
.................... 	int1 btlmode; //7 //phase segment 2 bit time length  
.................... };  
.................... #define CNF2   0x29  
....................   
.................... //baud rate control register 3  
.................... struct struct_CNF3 {  
.................... 	int phseg2:3;	//0:2	//phase segment 2 time select  
.................... 	int void543:3;	//3:5  
.................... 	int1 wakfil;	//6 //selects can bus line filter for wake-up  
.................... 	int1 void7;	//7  
.................... };  
.................... #define CNF3   0x28  
.................... //can i/o control register  
....................   
.................... //transmit buffer n control register  
.................... struct txbNctrl_struct {  
.................... 	int  txpri:2;	//0:1	//transmit priority bits  
.................... 	int1 void2; //2  
.................... 	int1 txreq;	//3	//transmit request status (clear to request message abort)  
.................... 	int1 txerr;	//4	//transmission error detected  
.................... 	int1 mloa;	//5	//message lost arbitration  
.................... 	int1 abtf;	//6	//message was aborted / or transmitted succesfully  
.................... 	int1 void7;  
.................... };  
.................... #define TXB0CTRL  0x30  
.................... #define TXB1CTRL  0x40  
.................... #define TXB2CTRL  0x50  
....................   
.................... //TXnRTS pin control and status register  
.................... struct struct_TXRTSCTRL {  
....................    int1 b0rtsm; //0  //1=request message trans, 0=digital  
....................    int1 b1rtsm; //1  //1=request message trans, 0=digital  
....................    int1 b2rtsm; //2  //1=request message trans, 0=digital  
....................    int1 b0rts; //3   //reads as tx2rts when in digital, 0 when in rts  
....................    int1 b1rts; //4   //reads as tx2rts when in digital, 0 when in rts mode  
....................    int1 b2rts; //5  //reads as tx2rts when in digital, 0 when in rts mode  
....................    int  void67:2; //6:7  
.................... };  
.................... #define TXRTSCTRL 0x0D  
....................   
.................... //transmit buffer n standard identifier  
.................... #define TXB0SIDH 0x31  
.................... #define TXB0SIDL 0x32  
.................... #define TXB1SIDH 0x41  
.................... #define TXB1SIDL 0x42  
.................... #define TXB2SIDH 0x51  
.................... #define TXB2SIDL 0x52  
....................   
.................... //transmit buffer n extended identifier  
.................... #define TXB0EIDH 0x33  
.................... #define TXB0EIDL 0x34  
.................... #define TXB1EIDH 0x43  
.................... #define TXB1EIDL 0x44  
.................... #define TXB2EIDH 0x53  
.................... #define TXB2EIDL 0x54  
....................   
.................... //transmit buffer n data byte m  
.................... #define TXB0D0 0x36  
.................... #define TXB0D7 0x3D  
....................   
.................... #define TXB1D0 0x46  
.................... #define TXB1D7 0x4D  
....................   
.................... #define TXB2D0 0x56  
.................... #define TXB2D7 0x5D  
....................   
.................... //transmit buffer n data length  
.................... struct txbNdlc_struct {  
.................... 	int dlc:4;	//0:3  
.................... 	int void54:2; //4:5  
.................... 	int1 rtr; //6 //transmission frame remote tranmission  
.................... 	int1 void7; //7  
.................... };  
.................... #define TXB0DLC 0x35  
.................... #define TXB1DLC 0x45  
.................... #define TXB2DLC 0x55  
....................   
.................... //#byte TXBaDLC=0xF65  //txbXdlc when in the access bank  
....................   
....................   
.................... //transmit error count register  
.................... #byte TXERRCNT=0xF76  
....................   
....................   
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0};  
....................   
.................... //receive buffer 0 control register  
.................... struct struct_RXB0CTRL {  
.................... 	int1 filhit0;	//0 //filter hit  
.................... 	int1 bukt1;	//1 //read only copy of bukt bit (used internally by mcp2510)  
.................... 	int1 bukt;	//2 //rollover enable  
.................... 	int1 rxrtr;	//3 //receive remote transfer request  
.................... 	int1 void4;	//4  
.................... 	CAN_RX_MODE rxm:2;	//5:6 //receiver buffer mode  
.................... 	int1 void7;	//7 //receive full status  
.................... };  
.................... #define RXB0CTRL  0x60  
....................   
.................... //receive buffer 1 control register  
.................... struct struct_RXB1CTRL {  
.................... 	int filhit0:3;	//0:2  
.................... 	int1 rxrtr;	//3 //receive remote transfer request  
.................... 	int1 void4;	//4  
.................... 	CAN_RX_MODE rxm:2;	//5:6 //receive buffer mode  
.................... 	int1 void7;	//7  
.................... };  
.................... #define RXB1CTRL 0x70  
....................   
.................... //RXnBF pint control and status register  
.................... struct struct_BFPCTRL {  
....................    int1  b0bfm; //0   //1=pin is interrupt when message loaded into rxb0, 0=digital  
....................    int1  b1bfm; //1   //1=pin is interrupt when message loaded into rxb1, 0=digital  
....................    int1  b0bfe; //2   //rx0bf pin function enable  
....................    int1  b1bfe; //3   //rx1bf pin function enable  
....................    int1  b0bfs; //4   //rx0bf pin state  
....................    int1  b1bfs; //5   //rx1bf pin state  
.................... };  
....................   
.................... //receive buffer n standard identifier  
.................... #define	RXB0SIDH  0x61  
.................... #define	RXB0SIDL  0x62  
....................   
.................... #define	RXB1SIDH  0x71  
.................... #define	RXB1SIDL  0x72  
....................   
.................... //receive buffer n extended identifier  
.................... #define	RXB0EID8  0x63  
.................... #define	RXB0EID0  0x64  
....................   
.................... #define	RXB1EID8  0x73  
.................... #define	RXB1EID0  0x74  
....................   
.................... struct struct_TXRXBaSIDL {  
....................    int void012:3; //0:2  
....................    int1 ext;      //3 //extendid id  
....................    int1 srr;      //4 //substitute remove request bit  
....................    int void567:3; //5:7  
.................... };  
....................   
.................... //receive buffer n data length code register  
.................... struct rxbNdlc_struct {  
.................... 	int dlc:4;	//0:3 //data length code  
.................... 	int1 rb0;   //4   //reserved  
.................... 	int1 rb1;	//5   //reserved  
.................... 	int1 rtr;	//6   //receiver remote transmission request bit  
.................... 	int1 void7;	//7  
.................... };  
.................... #define	RXB0DLC   0x65  
.................... #define	RXB1DLC   0x75  
....................   
.................... //receive buffer n data field byte m register  
.................... #define RXB0D0    0x66  
.................... #define RXB0D7    0x6D  
....................   
.................... #define RXB1D0    0x76  
.................... #define RXB1D7    0x7D  
....................   
....................   
.................... //receive acceptance filter n standard indifier  
.................... #define RXF0SIDH  0x00  
.................... #define RXF0SIDL  0x01  
.................... #define RXF1SIDH  0x04  
.................... #define RXF1SIDL  0x05  
.................... #define RXF2SIDH  0x08  
.................... #define RXF2SIDL  0x09  
.................... #define RXF3SIDH  0x10  
.................... #define RXF3SIDL  0x11  
.................... #define RXF4SIDH  0x14  
.................... #define RXF4SIDL  0x15  
.................... #define RXF5SIDH  0x18  
.................... #define RXF5SIDL  0x19  
....................   
.................... //receive acceptance filter n extended indifier  
.................... #define RXF0EIDH  0x02  
.................... #define RXF0EIDL  0x03  
.................... #define RXF1EIDH  0x06  
.................... #define RXF1EIDL  0x07  
.................... #define RXF2EIDH  0x0a  
.................... #define RXF2EIDL  0x0b  
.................... #define RXF3EIDH  0x12  
.................... #define RXF3EIDL  0x13  
.................... #define RXF4EIDH  0x16  
.................... #define RXF4EIDL  0x17  
.................... #define RXF5EIDH  0x1a  
.................... #define RXF5EIDL  0x1b  
....................   
.................... //receive acceptance mask n standard identifer mask  
.................... #define RXM0SIDH  0x20  
.................... #define RXM0SIDL  0x21  
.................... #define RXM1SIDH  0x24  
.................... #define RXM1SIDL  0x25  
....................   
.................... //receive acceptance mask n extended identifer mask  
.................... #define RXM0EIDH  0x22  
.................... #define RXM0EIDL  0x23  
.................... #define RXM1EIDH  0x26  
.................... #define RXM1EIDL  0x27  
....................   
.................... #define RX0MASK       RXM0EIDL   //rxm0eidl  
.................... #define RX1MASK       RXM1EIDL   //rxm1eidl  
.................... #define RX0FILTER0    RXF0EIDL   //rxf0eidl  
.................... #define RX0FILTER1    RXF1EIDL   //rxf1eidl  
.................... #define RX1FILTER2    RXF2EIDL   //rxf2eidl  
.................... #define RX1FILTER3    RXF3EIDL   //rxf3eidl  
.................... #define RX1FILTER4    RXF4EIDL   //rxf4eidl  
.................... #define RX1FILTER5    RXF5EIDL   //rxf5eidl  
.................... #define RXB0ID        RXB0EIDL   //rxb0eidl  
.................... #define RXB1ID        RXB1EIDL   //rxb1eidl  
.................... #define TXB0ID        TXB0EIDL   //txb0eidl  
.................... #define TXB1ID        TXB1EIDL   //txb1eidl  
.................... #define TXB2ID        TXB2EIDL   //tsb2eidl  
....................   
.................... //value to put in mask field to accept all incoming id's  
.................... #define CAN_MASK_ACCEPT_ALL   0  
....................   
....................   
.................... //PROTOTYPES and MACROS  
....................   
.................... struct rx_stat {  
....................    int1 err_ovfl;  
....................    int filthit:3;  
....................    int1 buffer;  
....................    int1 rtr;  
....................    int1 ext;  
....................    int1 inv;  
.................... };  
....................   
.................... /* variables bus can */  
.................... int32 crx_id;  
.................... int crxbuf[8];  
.................... int ctxbuf[8];  
.................... int ic,crx_len;  
.................... struct rx_stat rxstat;  
....................   
....................   
.................... void  can_init(void);  
.................... void  can_set_baud(void);  
.................... void  can_set_mode(CAN_OP_MODE mode);  
.................... void can_set_id(int addr, int32 id, int1 ext);  
.................... int32 can_get_id(int addr, int1 ext);  
.................... int   can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr);  
.................... int1  can_getd(int32 & id, int * data, int & len, struct rx_stat & stat);  
....................   
.................... void mcp2510_init();  
.................... void mcp2510_command(int command);  
.................... void mcp2510_write(int address, int data);  
.................... int mcp2510_status(void);  
.................... int mcp2510_read(int address);  
....................   
....................   
....................  
....................   
.................... //IO pins connected to MCP2510  
.................... #ifndef EXT_CAN_CS  
....................    #define EXT_CAN_CS   PIN_B3  
....................    #define EXT_CAN_SI   PIN_C5  
....................    #define EXT_CAN_SO   PIN_C4  
....................    #define EXT_CAN_SCK  PIN_C3  
.................... //   #define EXT_CAN_RESET   PIN_B5 //CCS library does not use this pin by default  
.................... //   #define EXT_CAN_TX0RTS  PIN_C4 //CCS library does not use this pin by default  
.................... //   #define EXT_CAN_TX1RTS  PIN_B4 //CCS library does not use this pin by default  
.................... //   #define EXT_CAN_TX2RTS  PIN_C2 //CCS library does not use this pin by default  
.................... #endif  
....................   
.................... #if CAN_DO_DEBUG  
....................  #define can_debug printf  
.................... #else  
....................  #define can_debug  
.................... #endif  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_init()  
.................... //  
.................... // Initializes MCP2510 CAN peripheral.  Sets the RX filter and masks so the  
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers  
.................... // to only accept valid valid messages (as opposed to all messages, or all  
.................... // extended message, or all standard messages).  
.................... //  
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH,  
.................... // CAN_ENABLE_CAN_CAPTURE, etc) are given a default define in the can-mcp2510.h file.  
.................... // These default values can be overwritten in the main code, but most  
.................... // applications will be fine with these defaults.  
.................... //  
.................... //////////////////////////////////////////////////////////////////////////////  
.................... void can_init(void) {  
....................    struct struct_RXB0CTRL b_rxb0ctrl;  
....................   
....................    mcp2510_init();  
....................   
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set  
*
08FA:  MOVLW  04
08FB:  BSF    03.5
08FC:  MOVWF  5A
08FD:  BCF    0A.3
08FE:  BCF    03.5
08FF:  CALL   588
0900:  BSF    0A.3
....................    can_set_baud();  
....................   
....................    b_rxb0ctrl=0;  
*
0941:  BSF    03.5
0942:  CLRF   59
....................    b_rxb0ctrl.rxm=CAN_RX_VALID;  
0943:  MOVLW  9F
0944:  ANDWF  59,W
0945:  MOVWF  59
....................    b_rxb0ctrl.bukt=CAN_USE_RX_DOUBLE_BUFFER;  
0946:  BSF    59.2
....................    mcp2510_write(RXB0CTRL, (int)b_rxb0ctrl);  
0947:  MOVLW  60
0948:  BCF    03.5
0949:  BSF    03.6
094A:  MOVWF  1C
094B:  BSF    03.5
094C:  BCF    03.6
094D:  MOVF   59,W
094E:  BCF    03.5
094F:  BSF    03.6
0950:  MOVWF  1D
0951:  BCF    0A.3
0952:  BCF    03.6
0953:  CALL   550
0954:  BSF    0A.3
....................    mcp2510_write(RXB1CTRL, (int)b_rxb0ctrl);  
0955:  MOVLW  70
0956:  BSF    03.6
0957:  MOVWF  1C
0958:  BSF    03.5
0959:  BCF    03.6
095A:  MOVF   59,W
095B:  BCF    03.5
095C:  BSF    03.6
095D:  MOVWF  1D
095E:  BCF    0A.3
095F:  BCF    03.6
0960:  CALL   550
0961:  BSF    0A.3
....................   
....................    //if you want to configure the TXnRTS pins, do it here.  default is off  
....................   
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 (RX BUFFER 0)  
0962:  MOVLW  23
0963:  BSF    03.5
0964:  MOVWF  6F
0965:  BCF    03.5
0966:  BSF    03.6
0967:  CLRF   13
0968:  CLRF   12
0969:  CLRF   11
096A:  CLRF   10
096B:  MOVLW  01
096C:  MOVWF  14
096D:  BCF    0A.3
096E:  BCF    03.6
096F:  CALL   5B9
0970:  BSF    0A.3
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 (RX BUFFER 0)  
0971:  MOVLW  03
0972:  BSF    03.5
0973:  MOVWF  6F
0974:  BCF    03.5
0975:  BSF    03.6
0976:  CLRF   13
0977:  CLRF   12
0978:  CLRF   11
0979:  CLRF   10
097A:  MOVLW  01
097B:  MOVWF  14
097C:  BCF    0A.3
097D:  BCF    03.6
097E:  CALL   5B9
097F:  BSF    0A.3
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 (RX BUFFER 0)  
0980:  MOVLW  07
0981:  BSF    03.5
0982:  MOVWF  6F
0983:  BCF    03.5
0984:  BSF    03.6
0985:  CLRF   13
0986:  CLRF   12
0987:  CLRF   11
0988:  CLRF   10
0989:  MOVLW  01
098A:  MOVWF  14
098B:  BCF    0A.3
098C:  BCF    03.6
098D:  CALL   5B9
098E:  BSF    0A.3
....................   
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 (RX BUFFER 1)  
098F:  MOVLW  27
0990:  BSF    03.5
0991:  MOVWF  6F
0992:  BCF    03.5
0993:  BSF    03.6
0994:  CLRF   13
0995:  CLRF   12
0996:  CLRF   11
0997:  CLRF   10
0998:  MOVLW  01
0999:  MOVWF  14
099A:  BCF    0A.3
099B:  BCF    03.6
099C:  CALL   5B9
099D:  BSF    0A.3
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 (RX BUFFER 1)  
099E:  MOVLW  0B
099F:  BSF    03.5
09A0:  MOVWF  6F
09A1:  BCF    03.5
09A2:  BSF    03.6
09A3:  CLRF   13
09A4:  CLRF   12
09A5:  CLRF   11
09A6:  CLRF   10
09A7:  MOVLW  01
09A8:  MOVWF  14
09A9:  BCF    0A.3
09AA:  BCF    03.6
09AB:  CALL   5B9
09AC:  BSF    0A.3
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 (RX BUFFER 1)  
09AD:  MOVLW  13
09AE:  BSF    03.5
09AF:  MOVWF  6F
09B0:  BCF    03.5
09B1:  BSF    03.6
09B2:  CLRF   13
09B3:  CLRF   12
09B4:  CLRF   11
09B5:  CLRF   10
09B6:  MOVLW  01
09B7:  MOVWF  14
09B8:  BCF    0A.3
09B9:  BCF    03.6
09BA:  CALL   5B9
09BB:  BSF    0A.3
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 (RX BUFFER 1)  
09BC:  MOVLW  17
09BD:  BSF    03.5
09BE:  MOVWF  6F
09BF:  BCF    03.5
09C0:  BSF    03.6
09C1:  CLRF   13
09C2:  CLRF   12
09C3:  CLRF   11
09C4:  CLRF   10
09C5:  MOVLW  01
09C6:  MOVWF  14
09C7:  BCF    0A.3
09C8:  BCF    03.6
09C9:  CALL   5B9
09CA:  BSF    0A.3
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 (RX BUFFER 1)  
09CB:  MOVLW  1B
09CC:  BSF    03.5
09CD:  MOVWF  6F
09CE:  BCF    03.5
09CF:  BSF    03.6
09D0:  CLRF   13
09D1:  CLRF   12
09D2:  CLRF   11
09D3:  CLRF   10
09D4:  MOVLW  01
09D5:  MOVWF  14
09D6:  BCF    0A.3
09D7:  BCF    03.6
09D8:  CALL   5B9
09D9:  BSF    0A.3
....................   
....................    can_set_mode(CAN_OP_NORMAL);  
09DA:  BSF    03.5
09DB:  CLRF   5A
09DC:  BCF    0A.3
09DD:  BCF    03.5
09DE:  CALL   588
09DF:  BSF    0A.3
09E0:  NOP
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_set_baud()  
.................... //  
.................... // Configures the baud rate control registers.  All the defines here  
.................... // are defaulted in the can-mcp2510.h file.  These defaults can, and  
.................... // probably should, be overwritten in the main code.  
.................... //  
.................... // Current defaults are set to work with CCS's CAN Prototype board and  
.................... // Microchip's MCP250xxx CAN Developers Kit if this PIC is running at 20Mhz.  
.................... //  
.................... ////////////////////////////////////////////////////////////////////////  
.................... void can_set_baud(void) {  
....................    struct struct_CNF1 new_CNF1;  
....................    struct struct_CNF2 new_CNF2;  
....................    struct struct_CNF3 new_CNF3;  
....................   
....................   
....................    new_CNF1.brp=CAN_BRG_PRESCALAR;  
*
0901:  MOVLW  C0
0902:  BSF    03.5
0903:  ANDWF  5A,W
0904:  IORLW  04
0905:  MOVWF  5A
....................    new_CNF1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH;  
0906:  MOVLW  3F
0907:  ANDWF  5A,W
0908:  MOVWF  5A
....................   
....................    new_CNF2.prseg=CAN_BRG_PROPAGATION_TIME;  
0909:  MOVLW  F8
090A:  ANDWF  5B,W
090B:  IORLW  02
090C:  MOVWF  5B
....................    new_CNF2.phseg1=CAN_BRG_PHASE_SEGMENT_1;  
090D:  MOVLW  C7
090E:  ANDWF  5B,W
090F:  IORLW  28
0910:  MOVWF  5B
....................    new_CNF2.sam=CAN_BRG_SAM;  
0911:  BCF    5B.6
....................    new_CNF2.btlmode=CAN_BRG_SEG_2_PHASE_TS;  
0912:  BSF    5B.7
....................   
....................    new_CNF3.phseg2=CAN_BRG_PHASE_SEGMENT_2;  
0913:  MOVLW  F8
0914:  ANDWF  5C,W
0915:  IORLW  05
0916:  MOVWF  5C
....................    new_CNF3.wakfil=CAN_BRG_WAKE_FILTER;  
0917:  BCF    5C.6
....................   
....................    mcp2510_write(CNF1, (int)new_CNF1);  
0918:  MOVLW  2A
0919:  BCF    03.5
091A:  BSF    03.6
091B:  MOVWF  1C
091C:  BSF    03.5
091D:  BCF    03.6
091E:  MOVF   5A,W
091F:  BCF    03.5
0920:  BSF    03.6
0921:  MOVWF  1D
0922:  BCF    0A.3
0923:  BCF    03.6
0924:  CALL   550
0925:  BSF    0A.3
....................    mcp2510_write(CNF2, (int)new_CNF2);  
0926:  MOVLW  29
0927:  BSF    03.6
0928:  MOVWF  1C
0929:  BSF    03.5
092A:  BCF    03.6
092B:  MOVF   5B,W
092C:  BCF    03.5
092D:  BSF    03.6
092E:  MOVWF  1D
092F:  BCF    0A.3
0930:  BCF    03.6
0931:  CALL   550
0932:  BSF    0A.3
....................    mcp2510_write(CNF3, (int)new_CNF3);  
0933:  MOVLW  28
0934:  BSF    03.6
0935:  MOVWF  1C
0936:  BSF    03.5
0937:  BCF    03.6
0938:  MOVF   5C,W
0939:  BCF    03.5
093A:  BSF    03.6
093B:  MOVWF  1D
093C:  BCF    0A.3
093D:  BCF    03.6
093E:  CALL   550
093F:  BSF    0A.3
0940:  NOP
.................... }  
....................   
.................... void can_set_mode(CAN_OP_MODE mode) {  
....................      
....................    struct struct_CANCTRL old_CANCTRL;  
....................   
....................    old_CANCTRL=mcp2510_read(CANCTRL);  
*
0588:  MOVLW  0F
0589:  BSF    03.6
058A:  MOVWF  1B
058B:  BCF    03.6
058C:  CALL   4F5
058D:  MOVF   78,W
058E:  BSF    03.5
058F:  MOVWF  5B
....................    old_CANCTRL.reqop=mode;  
0590:  SWAPF  5A,W
0591:  ANDLW  70
0592:  MOVWF  77
0593:  BCF    03.0
0594:  RLF    77,F
0595:  MOVLW  1F
0596:  ANDWF  5B,W
0597:  IORWF  77,W
0598:  MOVWF  5B
....................    // old_CANCTRL.clkpre=2; instruction pour passer à une division par 4 au lieu de 8  
....................    mcp2510_write(CANCTRL, (int)old_CANCTRL);  
0599:  MOVLW  0F
059A:  BCF    03.5
059B:  BSF    03.6
059C:  MOVWF  1C
059D:  BSF    03.5
059E:  BCF    03.6
059F:  MOVF   5B,W
05A0:  BCF    03.5
05A1:  BSF    03.6
05A2:  MOVWF  1D
05A3:  BCF    03.6
05A4:  CALL   550
....................      
....................    do {  
....................       old_CANCTRL=mcp2510_read(CANCTRL);  
05A5:  MOVLW  0F
05A6:  BSF    03.6
05A7:  MOVWF  1B
05A8:  BCF    03.6
05A9:  CALL   4F5
05AA:  MOVF   78,W
05AB:  BSF    03.5
05AC:  MOVWF  5B
....................    } while (old_CANCTRL.reqop != mode);  
05AD:  MOVF   5B,W
05AE:  MOVWF  77
05AF:  SWAPF  77,F
05B0:  RRF    77,W
05B1:  ANDLW  07
05B2:  SUBWF  5A,W
05B3:  BTFSC  03.2
05B4:  GOTO   5B7
05B5:  BCF    03.5
05B6:  GOTO   5A5
.................... }  
05B7:  BCF    03.5
05B8:  RETLW  00
....................   
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_set_id()  
.................... //  
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to  
.................... // configure the defined buffer to use the specified ID  
.................... //  
.................... //   Paramaters:  
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL.  
.................... //            For example, a pointer to RXM1EIDL  
.................... //     id - ID to set buffer to  
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not  
.................... //  
.................... ////////////////////////////////////////////////////////////////////////  
.................... void can_set_id(int addr, int32 id, int1 ext) {  
....................    int converted_id[4];  
....................    int *ptr;  
....................   
....................    ptr=&converted_id[3];   //3=eidl, 2=eidh, 1=sidl, 0=sidh  
05B9:  MOVLW  01
05BA:  BSF    03.6
05BB:  MOVWF  1A
05BC:  MOVLW  18
05BD:  MOVWF  19
....................   
....................    if (ext) {  //extended  
05BE:  MOVF   14,F
05BF:  BTFSC  03.2
05C0:  GOTO   61A
....................       //eidl  
....................       *ptr=make8(id,0); //0:7  
05C1:  MOVF   19,W
05C2:  MOVWF  04
05C3:  BCF    03.7
05C4:  BTFSC  1A.0
05C5:  BSF    03.7
05C6:  MOVF   10,W
05C7:  MOVWF  00
....................   
....................       //eidh  
....................       ptr--;  
05C8:  MOVF   19,W
05C9:  BTFSC  03.2
05CA:  DECF   1A,F
05CB:  DECF   19,F
....................       *ptr=make8(id,1); //8:15  
05CC:  MOVF   19,W
05CD:  MOVWF  04
05CE:  BCF    03.7
05CF:  BTFSC  1A.0
05D0:  BSF    03.7
05D1:  MOVF   11,W
05D2:  MOVWF  00
....................   
....................       //sidl  
....................       ptr--;  
05D3:  MOVF   19,W
05D4:  BTFSC  03.2
05D5:  DECF   1A,F
05D6:  DECF   19,F
....................       *ptr=make8(id,2) & 0x03;   //16:17  
05D7:  MOVF   19,W
05D8:  MOVWF  04
05D9:  BCF    03.7
05DA:  BTFSC  1A.0
05DB:  BSF    03.7
05DC:  MOVF   12,W
05DD:  ANDLW  03
05DE:  MOVWF  00
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20  
05DF:  MOVF   19,W
05E0:  MOVWF  04
05E1:  BCF    03.7
05E2:  BTFSC  1A.0
05E3:  BSF    03.7
05E4:  MOVF   12,W
05E5:  MOVWF  77
05E6:  RLF    77,F
05E7:  RLF    77,F
05E8:  RLF    77,F
05E9:  MOVLW  F8
05EA:  ANDWF  77,F
05EB:  MOVF   77,W
05EC:  ANDLW  E0
05ED:  IORWF  00,W
05EE:  MOVWF  00
....................       *ptr|=0x08;  
05EF:  MOVF   19,W
05F0:  MOVWF  04
05F1:  BCF    03.7
05F2:  BTFSC  1A.0
05F3:  BSF    03.7
05F4:  MOVF   00,W
05F5:  IORLW  08
05F6:  MOVWF  00
....................   
....................   
....................       //sidh  
....................       ptr--;  
05F7:  MOVF   19,W
05F8:  BTFSC  03.2
05F9:  DECF   1A,F
05FA:  DECF   19,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23  
05FB:  MOVF   19,W
05FC:  MOVWF  04
05FD:  BCF    03.7
05FE:  BTFSC  1A.0
05FF:  BSF    03.7
0600:  MOVF   12,W
0601:  MOVWF  77
0602:  SWAPF  77,F
0603:  RRF    77,F
0604:  MOVLW  07
0605:  ANDWF  77,F
0606:  MOVF   77,W
0607:  ANDLW  07
0608:  MOVWF  00
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28  
0609:  MOVF   19,W
060A:  MOVWF  04
060B:  BCF    03.7
060C:  BTFSC  1A.0
060D:  BSF    03.7
060E:  MOVF   13,W
060F:  MOVWF  77
0610:  RLF    77,F
0611:  RLF    77,F
0612:  RLF    77,F
0613:  MOVLW  F8
0614:  ANDWF  77,F
0615:  MOVF   77,W
0616:  ANDLW  F8
0617:  IORWF  00,W
0618:  MOVWF  00
....................    }  
....................    else {   //standard  
0619:  GOTO   65E
....................       //eidl  
....................       *ptr=0;  
061A:  MOVF   19,W
061B:  MOVWF  04
061C:  BCF    03.7
061D:  BTFSC  1A.0
061E:  BSF    03.7
061F:  CLRF   00
....................   
....................       //eidh  
....................       ptr--;  
0620:  MOVF   19,W
0621:  BTFSC  03.2
0622:  DECF   1A,F
0623:  DECF   19,F
....................       *ptr=0;  
0624:  MOVF   19,W
0625:  MOVWF  04
0626:  BCF    03.7
0627:  BTFSC  1A.0
0628:  BSF    03.7
0629:  CLRF   00
....................   
....................       //sidl  
....................       ptr--;  
062A:  MOVF   19,W
062B:  BTFSC  03.2
062C:  DECF   1A,F
062D:  DECF   19,F
....................       *ptr=(make8(id,0) << 5) & 0xE0;  
062E:  MOVF   19,W
062F:  MOVWF  04
0630:  BCF    03.7
0631:  BTFSC  1A.0
0632:  BSF    03.7
0633:  MOVF   10,W
0634:  MOVWF  77
0635:  SWAPF  77,F
0636:  RLF    77,F
0637:  MOVLW  E0
0638:  ANDWF  77,F
0639:  MOVF   77,W
063A:  ANDLW  E0
063B:  MOVWF  00
....................   
....................       //sidh  
....................       ptr--;  
063C:  MOVF   19,W
063D:  BTFSC  03.2
063E:  DECF   1A,F
063F:  DECF   19,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F;  
0640:  MOVF   19,W
0641:  MOVWF  04
0642:  BCF    03.7
0643:  BTFSC  1A.0
0644:  BSF    03.7
0645:  MOVF   10,W
0646:  MOVWF  77
0647:  RRF    77,F
0648:  RRF    77,F
0649:  RRF    77,F
064A:  MOVLW  1F
064B:  ANDWF  77,F
064C:  MOVF   77,W
064D:  ANDLW  1F
064E:  MOVWF  00
....................       *ptr|=(make8(id,1) << 5) & 0xE0;  
064F:  MOVF   19,W
0650:  MOVWF  04
0651:  BCF    03.7
0652:  BTFSC  1A.0
0653:  BSF    03.7
0654:  MOVF   11,W
0655:  MOVWF  77
0656:  SWAPF  77,F
0657:  RLF    77,F
0658:  MOVLW  E0
0659:  ANDWF  77,F
065A:  MOVF   77,W
065B:  ANDLW  E0
065C:  IORWF  00,W
065D:  MOVWF  00
....................    }  
....................   
....................    //0=eidl, 1=eidh, 2=sidl, 3=sidh  
....................    mcp2510_write(addr--, converted_id[3]);  
065E:  BSF    03.5
065F:  BCF    03.6
0660:  MOVF   6F,W
0661:  DECF   6F,F
0662:  BCF    03.5
0663:  BSF    03.6
0664:  MOVWF  1B
0665:  MOVWF  1C
0666:  MOVF   18,W
0667:  MOVWF  1D
0668:  BCF    03.6
0669:  CALL   550
....................    mcp2510_write(addr--, converted_id[2]);  
066A:  BSF    03.5
066B:  MOVF   6F,W
066C:  DECF   6F,F
066D:  BCF    03.5
066E:  BSF    03.6
066F:  MOVWF  1B
0670:  MOVWF  1C
0671:  MOVF   17,W
0672:  MOVWF  1D
0673:  BCF    03.6
0674:  CALL   550
....................    mcp2510_write(addr--, converted_id[1]);  
0675:  BSF    03.5
0676:  MOVF   6F,W
0677:  DECF   6F,F
0678:  BCF    03.5
0679:  BSF    03.6
067A:  MOVWF  1B
067B:  MOVWF  1C
067C:  MOVF   16,W
067D:  MOVWF  1D
067E:  BCF    03.6
067F:  CALL   550
....................    mcp2510_write(addr, converted_id[0]);  
0680:  BSF    03.5
0681:  MOVF   6F,W
0682:  BCF    03.5
0683:  BSF    03.6
0684:  MOVWF  1C
0685:  MOVF   15,W
0686:  MOVWF  1D
0687:  BCF    03.6
0688:  CALL   550
.................... }  
0689:  RETLW  00
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_get_id()  
.................... //  
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id())  
.................... // This is used after receiving a message, to see which ID sent the message.  
.................... //  
.................... //   Paramaters:  
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL.  
.................... //            For example, a pointer to RXM1EIDL  
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not  
.................... //  
.................... //   Returns:  
.................... //     The ID of the buffer  
.................... //  
.................... ////////////////////////////////////////////////////////////////////////  
.................... int32 can_get_id(int addr, int1 ext) {  
....................    int32 ret;  
....................    int * ptr;  
....................    int converted_id[4];  
....................   
....................    ptr=&converted_id[3];   //3=eidl, 2=eidh, 1=sidl, 0=sidh  
*
0C64:  MOVLW  01
0C65:  BCF    03.5
0C66:  BSF    03.6
0C67:  MOVWF  15
0C68:  MOVLW  19
0C69:  MOVWF  14
....................   
....................    converted_id[3]=mcp2510_read(addr--);  
0C6A:  BSF    03.5
0C6B:  BCF    03.6
0C6C:  MOVF   6D,W
0C6D:  DECF   6D,F
0C6E:  BCF    03.5
0C6F:  BSF    03.6
0C70:  MOVWF  1A
0C71:  MOVWF  1B
0C72:  BCF    0A.3
0C73:  BCF    03.6
0C74:  CALL   4F5
0C75:  BSF    0A.3
0C76:  MOVF   78,W
0C77:  BSF    03.6
0C78:  MOVWF  19
....................    converted_id[2]=mcp2510_read(addr--);  
0C79:  BSF    03.5
0C7A:  BCF    03.6
0C7B:  MOVF   6D,W
0C7C:  DECF   6D,F
0C7D:  BCF    03.5
0C7E:  BSF    03.6
0C7F:  MOVWF  1A
0C80:  MOVWF  1B
0C81:  BCF    0A.3
0C82:  BCF    03.6
0C83:  CALL   4F5
0C84:  BSF    0A.3
0C85:  MOVF   78,W
0C86:  BSF    03.6
0C87:  MOVWF  18
....................    converted_id[1]=mcp2510_read(addr--);  
0C88:  BSF    03.5
0C89:  BCF    03.6
0C8A:  MOVF   6D,W
0C8B:  DECF   6D,F
0C8C:  BCF    03.5
0C8D:  BSF    03.6
0C8E:  MOVWF  1A
0C8F:  MOVWF  1B
0C90:  BCF    0A.3
0C91:  BCF    03.6
0C92:  CALL   4F5
0C93:  BSF    0A.3
0C94:  MOVF   78,W
0C95:  BSF    03.6
0C96:  MOVWF  17
....................    converted_id[0]=mcp2510_read(addr);  
0C97:  BSF    03.5
0C98:  BCF    03.6
0C99:  MOVF   6D,W
0C9A:  BCF    03.5
0C9B:  BSF    03.6
0C9C:  MOVWF  1B
0C9D:  BCF    0A.3
0C9E:  BCF    03.6
0C9F:  CALL   4F5
0CA0:  BSF    0A.3
0CA1:  MOVF   78,W
0CA2:  BSF    03.6
0CA3:  MOVWF  16
....................   
....................    ret=0;  
0CA4:  CLRF   13
0CA5:  CLRF   12
0CA6:  CLRF   11
0CA7:  CLRF   10
....................   
....................   
....................    if (ext) {  
0CA8:  BSF    03.5
0CA9:  BCF    03.6
0CAA:  MOVF   6E,F
0CAB:  BTFSC  03.2
0CAC:  GOTO   558
....................       ret=*ptr;  //eidl  
0CAD:  BCF    03.5
0CAE:  BSF    03.6
0CAF:  MOVF   15,W
0CB0:  MOVWF  7A
0CB1:  MOVF   14,W
0CB2:  MOVWF  04
0CB3:  BCF    03.7
0CB4:  BTFSC  15.0
0CB5:  BSF    03.7
0CB6:  MOVF   00,W
0CB7:  MOVWF  77
0CB8:  CLRF   78
0CB9:  CLRF   79
0CBA:  CLRF   7A
0CBB:  MOVF   7A,W
0CBC:  MOVWF  13
0CBD:  MOVF   79,W
0CBE:  MOVWF  12
0CBF:  MOVF   78,W
0CC0:  MOVWF  11
0CC1:  MOVF   77,W
0CC2:  MOVWF  10
....................   
....................       ptr--;     //eidh  
0CC3:  MOVF   14,W
0CC4:  BTFSC  03.2
0CC5:  DECF   15,F
0CC6:  DECF   14,F
....................       ret|=((int32)*ptr << 8);  
0CC7:  MOVF   14,W
0CC8:  MOVWF  04
0CC9:  BCF    03.7
0CCA:  BTFSC  15.0
0CCB:  BSF    03.7
0CCC:  MOVF   00,W
0CCD:  CLRF   1D
0CCE:  CLRF   1C
0CCF:  CLRF   1B
0CD0:  MOVWF  1A
0CD1:  CLRF   77
0CD2:  MOVF   77,W
0CD3:  IORWF  10,F
0CD4:  MOVF   1A,W
0CD5:  IORWF  11,F
0CD6:  MOVF   1B,W
0CD7:  IORWF  12,F
0CD8:  MOVF   1C,W
0CD9:  IORWF  13,F
....................   
....................       ptr--;     //sidl  
0CDA:  MOVF   14,W
0CDB:  BTFSC  03.2
0CDC:  DECF   15,F
0CDD:  DECF   14,F
....................       ret|=((int32)*ptr & 0x03) << 16;  
0CDE:  MOVF   14,W
0CDF:  MOVWF  04
0CE0:  BCF    03.7
0CE1:  BTFSC  15.0
0CE2:  BSF    03.7
0CE3:  MOVF   00,W
0CE4:  CLRF   1D
0CE5:  CLRF   1C
0CE6:  CLRF   1B
0CE7:  MOVWF  1A
0CE8:  ANDLW  03
0CE9:  MOVWF  1E
0CEA:  MOVF   1B,W
0CEB:  ANDLW  00
0CEC:  MOVWF  1F
0CED:  MOVF   1C,W
0CEE:  ANDLW  00
0CEF:  MOVWF  20
0CF0:  MOVF   1D,W
0CF1:  ANDLW  00
0CF2:  MOVWF  21
0CF3:  CLRF   77
0CF4:  CLRF   78
0CF5:  MOVF   77,W
0CF6:  IORWF  10,F
0CF7:  MOVF   78,W
0CF8:  IORWF  11,F
0CF9:  MOVF   1E,W
0CFA:  IORWF  12,F
0CFB:  MOVF   1F,W
0CFC:  IORWF  13,F
....................       ret|=((int32)*ptr & 0xE0) << 13;  
0CFD:  MOVF   14,W
0CFE:  MOVWF  04
0CFF:  BCF    03.7
0D00:  BTFSC  15.0
0D01:  BSF    03.7
0D02:  MOVF   00,W
0D03:  CLRF   1D
0D04:  CLRF   1C
0D05:  CLRF   1B
0D06:  MOVWF  1A
0D07:  ANDLW  E0
0D08:  MOVWF  1E
0D09:  MOVF   1B,W
0D0A:  ANDLW  00
0D0B:  MOVWF  1F
0D0C:  MOVF   1C,W
0D0D:  ANDLW  00
0D0E:  MOVWF  20
0D0F:  MOVF   1D,W
0D10:  ANDLW  00
0D11:  MOVWF  21
0D12:  CLRF   77
0D13:  RLF    1E,W
0D14:  MOVWF  78
0D15:  RLF    1F,W
0D16:  MOVWF  79
0D17:  RLF    20,W
0D18:  MOVWF  7A
0D19:  RLF    78,F
0D1A:  RLF    79,F
0D1B:  RLF    7A,F
0D1C:  RLF    78,F
0D1D:  RLF    79,F
0D1E:  RLF    7A,F
0D1F:  RLF    78,F
0D20:  RLF    79,F
0D21:  RLF    7A,F
0D22:  RLF    78,F
0D23:  RLF    79,F
0D24:  RLF    7A,F
0D25:  MOVLW  E0
0D26:  ANDWF  78,F
0D27:  MOVF   77,W
0D28:  IORWF  10,F
0D29:  MOVF   78,W
0D2A:  IORWF  11,F
0D2B:  MOVF   79,W
0D2C:  IORWF  12,F
0D2D:  MOVF   7A,W
0D2E:  IORWF  13,F
....................   
....................       ptr--;     //sidh  
0D2F:  MOVF   14,W
0D30:  BTFSC  03.2
0D31:  DECF   15,F
0D32:  DECF   14,F
....................       ret|=((int32)*ptr << 21);  
0D33:  MOVF   14,W
0D34:  MOVWF  04
0D35:  BCF    03.7
0D36:  BTFSC  15.0
0D37:  BSF    03.7
0D38:  MOVF   00,W
0D39:  CLRF   1D
0D3A:  CLRF   1C
0D3B:  CLRF   1B
0D3C:  MOVWF  1A
0D3D:  CLRF   77
0D3E:  CLRF   78
0D3F:  RLF    1A,W
0D40:  MOVWF  79
0D41:  RLF    1B,W
0D42:  MOVWF  7A
0D43:  RLF    79,F
0D44:  RLF    7A,F
0D45:  RLF    79,F
0D46:  RLF    7A,F
0D47:  RLF    79,F
0D48:  RLF    7A,F
0D49:  RLF    79,F
0D4A:  RLF    7A,F
0D4B:  MOVLW  E0
0D4C:  ANDWF  79,F
0D4D:  MOVF   77,W
0D4E:  IORWF  10,F
0D4F:  MOVF   78,W
0D50:  IORWF  11,F
0D51:  MOVF   79,W
0D52:  IORWF  12,F
0D53:  MOVF   7A,W
0D54:  IORWF  13,F
....................    }  
....................    else {  
0D55:  GOTO   5B7
0D56:  BSF    03.5
0D57:  BCF    03.6
....................       ptr-=2;    //sidl  
0D58:  MOVLW  02
0D59:  BCF    03.5
0D5A:  BSF    03.6
0D5B:  SUBWF  14,F
0D5C:  MOVLW  00
0D5D:  BTFSS  03.0
0D5E:  MOVLW  01
0D5F:  SUBWF  15,F
....................       ret=((int32)*ptr & 0xE0) >> 5;  
0D60:  MOVF   14,W
0D61:  MOVWF  04
0D62:  BCF    03.7
0D63:  BTFSC  15.0
0D64:  BSF    03.7
0D65:  MOVF   00,W
0D66:  CLRF   1D
0D67:  CLRF   1C
0D68:  CLRF   1B
0D69:  MOVWF  1A
0D6A:  ANDLW  E0
0D6B:  MOVWF  1E
0D6C:  MOVF   1B,W
0D6D:  ANDLW  00
0D6E:  MOVWF  1F
0D6F:  MOVF   1C,W
0D70:  ANDLW  00
0D71:  MOVWF  20
0D72:  MOVF   1D,W
0D73:  ANDLW  00
0D74:  MOVWF  21
0D75:  RRF    21,W
0D76:  MOVWF  13
0D77:  RRF    20,W
0D78:  MOVWF  12
0D79:  RRF    1F,W
0D7A:  MOVWF  11
0D7B:  RRF    1E,W
0D7C:  MOVWF  10
0D7D:  RRF    13,F
0D7E:  RRF    12,F
0D7F:  RRF    11,F
0D80:  RRF    10,F
0D81:  RRF    13,F
0D82:  RRF    12,F
0D83:  RRF    11,F
0D84:  RRF    10,F
0D85:  RRF    13,F
0D86:  RRF    12,F
0D87:  RRF    11,F
0D88:  RRF    10,F
0D89:  RRF    13,F
0D8A:  RRF    12,F
0D8B:  RRF    11,F
0D8C:  RRF    10,F
0D8D:  MOVLW  07
0D8E:  ANDWF  13,F
....................   
....................       ptr--;     //sidh  
0D8F:  MOVF   14,W
0D90:  BTFSC  03.2
0D91:  DECF   15,F
0D92:  DECF   14,F
....................       ret|=((int32)*ptr << 3);  
0D93:  MOVF   14,W
0D94:  MOVWF  04
0D95:  BCF    03.7
0D96:  BTFSC  15.0
0D97:  BSF    03.7
0D98:  MOVF   00,W
0D99:  CLRF   1D
0D9A:  CLRF   1C
0D9B:  CLRF   1B
0D9C:  MOVWF  1A
0D9D:  RLF    1A,W
0D9E:  MOVWF  77
0D9F:  RLF    1B,W
0DA0:  MOVWF  78
0DA1:  RLF    1C,W
0DA2:  MOVWF  79
0DA3:  RLF    1D,W
0DA4:  MOVWF  7A
0DA5:  RLF    77,F
0DA6:  RLF    78,F
0DA7:  RLF    79,F
0DA8:  RLF    7A,F
0DA9:  RLF    77,F
0DAA:  RLF    78,F
0DAB:  RLF    79,F
0DAC:  RLF    7A,F
0DAD:  MOVLW  F8
0DAE:  ANDWF  77,F
0DAF:  MOVF   77,W
0DB0:  IORWF  10,F
0DB1:  MOVF   78,W
0DB2:  IORWF  11,F
0DB3:  MOVF   79,W
0DB4:  IORWF  12,F
0DB5:  MOVF   7A,W
0DB6:  IORWF  13,F
....................    }  
....................   
....................    return(ret);  
0DB7:  MOVF   10,W
0DB8:  MOVWF  77
0DB9:  MOVF   11,W
0DBA:  MOVWF  78
0DBB:  MOVF   12,W
0DBC:  MOVWF  79
0DBD:  MOVF   13,W
0DBE:  MOVWF  7A
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_putd()  
.................... //  
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will  
.................... // send when the CAN bus becomes available.  
.................... //  
.................... //    Paramaters:  
.................... //       id - ID to transmit data as  
.................... //       data - pointer to data to send  
.................... //       len - length of data to send  
.................... //       priority - priority of message.  The higher the number, the  
.................... //                  sooner the CAN peripheral will send the message.  
.................... //                  Numbers 0 through 3 are valid.  
.................... //       ext - TRUE to use an extended ID, FALSE if not  
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT  
.................... //  
.................... //    Returns:  
.................... //       If successful, it will return TRUE  
.................... //       If un-successful, will return FALSE  
.................... //  
.................... ////////////////////////////////////////////////////////////////////////  
.................... int1 can_putd(int32 id, int * data, int len, int priority, int1 ext, int1 rtr) {  
....................    int i;  
....................    int port;  
....................   
....................    int TXRXBaD0;  
....................    int TXBaCTRL;  
....................    int TXRXBaEIDL;  
....................    int TXBaDLC;  
....................   
....................    struct txbNctrl_struct b_TXBaCTRL;  
....................    struct rxbNdlc_struct b_TXBaDLC;  
....................    struct txbNctrl_struct b_TXB0CTRL, b_TXB1CTRL, b_TXB2CTRL;  
....................   
....................    b_TXB0CTRL=mcp2510_read(TXB0CTRL);  
*
068A:  MOVLW  30
068B:  BSF    03.6
068C:  MOVWF  1B
068D:  BCF    03.6
068E:  CALL   4F5
068F:  MOVF   78,W
0690:  BSF    03.5
0691:  MOVWF  6C
....................    b_TXB1CTRL=mcp2510_read(TXB1CTRL);  
0692:  MOVLW  40
0693:  BCF    03.5
0694:  BSF    03.6
0695:  MOVWF  1B
0696:  BCF    03.6
0697:  CALL   4F5
0698:  MOVF   78,W
0699:  BSF    03.5
069A:  MOVWF  6D
....................    b_TXB2CTRL=mcp2510_read(TXB2CTRL);  
069B:  MOVLW  50
069C:  BCF    03.5
069D:  BSF    03.6
069E:  MOVWF  1B
069F:  BCF    03.6
06A0:  CALL   4F5
06A1:  MOVF   78,W
06A2:  BSF    03.5
06A3:  MOVWF  6E
....................   
....................     // find emtpy transmitter  
....................     //map access bank addresses to empty transmitter  
....................    if (!b_TXB0CTRL.txreq) {  
06A4:  BTFSC  6C.3
06A5:  GOTO   6B0
....................       TXRXBaD0=TXB0D0;  
06A6:  MOVLW  36
06A7:  MOVWF  66
....................       TXBaCTRL=TXB0CTRL;  
06A8:  MOVLW  30
06A9:  MOVWF  67
....................       TXRXBaEIDL=TXB0EIDL;  
06AA:  MOVLW  34
06AB:  MOVWF  68
....................       TXBaDLC=TXB0DLC;  
06AC:  MOVLW  35
06AD:  MOVWF  69
....................       port=0;  
06AE:  CLRF   65
....................    }  
....................    else if (!b_TXB1CTRL.txreq) {  
06AF:  GOTO   6CD
06B0:  BTFSC  6D.3
06B1:  GOTO   6BD
....................       TXRXBaD0=TXB1D0;  
06B2:  MOVLW  46
06B3:  MOVWF  66
....................       TXBaCTRL=TXB1CTRL;  
06B4:  MOVLW  40
06B5:  MOVWF  67
....................       TXRXBaEIDL=TXB1EIDL;  
06B6:  MOVLW  44
06B7:  MOVWF  68
....................       TXBaDLC=TXB1DLC;  
06B8:  MOVLW  45
06B9:  MOVWF  69
....................       port=1;  
06BA:  MOVLW  01
06BB:  MOVWF  65
....................    }  
....................    else if (!b_TXB2CTRL.txreq) {  
06BC:  GOTO   6CD
06BD:  BTFSC  6E.3
06BE:  GOTO   6CA
....................       TXRXBaD0=TXB2D0;  
06BF:  MOVLW  56
06C0:  MOVWF  66
....................       TXBaCTRL=TXB2CTRL;  
06C1:  MOVLW  50
06C2:  MOVWF  67
....................       TXRXBaEIDL=TXB2EIDL;  
06C3:  MOVLW  54
06C4:  MOVWF  68
....................       TXBaDLC=TXB2DLC;  
06C5:  MOVLW  55
06C6:  MOVWF  69
....................       port=2;  
06C7:  MOVLW  02
06C8:  MOVWF  65
....................    }  
....................    else {  
06C9:  GOTO   6CD
....................       #if CAN_DO_DEBUG  
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n");  
....................       #endif  
....................       return(0);  
06CA:  MOVLW  00
06CB:  MOVWF  78
06CC:  GOTO   758
....................    }  
....................   
....................    //set priority.  
....................    b_TXBaCTRL=mcp2510_read(TXBaCTRL);  
06CD:  MOVF   67,W
06CE:  BCF    03.5
06CF:  BSF    03.6
06D0:  MOVWF  1B
06D1:  BCF    03.6
06D2:  CALL   4F5
06D3:  MOVF   78,W
06D4:  BSF    03.5
06D5:  MOVWF  6A
....................    b_TXBaCTRL.txpri=priority;  
06D6:  MOVF   61,W
06D7:  ANDLW  03
06D8:  MOVWF  77
06D9:  MOVLW  FC
06DA:  ANDWF  6A,W
06DB:  IORWF  77,W
06DC:  MOVWF  6A
....................    mcp2510_write(TXBaCTRL, (int)b_TXBaCTRL);  
06DD:  MOVF   67,W
06DE:  BCF    03.5
06DF:  BSF    03.6
06E0:  MOVWF  1C
06E1:  BSF    03.5
06E2:  BCF    03.6
06E3:  MOVF   6A,W
06E4:  BCF    03.5
06E5:  BSF    03.6
06E6:  MOVWF  1D
06E7:  BCF    03.6
06E8:  CALL   550
....................   
....................    //set tx mask  
....................    can_set_id(TXRXBaEIDL, id, ext);  
06E9:  BSF    03.5
06EA:  MOVF   68,W
06EB:  MOVWF  6F
06EC:  MOVF   5D,W
06ED:  BCF    03.5
06EE:  BSF    03.6
06EF:  MOVWF  13
06F0:  BSF    03.5
06F1:  BCF    03.6
06F2:  MOVF   5C,W
06F3:  BCF    03.5
06F4:  BSF    03.6
06F5:  MOVWF  12
06F6:  BSF    03.5
06F7:  BCF    03.6
06F8:  MOVF   5B,W
06F9:  BCF    03.5
06FA:  BSF    03.6
06FB:  MOVWF  11
06FC:  BSF    03.5
06FD:  BCF    03.6
06FE:  MOVF   5A,W
06FF:  BCF    03.5
0700:  BSF    03.6
0701:  MOVWF  10
0702:  BSF    03.5
0703:  BCF    03.6
0704:  MOVF   62,W
0705:  BCF    03.5
0706:  BSF    03.6
0707:  MOVWF  14
0708:  BCF    03.6
0709:  CALL   5B9
....................   
....................    //set tx data count  
....................    b_TXBaDLC=len;  
070A:  BSF    03.5
070B:  MOVF   60,W
070C:  MOVWF  6B
....................    b_TXBaDLC.rtr=rtr;  
070D:  BCF    6B.6
070E:  BTFSC  63.0
070F:  BSF    6B.6
....................    mcp2510_write(TXBaDLC, (int)b_TXBaDLC);  
0710:  MOVF   69,W
0711:  BCF    03.5
0712:  BSF    03.6
0713:  MOVWF  1C
0714:  BSF    03.5
0715:  BCF    03.6
0716:  MOVF   6B,W
0717:  BCF    03.5
0718:  BSF    03.6
0719:  MOVWF  1D
071A:  BCF    03.6
071B:  CALL   550
....................   
....................    //write to buffer  
....................     for (i=TXRXBaD0; i<(TXRXBaD0 + len); i++) {  
071C:  BSF    03.5
071D:  MOVF   66,W
071E:  MOVWF  64
071F:  MOVF   60,W
0720:  ADDWF  66,W
0721:  SUBWF  64,W
0722:  BTFSC  03.0
0723:  GOTO   73F
....................       mcp2510_write(i,*data);  
0724:  MOVF   5F,W
0725:  MOVWF  7A
0726:  MOVF   5E,W
0727:  MOVWF  04
0728:  BCF    03.7
0729:  BTFSC  5F.0
072A:  BSF    03.7
072B:  MOVF   00,W
072C:  MOVWF  6F
072D:  MOVF   64,W
072E:  BCF    03.5
072F:  BSF    03.6
0730:  MOVWF  1C
0731:  BSF    03.5
0732:  BCF    03.6
0733:  MOVF   6F,W
0734:  BCF    03.5
0735:  BSF    03.6
0736:  MOVWF  1D
0737:  BCF    03.6
0738:  CALL   550
....................       data++;  
0739:  BSF    03.5
073A:  INCF   5E,F
073B:  BTFSC  03.2
073C:  INCF   5F,F
....................     }  
073D:  INCF   64,F
073E:  GOTO   71F
....................   
....................    //enable transmission  
....................    b_TXBaCTRL=mcp2510_read(TXBaCTRL);  
073F:  MOVF   67,W
0740:  BCF    03.5
0741:  BSF    03.6
0742:  MOVWF  1B
0743:  BCF    03.6
0744:  CALL   4F5
0745:  MOVF   78,W
0746:  BSF    03.5
0747:  MOVWF  6A
....................    b_TXBaCTRL.txreq=1;  
0748:  BSF    6A.3
....................    mcp2510_write(TXBaCTRL, (int)b_TXBaCTRL);  
0749:  MOVF   67,W
074A:  BCF    03.5
074B:  BSF    03.6
074C:  MOVWF  1C
074D:  BSF    03.5
074E:  BCF    03.6
074F:  MOVF   6A,W
0750:  BCF    03.5
0751:  BSF    03.6
0752:  MOVWF  1D
0753:  BCF    03.6
0754:  CALL   550
....................   
....................    #if CAN_DO_DEBUG  
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr);  
....................             if ((len)&&(!rtr)) {  
....................                data-=len;  
....................                can_debug("  DATA = ");  
....................                for (i=0;i<len;i++) {  
....................                   can_debug("%X ",*data);  
....................                   data++;  
....................                }  
....................                can_debug("\r\n");  
....................             }  
....................    #endif  
....................   
....................    return(1);  
0755:  MOVLW  01
0756:  MOVWF  78
0757:  BSF    03.5
.................... }  
0758:  BCF    03.5
0759:  RETLW  00
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_getd()  
.................... //  
.................... // Gets data from a receive buffer, if the data exists  
.................... //  
.................... //    Returns:  
.................... //      id - ID who sent message  
.................... //      data - pointer to array of data  
.................... //      len - length of received data  
.................... //      stat - structure holding some information (such as which buffer  
.................... //             recieved it, ext or standard, etc)  
.................... //  
.................... //    Returns:  
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE  
.................... //      if there was none.  
.................... //  
.................... ////////////////////////////////////////////////////////////////////////  
.................... int1 can_getd(int32 & id, int * data, int & len, struct rx_stat & stat)  
.................... {  
....................     int i;  
....................   
....................    struct struct_RXB0CTRL b_RXB0CTRL;  
....................    struct struct_RXB1CTRL b_RXB1CTRL;  
....................    struct struct_EFLG b_EFLG;  
....................   
....................    int RXBaDLC;  
....................    struct rxbNdlc_struct b_RXBaDLC;  
....................   
....................    int TXRXBaSIDL;  
....................    struct struct_TXRXBaSIDL b_TXRXBaSIDL;  
....................   
....................   
....................    int RXBaD0;  
....................    struct struct_CANINTF b_CANINTF;  
....................   
....................    b_CANINTF=mcp2510_read(CANINTF);  
*
0BA0:  MOVLW  2C
0BA1:  BCF    03.5
0BA2:  BSF    03.6
0BA3:  MOVWF  1B
0BA4:  BCF    0A.3
0BA5:  BCF    03.6
0BA6:  CALL   4F5
0BA7:  BSF    0A.3
0BA8:  MOVF   78,W
0BA9:  BSF    03.5
0BAA:  MOVWF  64
....................   
....................    b_RXB0CTRL=mcp2510_read(RXB0CTRL);  
0BAB:  MOVLW  60
0BAC:  BCF    03.5
0BAD:  BSF    03.6
0BAE:  MOVWF  1B
0BAF:  BCF    0A.3
0BB0:  BCF    03.6
0BB1:  CALL   4F5
0BB2:  BSF    0A.3
0BB3:  MOVF   78,W
0BB4:  BSF    03.5
0BB5:  MOVWF  5C
....................    b_RXB1CTRL=mcp2510_read(RXB1CTRL);  
0BB6:  MOVLW  70
0BB7:  BCF    03.5
0BB8:  BSF    03.6
0BB9:  MOVWF  1B
0BBA:  BCF    0A.3
0BBB:  BCF    03.6
0BBC:  CALL   4F5
0BBD:  BSF    0A.3
0BBE:  MOVF   78,W
0BBF:  BSF    03.5
0BC0:  MOVWF  5D
....................    b_EFLG=mcp2510_read(EFLG);  
0BC1:  MOVLW  2D
0BC2:  BCF    03.5
0BC3:  BSF    03.6
0BC4:  MOVWF  1B
0BC5:  BCF    0A.3
0BC6:  BCF    03.6
0BC7:  CALL   4F5
0BC8:  BSF    0A.3
0BC9:  MOVF   78,W
0BCA:  BSF    03.5
0BCB:  MOVWF  5E
....................   
....................     if (b_CANINTF.rx0if) {  
0BCC:  BTFSS  64.0
0BCD:  GOTO   3FD
....................         stat.buffer=0;  
0BCE:  BCF    03.5
0BCF:  BCF    6B.4
....................   
....................         stat.err_ovfl=b_EFLG.rx0ovr;  
0BD0:  BCF    6B.0
0BD1:  BSF    03.5
0BD2:  BTFSS  5E.6
0BD3:  GOTO   3D7
0BD4:  BCF    03.5
0BD5:  BSF    6B.0
0BD6:  BSF    03.5
....................         b_EFLG.rx0ovr=0;  
0BD7:  BCF    5E.6
....................         mcp2510_write(EFLG, (int)b_EFLG);  
0BD8:  MOVLW  2D
0BD9:  BCF    03.5
0BDA:  BSF    03.6
0BDB:  MOVWF  1C
0BDC:  BSF    03.5
0BDD:  BCF    03.6
0BDE:  MOVF   5E,W
0BDF:  BCF    03.5
0BE0:  BSF    03.6
0BE1:  MOVWF  1D
0BE2:  BCF    0A.3
0BE3:  BCF    03.6
0BE4:  CALL   550
0BE5:  BSF    0A.3
....................   
....................         if (b_RXB0CTRL.bukt) {  
0BE6:  BSF    03.5
0BE7:  BTFSS  5C.2
0BE8:  GOTO   3F6
....................          stat.filthit=b_RXB0CTRL.filhit0;  
0BE9:  MOVLW  00
0BEA:  BTFSC  5C.0
0BEB:  MOVLW  01
0BEC:  ANDLW  07
0BED:  MOVWF  77
0BEE:  BCF    03.0
0BEF:  RLF    77,F
0BF0:  MOVLW  F1
0BF1:  BCF    03.5
0BF2:  ANDWF  6B,W
0BF3:  IORWF  77,W
0BF4:  MOVWF  6B
0BF5:  BSF    03.5
....................         }  
....................   
....................         RXBaDLC=RXB0DLC;  
0BF6:  MOVLW  65
0BF7:  MOVWF  5F
....................         TXRXBaSIDL=RXB0SIDL;  
0BF8:  MOVLW  62
0BF9:  MOVWF  61
....................         RXBaD0=RXB0D0;  
0BFA:  MOVLW  66
0BFB:  MOVWF  63
....................     }  
....................     else if (b_CANINTF.rx1if)  
0BFC:  GOTO   42E
0BFD:  BTFSS  64.1
0BFE:  GOTO   42B
....................     {  
....................         stat.buffer=1;  
0BFF:  BCF    03.5
0C00:  BSF    6B.4
....................   
....................         stat.err_ovfl=b_EFLG.rx1ovr;  
0C01:  BCF    6B.0
0C02:  BSF    03.5
0C03:  BTFSS  5E.7
0C04:  GOTO   408
0C05:  BCF    03.5
0C06:  BSF    6B.0
0C07:  BSF    03.5
....................         b_EFLG.rx1ovr=0;  
0C08:  BCF    5E.7
....................         mcp2510_write(EFLG, (int)b_EFLG);  
0C09:  MOVLW  2D
0C0A:  BCF    03.5
0C0B:  BSF    03.6
0C0C:  MOVWF  1C
0C0D:  BSF    03.5
0C0E:  BCF    03.6
0C0F:  MOVF   5E,W
0C10:  BCF    03.5
0C11:  BSF    03.6
0C12:  MOVWF  1D
0C13:  BCF    0A.3
0C14:  BCF    03.6
0C15:  CALL   550
0C16:  BSF    0A.3
....................   
....................   
....................         stat.filthit=b_RXB1CTRL.filhit0;  
0C17:  BSF    03.5
0C18:  MOVF   5D,W
0C19:  ANDLW  07
0C1A:  ANDLW  07
0C1B:  MOVWF  77
0C1C:  BCF    03.0
0C1D:  RLF    77,F
0C1E:  MOVLW  F1
0C1F:  BCF    03.5
0C20:  ANDWF  6B,W
0C21:  IORWF  77,W
0C22:  MOVWF  6B
....................         RXBaDLC=RXB1DLC;  
0C23:  MOVLW  75
0C24:  BSF    03.5
0C25:  MOVWF  5F
....................         TXRXBaSIDL=RXB1SIDL;  
0C26:  MOVLW  72
0C27:  MOVWF  61
....................         RXBaD0=RXB1D0;  
0C28:  MOVLW  76
0C29:  MOVWF  63
....................     }  
....................     else {  
0C2A:  GOTO   42E
....................       #if CAN_DO_DEBUG  
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n");  
....................       #endif  
....................       return (0);  
0C2B:  MOVLW  00
0C2C:  MOVWF  78
0C2D:  GOTO   612
....................     }  
....................   
....................    //get count  
....................     b_RXBaDLC=mcp2510_read(RXBaDLC);  
0C2E:  MOVF   5F,W
0C2F:  BCF    03.5
0C30:  BSF    03.6
0C31:  MOVWF  1B
0C32:  BCF    0A.3
0C33:  BCF    03.6
0C34:  CALL   4F5
0C35:  BSF    0A.3
0C36:  MOVF   78,W
0C37:  BSF    03.5
0C38:  MOVWF  60
....................     len = b_RXBaDLC.dlc;  
0C39:  MOVF   60,W
0C3A:  ANDLW  0F
0C3B:  BCF    03.5
0C3C:  MOVWF  6A
....................     stat.rtr=b_RXBaDLC.rtr;  
0C3D:  BCF    6B.5
0C3E:  BSF    03.5
0C3F:  BTFSS  60.6
0C40:  GOTO   444
0C41:  BCF    03.5
0C42:  BSF    6B.5
0C43:  BSF    03.5
....................   
....................    //was it extended or standard? 
....................     b_TXRXBaSIDL=mcp2510_read(TXRXBaSIDL);  
0C44:  MOVF   61,W
0C45:  BCF    03.5
0C46:  BSF    03.6
0C47:  MOVWF  1B
0C48:  BCF    0A.3
0C49:  BCF    03.6
0C4A:  CALL   4F5
0C4B:  BSF    0A.3
0C4C:  MOVF   78,W
0C4D:  BSF    03.5
0C4E:  MOVWF  62
....................     stat.ext=b_TXRXBaSIDL.ext;  
0C4F:  BCF    03.5
0C50:  BCF    6B.6
0C51:  BSF    03.5
0C52:  BTFSS  62.3
0C53:  GOTO   457
0C54:  BCF    03.5
0C55:  BSF    6B.6
0C56:  BSF    03.5
....................     id=can_get_id(TXRXBaSIDL + 2,stat.ext);  
0C57:  MOVLW  02
0C58:  ADDWF  61,W
0C59:  MOVWF  65
0C5A:  MOVLW  00
0C5B:  BCF    03.5
0C5C:  BTFSC  6B.6
0C5D:  MOVLW  01
0C5E:  BSF    03.5
0C5F:  MOVWF  66
0C60:  MOVF   65,W
0C61:  MOVWF  6D
0C62:  MOVF   66,W
0C63:  MOVWF  6E
*
0DBF:  MOVF   7A,W
0DC0:  BCF    03.6
0DC1:  MOVWF  58
0DC2:  MOVF   79,W
0DC3:  MOVWF  57
0DC4:  MOVF   78,W
0DC5:  MOVWF  56
0DC6:  MOVF   77,W
0DC7:  MOVWF  55
....................   
....................    //get data  
....................     for ( i = RXBaD0; i < (RXBaD0 + len); i++ ) {  
0DC8:  BSF    03.5
0DC9:  MOVF   63,W
0DCA:  MOVWF  5B
0DCB:  BCF    03.5
0DCC:  MOVF   6A,W
0DCD:  BSF    03.5
0DCE:  ADDWF  63,W
0DCF:  SUBWF  5B,W
0DD0:  BTFSC  03.0
0DD1:  GOTO   5ED
....................          *data=mcp2510_read(i);  
0DD2:  MOVF   5A,W
0DD3:  MOVWF  7A
0DD4:  MOVF   59,W
0DD5:  MOVWF  65
0DD6:  MOVF   5A,W
0DD7:  MOVWF  66
0DD8:  MOVF   5B,W
0DD9:  BCF    03.5
0DDA:  BSF    03.6
0DDB:  MOVWF  1B
0DDC:  BCF    0A.3
0DDD:  BCF    03.6
0DDE:  CALL   4F5
0DDF:  BSF    0A.3
0DE0:  BSF    03.5
0DE1:  MOVF   65,W
0DE2:  MOVWF  04
0DE3:  BCF    03.7
0DE4:  BTFSC  66.0
0DE5:  BSF    03.7
0DE6:  MOVF   78,W
0DE7:  MOVWF  00
....................         data++;  
0DE8:  INCF   59,F
0DE9:  BTFSC  03.2
0DEA:  INCF   5A,F
....................     }  
0DEB:  INCF   5B,F
0DEC:  GOTO   5CB
....................   
....................     stat.inv=b_CANINTF.merrf;  
0DED:  BCF    03.5
0DEE:  BCF    6B.7
0DEF:  BSF    03.5
0DF0:  BTFSS  64.7
0DF1:  GOTO   5F5
0DF2:  BCF    03.5
0DF3:  BSF    6B.7
0DF4:  BSF    03.5
....................     if (b_CANINTF.merrf) {  
0DF5:  BTFSS  64.7
0DF6:  GOTO   5F8
....................       b_CANINTF.merrf=0;  
0DF7:  BCF    64.7
....................     }  
....................   
....................     if (stat.buffer) {  
0DF8:  BCF    03.5
0DF9:  BTFSS  6B.4
0DFA:  GOTO   5FF
....................       b_CANINTF.rx1if=0;  
0DFB:  BSF    03.5
0DFC:  BCF    64.1
....................     }  
....................     else {  
0DFD:  GOTO   601
0DFE:  BCF    03.5
....................       b_CANINTF.rx0if=0;  
0DFF:  BSF    03.5
0E00:  BCF    64.0
....................     }  
....................     mcp2510_write(CANINTF, (int)b_CANINTF);  
0E01:  MOVLW  2C
0E02:  BCF    03.5
0E03:  BSF    03.6
0E04:  MOVWF  1C
0E05:  BSF    03.5
0E06:  BCF    03.6
0E07:  MOVF   64,W
0E08:  BCF    03.5
0E09:  BSF    03.6
0E0A:  MOVWF  1D
0E0B:  BCF    0A.3
0E0C:  BCF    03.6
0E0D:  CALL   550
0E0E:  BSF    0A.3
....................   
....................     #if CAN_DO_DEBUG  
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl);  
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv);  
....................        if ((len)&&(!stat.rtr)) {  
....................           data-=len;  
....................           can_debug("\r\n    DATA = ");  
....................           for (i=0;i<len;i++) {  
....................             can_debug("%X ",*data);  
....................             data++;  
....................           }  
....................        }  
....................        can_debug("\r\n");  
....................     #endif  
....................   
....................     return(1);  
0E0F:  MOVLW  01
0E10:  MOVWF  78
0E11:  BSF    03.5
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_kbhit()  
.................... //  
.................... // Returns TRUE if there is data in the receive buffers  
.................... //  
.................... //////////////////////////////////////////////////////////////////////////////  
.................... int1 can_kbhit(void) {  
....................    struct struct_CANINTF b_CANINTF;  
....................   
....................    b_CANINTF=mcp2510_read(CANINTF);  
*
0B87:  MOVLW  2C
0B88:  BSF    03.6
0B89:  MOVWF  1B
0B8A:  BCF    0A.3
0B8B:  BCF    03.6
0B8C:  CALL   4F5
0B8D:  BSF    0A.3
0B8E:  MOVF   78,W
0B8F:  BSF    03.5
0B90:  MOVWF  59
....................    if (b_CANINTF.rx0if || b_CANINTF.rx1if)  
0B91:  BTFSC  59.0
0B92:  GOTO   395
0B93:  BTFSS  59.1
0B94:  GOTO   398
....................       {return(1);}  
0B95:  MOVLW  01
0B96:  MOVWF  78
0B97:  GOTO   39A
....................   
....................    return(0);  
0B98:  MOVLW  00
0B99:  MOVWF  78
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_tbe()  
.................... //  
.................... // Returns TRUE if the transmit buffers are empty and ready to transmit data  
.................... //  
.................... //////////////////////////////////////////////////////////////////////////////  
.................... int1 can_tbe(void) {  
....................    struct txbNctrl_struct b_TXB0CTRL, b_TXB1CTRL, b_TXB2CTRL;  
....................   
....................    b_TXB0CTRL=mcp2510_read(TXB0CTRL);  
....................    b_TXB1CTRL=mcp2510_read(TXB1CTRL);  
....................    b_TXB2CTRL=mcp2510_read(TXB2CTRL);  
....................   
....................    if (!b_TXB0CTRL.txreq || !b_TXB1CTRL.txreq || !b_TXB2CTRL.txreq)  
....................       {return(1);}  
....................   
....................    return(0);  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // can_abort()  
.................... //  
.................... // Aborts all pending tranmissions.  
.................... //  
.................... //////////////////////////////////////////////////////////////////////////////  
.................... void can_abort(void) {  
....................    struct struct_CANCTRL b_CANCTRL;  
....................   
....................    b_CANCTRL=mcp2510_read(CANCTRL);  
....................    b_CANCTRL.abat=1;  
....................    mcp2510_write(CANCTRL, (int)b_CANCTRL);  
....................   
....................    delay_ms(5);  
....................    b_CANCTRL.abat=0;  
....................    mcp2510_write(CANCTRL, (int)b_CANCTRL);  
.................... }  
....................   
....................   
....................   
....................   
.................... ///////////////////  
.................... ///  
.................... //  
.................... // SPI CODE  
.................... //  
.................... ///  
.................... //////////////////  
....................   
.................... //data clocked in on rising edge  
.................... //data driven out on falling edge  
.................... int mcp2510_read(int address) {  
....................    int command[2];  
....................    int i;  
....................    int data;  
....................   
....................    command[1]=0x03;  
*
04F5:  MOVLW  03
04F6:  BSF    03.6
04F7:  MOVWF  1D
....................    command[0]=address;  
04F8:  MOVF   1B,W
04F9:  MOVWF  1C
....................   
....................    output_low(EXT_CAN_CS);  
04FA:  BSF    03.5
04FB:  BCF    03.6
04FC:  BCF    06.3
04FD:  BCF    03.5
04FE:  BCF    06.3
....................   
....................    for (i=0;i<16;i++) {  
04FF:  BSF    03.6
0500:  CLRF   1E
0501:  MOVF   1E,W
0502:  SUBLW  0F
0503:  BTFSS  03.0
0504:  GOTO   524
....................       output_bit(EXT_CAN_SI, shift_left(&command[0],2,0));  
0505:  BCF    03.0
0506:  RLF    1C,F
0507:  RLF    1D,F
0508:  BTFSC  03.0
0509:  GOTO   50E
050A:  BCF    03.6
050B:  BCF    07.5
050C:  GOTO   510
050D:  BSF    03.6
050E:  BCF    03.6
050F:  BSF    07.5
0510:  BCF    6C.5
0511:  MOVF   6C,W
0512:  BSF    03.5
0513:  MOVWF  07
*
184F:  MOVLW  FF
1850:  MOVWF  6C
....................       output_high(EXT_CAN_SCK);  
*
0514:  BCF    03.5
0515:  BCF    6C.3
0516:  MOVF   6C,W
0517:  BSF    03.5
0518:  MOVWF  07
0519:  BCF    03.5
051A:  BSF    07.3
....................       output_low(EXT_CAN_SCK);  
051B:  BCF    6C.3
051C:  MOVF   6C,W
051D:  BSF    03.5
051E:  MOVWF  07
051F:  BCF    03.5
0520:  BCF    07.3
....................    }  
0521:  BSF    03.6
0522:  INCF   1E,F
0523:  GOTO   501
....................    for (i=0;i<8;i++) {  
0524:  CLRF   1E
0525:  MOVF   1E,W
0526:  SUBLW  07
0527:  BTFSS  03.0
0528:  GOTO   546
....................       shift_left(&data,1,input(EXT_CAN_SO));  
0529:  BCF    03.6
052A:  BSF    6C.4
052B:  MOVF   6C,W
052C:  BSF    03.5
052D:  MOVWF  07
052E:  BCF    03.5
052F:  BTFSC  07.4
0530:  GOTO   533
0531:  BCF    03.0
0532:  GOTO   534
0533:  BSF    03.0
0534:  BSF    03.6
0535:  RLF    1F,F
....................       output_high(EXT_CAN_SCK);  
0536:  BCF    03.6
0537:  BCF    6C.3
0538:  MOVF   6C,W
0539:  BSF    03.5
053A:  MOVWF  07
053B:  BCF    03.5
053C:  BSF    07.3
....................       output_low(EXT_CAN_SCK);  
053D:  BCF    6C.3
053E:  MOVF   6C,W
053F:  BSF    03.5
0540:  MOVWF  07
0541:  BCF    03.5
0542:  BCF    07.3
....................    }  
0543:  BSF    03.6
0544:  INCF   1E,F
0545:  GOTO   525
....................   
....................    output_high(EXT_CAN_CS);  
0546:  BSF    03.5
0547:  BCF    03.6
0548:  BCF    06.3
0549:  BCF    03.5
054A:  BSF    06.3
....................   
....................    return(data);  
054B:  BSF    03.6
054C:  MOVF   1F,W
054D:  MOVWF  78
.................... }  
054E:  BCF    03.6
054F:  RETLW  00
....................   
.................... int mcp2510_status(void) {  
....................    int command;  
....................    int data;  
....................    int i;  
....................   
....................    command=0xA0;  
....................   
....................    output_low(EXT_CAN_CS);  
....................   
....................    for (i=0;i<8;i++) {  
....................       output_bit(EXT_CAN_SI, shift_left(&command,1,0));  
....................       output_high(EXT_CAN_SCK);  
....................       output_low(EXT_CAN_SCK);  
....................    }  
....................    for (i=0;i<8;i++) {  
....................       shift_left(&data,1,input(EXT_CAN_SO));  
....................       output_high(EXT_CAN_SCK);  
....................       output_low(EXT_CAN_SCK);  
....................    }  
....................    for (i=0;i<8;i++) {  
....................       output_high(EXT_CAN_SCK);  
....................       output_low(EXT_CAN_SCK);  
....................    }  
....................   
....................    output_high(EXT_CAN_CS);  
....................   
....................    return(data);  
.................... }  
....................   
....................   
.................... void mcp2510_write(int address, int data) {  
....................    int command[3];  
....................    int i;  
....................   
....................    command[2]=0x02;  
0550:  MOVLW  02
0551:  BSF    03.6
0552:  MOVWF  20
....................    command[1]=address;  
0553:  MOVF   1C,W
0554:  MOVWF  1F
....................    command[0]=data;  
0555:  MOVF   1D,W
0556:  MOVWF  1E
....................   
....................    output_low(EXT_CAN_CS);  
0557:  BSF    03.5
0558:  BCF    03.6
0559:  BCF    06.3
055A:  BCF    03.5
055B:  BCF    06.3
....................   
....................    for (i=0;i<24;i++) {  
055C:  BSF    03.6
055D:  CLRF   21
055E:  MOVF   21,W
055F:  SUBLW  17
0560:  BTFSS  03.0
0561:  GOTO   582
....................       output_bit(EXT_CAN_SI, shift_left(&command[0],3,0));  
0562:  BCF    03.0
0563:  RLF    1E,F
0564:  RLF    1F,F
0565:  RLF    20,F
0566:  BTFSC  03.0
0567:  GOTO   56C
0568:  BCF    03.6
0569:  BCF    07.5
056A:  GOTO   56E
056B:  BSF    03.6
056C:  BCF    03.6
056D:  BSF    07.5
056E:  BCF    6C.5
056F:  MOVF   6C,W
0570:  BSF    03.5
0571:  MOVWF  07
....................       output_high(EXT_CAN_SCK);  
0572:  BCF    03.5
0573:  BCF    6C.3
0574:  MOVF   6C,W
0575:  BSF    03.5
0576:  MOVWF  07
0577:  BCF    03.5
0578:  BSF    07.3
....................       output_low(EXT_CAN_SCK);  
0579:  BCF    6C.3
057A:  MOVF   6C,W
057B:  BSF    03.5
057C:  MOVWF  07
057D:  BCF    03.5
057E:  BCF    07.3
....................    }  
057F:  BSF    03.6
0580:  INCF   21,F
0581:  GOTO   55E
....................   
....................    output_high(EXT_CAN_CS);  
0582:  BSF    03.5
0583:  BCF    03.6
0584:  BCF    06.3
0585:  BCF    03.5
0586:  BSF    06.3
.................... }  
0587:  RETLW  00
....................   
.................... void mcp2510_command(int command) {  
....................    int i;  
....................   
....................    output_low(EXT_CAN_CS);  
*
08C8:  BCF    06.3
08C9:  BCF    03.5
08CA:  BCF    06.3
....................   
....................    for (i=0;i<8;i++) {  
08CB:  BSF    03.5
08CC:  CLRF   5B
08CD:  MOVF   5B,W
08CE:  SUBLW  07
08CF:  BTFSS  03.0
08D0:  GOTO   0EF
....................       output_bit(EXT_CAN_SI, shift_left(&command,1,0));  
08D1:  BCF    03.0
08D2:  RLF    5A,F
08D3:  BTFSC  03.0
08D4:  GOTO   0D9
08D5:  BCF    03.5
08D6:  BCF    07.5
08D7:  GOTO   0DB
08D8:  BSF    03.5
08D9:  BCF    03.5
08DA:  BSF    07.5
08DB:  BCF    6C.5
08DC:  MOVF   6C,W
08DD:  BSF    03.5
08DE:  MOVWF  07
....................       output_high(EXT_CAN_SCK);  
08DF:  BCF    03.5
08E0:  BCF    6C.3
08E1:  MOVF   6C,W
08E2:  BSF    03.5
08E3:  MOVWF  07
08E4:  BCF    03.5
08E5:  BSF    07.3
....................       output_low(EXT_CAN_SCK);  
08E6:  BCF    6C.3
08E7:  MOVF   6C,W
08E8:  BSF    03.5
08E9:  MOVWF  07
08EA:  BCF    03.5
08EB:  BCF    07.3
....................    }  
08EC:  BSF    03.5
08ED:  INCF   5B,F
08EE:  GOTO   0CD
....................   
....................    output_high(EXT_CAN_CS);  
08EF:  BCF    06.3
08F0:  BCF    03.5
08F1:  BSF    06.3
.................... }  
....................   
.................... void mcp2510_init(void) {  
....................    output_high(EXT_CAN_CS);  
*
08BC:  BCF    06.3
08BD:  BCF    03.5
08BE:  BSF    06.3
....................    output_low(EXT_CAN_SCK);  
08BF:  BCF    6C.3
08C0:  MOVF   6C,W
08C1:  BSF    03.5
08C2:  MOVWF  07
08C3:  BCF    03.5
08C4:  BCF    07.3
....................   
....................    #ifdef EXT_CAN_TX0RTS  
....................     output_high(EXT_CAN_TX0RTS);  
....................    #endif  
....................    #ifdef EXT_CAN_TX1RTS  
....................     output_high(EXT_CAN_TX1RTS);  
....................    #endif  
....................    #ifdef EXT_CAN_TX2RTS  
....................     output_high(EXT_CAN_TX2RTS);  
....................    #endif  
....................   
....................   #ifdef EXT_CAN_TX0RTS  
....................    output_high(EXT_CAN_RESET);  
....................    output_low(EXT_CAN_RESET);  
....................    output_high(EXT_CAN_RESET);  
....................    delay_ms(5);  
....................   #endif  
....................   
....................    mcp2510_command(0xC0);   //reset  
08C5:  MOVLW  C0
08C6:  BSF    03.5
08C7:  MOVWF  5A
....................    delay_ms(5);  
*
08F2:  MOVLW  05
08F3:  BSF    03.5
08F4:  MOVWF  5B
08F5:  BCF    0A.3
08F6:  BCF    03.5
08F7:  CALL   430
08F8:  BSF    0A.3
08F9:  NOP
.................... }  
....................  
.................... #include "lcd.c"                       //driver lcd a consulter pour bits utilises 
....................  /* LCD driver */  
....................   
.................... ///////////////////////////////////////////////////////////////////////////  
.................... ////  lcd_init()   doit etre appele avant les autres fonctions.        ////  
.................... ////                                                                   ////  
.................... ////  lcd_putc(c)  affiche c a la prochaine position LCD.              ////  
.................... ////                     commandes speciales :                         ////  
.................... ////                      \f  efface l'affichage                       ////  
.................... ////                      \n  debut de seconde ligne                   ////  
.................... ////                      \b  en arriere d'une position                ////  
.................... ////                                                                   ////  
.................... ////  lcd_gotoxy(x,y) choix de la position (haut gauche avec 1,1)      ////  
.................... ////                                                                   ////  
.................... ////  lcd_getc(x,y)   renvoie le caractère de la position x,y          ////  
.................... ////                                                                   ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #define LCD_EN          pin_A4  
.................... #define LCD_RW          pin_A5  
.................... #define LCD_RS          pin_C0  
....................   
.................... short disp_lcd, disp_serial;  
....................   
.................... struct lcd_pin_map {  
....................            int     data : 4;  
....................         } lcd;  
....................   
.................... #byte lcd = 5                  // on to port A (at address 5)  
....................   
.................... #define set_tris_lcd(x) set_tris_a(x)  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines  
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line  
....................   
....................   
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6};  
....................                              // These bytes need to be sent to the LCD  
....................                              // to start it up.  
....................   
....................   
....................                              // The following are used for setting  
....................                              // the I/O port direction register.  
....................   
.................... #define LCD_WRITE set_tris_lcd(0x00) // For write mode all pins are out  
.................... #define LCD_READ  set_tris_lcd(0x0f) // For read mode data pins are in  
....................   
.................... void lcd_putc( char c);  
....................   
....................   
.................... void displays(BYTE b)  
.................... {  
....................     if (disp_lcd)  
*
0491:  BTFSS  53.2
0492:  GOTO   4D5
....................     {  
....................         lcd_putc(b);  
0493:  BSF    03.5
0494:  MOVF   5D,W
0495:  MOVWF  5E
....................     }  
....................     if (disp_serial)  
*
04D5:  BTFSS  53.3
04D6:  GOTO   4E5
....................     {  
....................         if (b == '\n')  
04D7:  BSF    03.5
04D8:  MOVF   5D,W
04D9:  SUBLW  0A
04DA:  BTFSS  03.2
04DB:  GOTO   4E1
....................             putchar('\r');  
04DC:  MOVLW  0D
04DD:  MOVWF  63
04DE:  BCF    03.5
04DF:  CALL   48A
04E0:  BSF    03.5
....................         putchar(b);  
04E1:  MOVF   5D,W
04E2:  MOVWF  63
04E3:  BCF    03.5
04E4:  CALL   48A
....................     }  
.................... }  
04E5:  RETLW  00
....................   
.................... BYTE lcd_read_byte() {  
....................       BYTE low,high;  
....................       LCD_READ;  
....................       output_high(LCD_RW);  
....................       delay_cycles(1);  
....................       output_high(LCD_EN);  
....................       delay_cycles(1);  
....................       high = lcd.data;  
....................       output_low(LCD_EN);  
....................       delay_cycles(1);  
....................       output_high(LCD_EN);  
....................       delay_us(1);  
....................       low = lcd.data;  
....................       output_low(LCD_EN);  
....................       LCD_WRITE;  
....................       return( (high<<4) | low);  
.................... }  
....................   
.................... void lcd_send_nibble( BYTE n ) {  
....................       lcd.data = n;  
*
043D:  BSF    03.5
043E:  MOVF   66,W
043F:  ANDLW  0F
0440:  MOVWF  77
0441:  MOVLW  F0
0442:  BCF    03.5
0443:  ANDWF  05,W
0444:  IORWF  77,W
0445:  MOVWF  05
....................       delay_cycles(1);  
0446:  NOP
....................       output_high(LCD_EN);  
0447:  BSF    03.5
0448:  BCF    05.4
0449:  BCF    03.5
044A:  BSF    05.4
....................       delay_us(2);  
044B:  NOP
....................       output_low(LCD_EN);  
044C:  BSF    03.5
044D:  BCF    05.4
044E:  BCF    03.5
044F:  BCF    05.4
.................... }  
0450:  RETLW  00
....................   
.................... void lcd_send_byte( BYTE address, BYTE n ) {  
....................   
....................       output_low(LCD_RS);  
0451:  BCF    6C.0
0452:  MOVF   6C,W
0453:  BSF    03.5
0454:  MOVWF  07
0455:  BCF    03.5
0456:  BCF    07.0
....................       delay_ms(1);  
0457:  MOVLW  D0
0458:  MOVWF  77
0459:  DECFSZ 77,F
045A:  GOTO   459
....................       //while ( bit_test(lcd_read_byte(),7) ) ;  
....................       if (address&&0x01)output_high(LCD_RS);  
045B:  BSF    03.5
045C:  MOVF   63,F
045D:  BTFSC  03.2
045E:  GOTO   468
045F:  BCF    03.5
0460:  BCF    6C.0
0461:  MOVF   6C,W
0462:  BSF    03.5
0463:  MOVWF  07
0464:  BCF    03.5
0465:  BSF    07.0
....................       else output_low(LCD_RS);  
0466:  GOTO   46F
0467:  BSF    03.5
0468:  BCF    03.5
0469:  BCF    6C.0
046A:  MOVF   6C,W
046B:  BSF    03.5
046C:  MOVWF  07
046D:  BCF    03.5
046E:  BCF    07.0
....................       delay_cycles(1);  
046F:  NOP
....................       output_low(LCD_RW);  
0470:  BSF    03.5
0471:  BCF    05.5
0472:  BCF    03.5
0473:  BCF    05.5
....................       delay_cycles(1);  
0474:  NOP
....................       output_low(LCD_EN);  
0475:  BSF    03.5
0476:  BCF    05.4
0477:  BCF    03.5
0478:  BCF    05.4
....................       lcd_send_nibble(n >> 4);  
0479:  BSF    03.5
047A:  SWAPF  64,W
047B:  MOVWF  65
047C:  MOVLW  0F
047D:  ANDWF  65,F
047E:  MOVF   65,W
047F:  MOVWF  66
0480:  BCF    03.5
0481:  CALL   43D
....................       lcd_send_nibble(n & 0xf);  
0482:  BSF    03.5
0483:  MOVF   64,W
0484:  ANDLW  0F
0485:  MOVWF  65
0486:  MOVWF  66
0487:  BCF    03.5
0488:  CALL   43D
.................... }  
0489:  RETLW  00
....................   
.................... void lcd_init() {  
....................     BYTE i;  
....................     LCD_WRITE;  
*
0801:  MOVLW  00
0802:  BSF    03.5
0803:  MOVWF  05
....................     output_low(LCD_RS);  
0804:  BCF    03.5
0805:  BCF    6C.0
0806:  MOVF   6C,W
0807:  BSF    03.5
0808:  MOVWF  07
0809:  BCF    03.5
080A:  BCF    07.0
....................     output_low(LCD_RW);  
080B:  BSF    03.5
080C:  BCF    05.5
080D:  BCF    03.5
080E:  BCF    05.5
....................     output_low(LCD_EN);  
080F:  BSF    03.5
0810:  BCF    05.4
0811:  BCF    03.5
0812:  BCF    05.4
....................     delay_ms(15);  
0813:  MOVLW  0F
0814:  BSF    03.5
0815:  MOVWF  5B
0816:  BCF    0A.3
0817:  BCF    03.5
0818:  CALL   430
0819:  BSF    0A.3
....................     for(i=1;i<=3;++i) {  
081A:  MOVLW  01
081B:  BSF    03.5
081C:  MOVWF  59
081D:  MOVF   59,W
081E:  SUBLW  03
081F:  BTFSS  03.0
0820:  GOTO   031
....................        lcd_send_nibble(3);  
0821:  MOVLW  03
0822:  MOVWF  66
0823:  BCF    0A.3
0824:  BCF    03.5
0825:  CALL   43D
0826:  BSF    0A.3
....................        delay_ms(5);  
0827:  MOVLW  05
0828:  BSF    03.5
0829:  MOVWF  5B
082A:  BCF    0A.3
082B:  BCF    03.5
082C:  CALL   430
082D:  BSF    0A.3
....................     }  
082E:  BSF    03.5
082F:  INCF   59,F
0830:  GOTO   01D
....................     lcd_send_nibble(2);  
0831:  MOVLW  02
0832:  MOVWF  66
0833:  BCF    0A.3
0834:  BCF    03.5
0835:  CALL   43D
0836:  BSF    0A.3
....................     for(i=0;i<=3;++i)  
0837:  BSF    03.5
0838:  CLRF   59
0839:  MOVF   59,W
083A:  SUBLW  03
083B:  BTFSS  03.0
083C:  GOTO   04E
....................        lcd_send_byte(0,LCD_INIT_STRING[i]);  
083D:  MOVF   59,W
083E:  BCF    0A.3
083F:  BCF    03.5
0840:  CALL   045
0841:  BSF    0A.3
0842:  BSF    03.5
0843:  MOVWF  5A
0844:  CLRF   63
0845:  MOVF   5A,W
0846:  MOVWF  64
0847:  BCF    0A.3
0848:  BCF    03.5
0849:  CALL   451
084A:  BSF    0A.3
084B:  BSF    03.5
084C:  INCF   59,F
084D:  GOTO   039
.................... }  
....................   
.................... void lcd_gotoxy( BYTE x, BYTE y) {  
....................    BYTE address;  
....................   
....................    if(y!=1)  
*
04B2:  DECFSZ 60,W
04B3:  GOTO   4B5
04B4:  GOTO   4B8
....................      address=lcd_line_two;  
04B5:  MOVLW  40
04B6:  MOVWF  61
....................    else  
04B7:  GOTO   4B9
....................      address=0;  
04B8:  CLRF   61
....................    address+=x-1;  
04B9:  MOVLW  01
04BA:  SUBWF  5F,W
04BB:  ADDWF  61,F
....................    lcd_send_byte(0,0x80|address);  
04BC:  MOVF   61,W
04BD:  IORLW  80
04BE:  MOVWF  62
04BF:  CLRF   63
04C0:  MOVF   62,W
04C1:  MOVWF  64
04C2:  BCF    03.5
04C3:  CALL   451
04C4:  NOP
.................... }  
....................   
.................... void lcd_putc( char c) {  
....................    switch (c) {  
*
0496:  MOVF   5E,W
0497:  XORLW  0C
0498:  BCF    03.5
0499:  BTFSC  03.2
049A:  GOTO   4A2
049B:  XORLW  06
049C:  BTFSC  03.2
049D:  GOTO   4AD
049E:  XORLW  02
049F:  BTFSC  03.2
04A0:  GOTO   4C6
04A1:  GOTO   4CD
....................      case '\f'   : lcd_send_byte(0,1);  
04A2:  BSF    03.5
04A3:  CLRF   63
04A4:  MOVLW  01
04A5:  MOVWF  64
04A6:  BCF    03.5
04A7:  CALL   451
....................                    delay_ms(1);        //ou 2  
04A8:  MOVLW  D0
04A9:  MOVWF  77
04AA:  DECFSZ 77,F
04AB:  GOTO   4AA
....................                                            break;  
04AC:  GOTO   4D5
....................      case '\n'   : lcd_gotoxy(1,2);        break;  
04AD:  MOVLW  01
04AE:  BSF    03.5
04AF:  MOVWF  5F
04B0:  MOVLW  02
04B1:  MOVWF  60
*
04C5:  GOTO   4D5
....................      case '\b'   : lcd_send_byte(0,0x10);  break;  
04C6:  BSF    03.5
04C7:  CLRF   63
04C8:  MOVLW  10
04C9:  MOVWF  64
04CA:  BCF    03.5
04CB:  CALL   451
04CC:  GOTO   4D5
....................      default     : lcd_send_byte(1,c);     break;  
04CD:  MOVLW  01
04CE:  BSF    03.5
04CF:  MOVWF  63
04D0:  MOVF   5E,W
04D1:  MOVWF  64
04D2:  BCF    03.5
04D3:  CALL   451
04D4:  GOTO   4D5
....................    }  
.................... }  
....................   
.................... char lcd_getc( BYTE x, BYTE y) {  
....................    char value;  
....................   
....................     lcd_gotoxy(x,y);  
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low  
....................     output_high(LCD_RS);  
....................     value = lcd_read_byte();  
....................     output_low(LCD_RS);  
....................     return(value);  
.................... }  
....................   
....................  
.................... #include "gest_time.c"                 //gestion du temps pour les taches 
....................  /* gestion du temps et des taches */  
....................   
.................... /* definition des indicateurs des taches */  
.................... int1 lum_flag;                         //demande donnees luminosite declenche periodiquement  
.................... int1 bat_flag;                         //demande donnees batterie declenche periodiquement  
.................... int1 mot_flag;                         //demande donnees moteur declenche periodiquement  
.................... int1 cor_flag;                         //gestion de la correction declenche periodiquement  
.................... int1 afg_flag;                         //gestion affichage general declenche periodiquement  
.................... int1 afm_flag;                         //indicateur affichage menu pour gel affichage general  
.................... int1 afr_flag;                         //indicateur raffraichissement affichage  
....................   
.................... /* compteurs pour periodicites des taches */  
.................... int16 mst;  
.................... int16 msa;  
.................... int16 msc;  
.................... int16 msl;  
.................... int16 msb;  
.................... int16 msm;  
.................... int16 msr;  
....................   
.................... /* initialisation gestion du temps */  
.................... void time_init(){  
....................    setup_timer_2(T2_DIV_BY_16,8,5);    // parametrage du timer 2  
*
09F0:  MOVLW  20
09F1:  MOVWF  78
09F2:  IORLW  06
09F3:  MOVWF  12
09F4:  MOVLW  08
09F5:  BSF    03.5
09F6:  MOVWF  12
....................    enable_interrupts(INT_TIMER2);      // autorisation interruption timer2  
09F7:  BSF    0C.1
.................... }  
....................   
.................... /* indicateurs des taches activees periodiquement */  
.................... #int_timer2  
.................... void isr_timer2(void) {  
....................    mst++;                               //timer qui est appele toutes les ms par une interruption du timer2  
*
02EA:  INCF   6E,F
02EB:  BTFSC  03.2
02EC:  INCF   6F,F
....................    if (mst == 97){  
02ED:  MOVF   6E,W
02EE:  SUBLW  61
02EF:  BTFSS  03.2
02F0:  GOTO   301
02F1:  MOVF   6F,F
02F2:  BTFSS  03.2
02F3:  GOTO   301
....................       msl++;  
02F4:  INCF   75,F
02F5:  BTFSC  03.2
02F6:  INCF   76,F
....................       if (msl>5){  
02F7:  MOVF   76,F
02F8:  BTFSS  03.2
02F9:  GOTO   2FE
02FA:  MOVF   75,W
02FB:  SUBLW  05
02FC:  BTFSC  03.0
02FD:  GOTO   301
....................          lum_flag = 1;  
02FE:  BSF    53.4
....................          msl=0;  
02FF:  CLRF   76
0300:  CLRF   75
....................       }  
....................    }  
....................    if ((mst == 97)&&(afm_flag==0)){  
0301:  MOVF   6E,W
0302:  SUBLW  61
0303:  BTFSS  03.2
0304:  GOTO   31B
0305:  MOVF   6F,F
0306:  BTFSS  03.2
0307:  GOTO   31B
0308:  BTFSC  6D.1
0309:  GOTO   31B
....................       msr++;  
030A:  BSF    03.5
030B:  INCF   22,F
030C:  BTFSC  03.2
030D:  INCF   23,F
....................       if (msr>10){  
030E:  MOVF   23,F
030F:  BTFSS  03.2
0310:  GOTO   315
0311:  MOVF   22,W
0312:  SUBLW  0A
0313:  BTFSC  03.0
0314:  GOTO   31A
....................          afr_flag = 1;  
0315:  BCF    03.5
0316:  BSF    6D.2
....................          msr=0;  
0317:  BSF    03.5
0318:  CLRF   23
0319:  CLRF   22
031A:  BCF    03.5
....................       }  
....................    }  
....................    if (mst == 97){  
031B:  MOVF   6E,W
031C:  SUBLW  61
031D:  BTFSS  03.2
031E:  GOTO   32F
031F:  MOVF   6F,F
0320:  BTFSS  03.2
0321:  GOTO   32F
....................       msb++;  
0322:  INCF   7C,F
0323:  BTFSC  03.2
0324:  INCF   7D,F
....................       if (msb>4){  
0325:  MOVF   7D,F
0326:  BTFSS  03.2
0327:  GOTO   32C
0328:  MOVF   7C,W
0329:  SUBLW  04
032A:  BTFSC  03.0
032B:  GOTO   32F
....................          bat_flag = 1;  
032C:  BSF    53.5
....................          msb=0;  
032D:  CLRF   7D
032E:  CLRF   7C
....................       }  
....................    }  
....................    if (mst == 97){  
032F:  MOVF   6E,W
0330:  SUBLW  61
0331:  BTFSS  03.2
0332:  GOTO   347
0333:  MOVF   6F,F
0334:  BTFSS  03.2
0335:  GOTO   347
....................       msm++;  
0336:  BSF    03.5
0337:  INCF   20,F
0338:  BTFSC  03.2
0339:  INCF   21,F
....................       if (msm>7){  
033A:  MOVF   21,F
033B:  BTFSS  03.2
033C:  GOTO   341
033D:  MOVF   20,W
033E:  SUBLW  07
033F:  BTFSC  03.0
0340:  GOTO   346
....................          mot_flag = 1;  
0341:  BCF    03.5
0342:  BSF    53.6
....................          msm=0;  
0343:  BSF    03.5
0344:  CLRF   21
0345:  CLRF   20
0346:  BCF    03.5
....................       }  
....................    }  
....................    if (afm_flag==0){                   //gel de l'affichage si menu  
0347:  BTFSC  6D.1
0348:  GOTO   35A
....................       msa++;  
0349:  INCF   71,F
034A:  BTFSC  03.2
034B:  INCF   72,F
....................       if (msa>1958){  
034C:  MOVF   72,W
034D:  SUBLW  06
034E:  BTFSC  03.0
034F:  GOTO   35A
0350:  XORLW  FF
0351:  BTFSS  03.2
0352:  GOTO   357
0353:  MOVF   71,W
0354:  SUBLW  A6
0355:  BTFSC  03.0
0356:  GOTO   35A
....................          afg_flag = 1;                 //flag pour valider le defilement de l'affichage  
0357:  BSF    6D.0
....................          msa=0;  
0358:  CLRF   72
0359:  CLRF   71
....................       }  
....................    }  
....................    if ((mst == 97)&&(cor_mode==1)){   //declenchement correction si mode automatique  
035A:  MOVF   6E,W
035B:  SUBLW  61
035C:  BTFSS  03.2
035D:  GOTO   381
035E:  MOVF   6F,F
035F:  BTFSS  03.2
0360:  GOTO   381
0361:  DECFSZ 50,W
0362:  GOTO   381
....................       msc++;  
0363:  INCF   73,F
0364:  BTFSC  03.2
0365:  INCF   74,F
....................       if (msc>(cor_per*600)){  
0366:  BSF    03.6
0367:  CLRF   24
0368:  BCF    03.6
0369:  MOVF   51,W
036A:  BSF    03.6
036B:  MOVWF  23
036C:  MOVLW  02
036D:  MOVWF  26
036E:  MOVLW  58
036F:  MOVWF  25
0370:  BCF    03.6
0371:  GOTO   2D1
0372:  MOVF   79,W
0373:  MOVWF  7A
0374:  MOVF   7A,W
0375:  SUBWF  74,W
0376:  BTFSS  03.0
0377:  GOTO   381
0378:  BTFSS  03.2
0379:  GOTO   37E
037A:  MOVF   73,W
037B:  SUBWF  78,W
037C:  BTFSC  03.0
037D:  GOTO   381
....................          cor_flag = 1;  
037E:  BSF    53.7
....................          msc=0;  
037F:  CLRF   74
0380:  CLRF   73
....................       }  
....................    }  
....................    if (mst == 97){  
0381:  MOVF   6E,W
0382:  SUBLW  61
0383:  BTFSS  03.2
0384:  GOTO   38E
0385:  MOVF   6F,F
0386:  BTFSS  03.2
0387:  GOTO   38E
....................       mst = 0;  
0388:  CLRF   6F
0389:  CLRF   6E
....................       led_off;  
038A:  BSF    03.5
038B:  BCF    06.1
038C:  BCF    03.5
038D:  BCF    06.1
....................       }  
.................... }  
....................  
.................... #include "gest_can.c"                  //gestion du bus can 
....................  /* gestion du bus can */  
....................   
.................... /* identifiants bus can */  
.................... #define i_elum    0x100                   //emission vers le module luminosite  
.................... #define i_rlum    0x101                   //reception depuis le module luminosite  
.................... #define i_eecl    0x200                   //emission vers le module eclairage  
.................... #define i_recl    0x201                   //reception depuis le module eclairage  
.................... #define i_ebat    0x300                   //emission vers le module energie  
.................... #define i_rbat    0x301                   //reception depuis le module energie  
.................... #define i_emot_m  0x400                   //emission vers le module moteur pour demande de donnees  
.................... #define i_rmot    0x401                   //reception depuis le module moteur  
.................... #define i_emot_c  0x402                   //emission vers le module moteur pour commandes elevation  
....................   
.................... /* declaration des fonctions */  
038E:  BCF    0C.1
038F:  BCF    0A.3
0390:  BCF    0A.4
0391:  GOTO   029
.................... void can_receive();                       //reception bus can et recuperation des donnees  
.................... void can_sd_mot();                        //envoi de donnees vers module moteur  
.................... void can_sd_ecl();                        //envoi de donnees vers module eclairage  
.................... void can_sr_lum();                        //envoi request vers module luminosite  
.................... void can_sr_mot();                        //envoi request vers module moteur  
.................... void can_sr_en();                         //envoi request vers module energie  
....................   
.................... /* definitions des fonctions */  
.................... void can_receive(){  
....................    if ( can_kbhit() ){                    //y a t il des donnees dans le buffer ?..  
*
0B9A:  MOVF   78,F
0B9B:  BTFSC  03.2
0B9C:  GOTO   682
....................       if(can_getd(crx_id, &crxbuf[0], crx_len, rxstat)){ //...si oui lecture des donnees  
0B9D:  CLRF   5A
0B9E:  MOVLW  59
0B9F:  MOVWF  59
*
0E12:  MOVF   78,F
0E13:  BTFSC  03.2
0E14:  GOTO   682
....................          led_on;                          // change la LED system  
0E15:  BCF    06.1
0E16:  BCF    03.5
0E17:  BSF    06.1
....................          if (crx_id == i_rlum) {  
0E18:  DECFSZ 55,W
0E19:  GOTO   63E
0E1A:  DECFSZ 56,W
0E1B:  GOTO   63E
0E1C:  MOVF   57,F
0E1D:  BTFSS  03.2
0E1E:  GOTO   63E
0E1F:  MOVF   58,F
0E20:  BTFSS  03.2
0E21:  GOTO   63E
....................             e=crxbuf[0]<<8;  
0E22:  MOVF   59,W
0E23:  MOVWF  2A
0E24:  CLRF   29
....................             e=e+crxbuf[1];                //luminosite est  
0E25:  MOVF   5A,W
0E26:  ADDWF  29,F
0E27:  BTFSC  03.0
0E28:  INCF   2A,F
....................             o=crxbuf[2]<<8;  
0E29:  MOVF   5B,W
0E2A:  MOVWF  2C
0E2B:  CLRF   2B
....................             o=o+crxbuf[3];                //luminosite ouest  
0E2C:  MOVF   5C,W
0E2D:  ADDWF  2B,F
0E2E:  BTFSC  03.0
0E2F:  INCF   2C,F
....................             n=crxbuf[4]<<8;  
0E30:  MOVF   5D,W
0E31:  MOVWF  2E
0E32:  CLRF   2D
....................             n=n+crxbuf[5];                //luminosite nord  
0E33:  MOVF   5E,W
0E34:  ADDWF  2D,F
0E35:  BTFSC  03.0
0E36:  INCF   2E,F
....................             s=crxbuf[6]<<8;  
0E37:  MOVF   5F,W
0E38:  MOVWF  30
0E39:  CLRF   2F
....................             s=s+crxbuf[7];                //luminosite sud  
0E3A:  MOVF   60,W
0E3B:  ADDWF  2F,F
0E3C:  BTFSC  03.0
0E3D:  INCF   30,F
....................          }  
....................          if (crx_id == i_rbat) {  
0E3E:  DECFSZ 55,W
0E3F:  GOTO   658
0E40:  MOVF   56,W
0E41:  SUBLW  03
0E42:  BTFSS  03.2
0E43:  GOTO   658
0E44:  MOVF   57,F
0E45:  BTFSS  03.2
0E46:  GOTO   658
0E47:  MOVF   58,F
0E48:  BTFSS  03.2
0E49:  GOTO   658
....................             en_ve=crxbuf[0];              //tension panneau  
0E4A:  MOVF   59,W
0E4B:  MOVWF  38
....................             en_ie=crxbuf[1];              //courant entree  
0E4C:  MOVF   5A,W
0E4D:  MOVWF  3A
....................             en_is=crxbuf[2];              //courant sortie  
0E4E:  MOVF   5B,W
0E4F:  MOVWF  3B
....................             en_vs=crxbuf[3];              //tension batterie  
0E50:  MOVF   5C,W
0E51:  MOVWF  39
....................             charge=crxbuf[4];             //indicateur de charge  
0E52:  MOVF   5D,W
0E53:  MOVWF  3C
....................             full=crxbuf[5];               //indicateur de charge complete  
0E54:  MOVF   5E,W
0E55:  MOVWF  3D
....................             empty=crxbuf[6];              //indicateur de decharge  
0E56:  MOVF   5F,W
0E57:  MOVWF  3E
....................          }  
....................          if (crx_id == i_rmot) {  
0E58:  DECFSZ 55,W
0E59:  GOTO   681
0E5A:  MOVF   56,W
0E5B:  SUBLW  04
0E5C:  BTFSS  03.2
0E5D:  GOTO   681
0E5E:  MOVF   57,F
0E5F:  BTFSS  03.2
0E60:  GOTO   681
0E61:  MOVF   58,F
0E62:  BTFSS  03.2
0E63:  GOTO   681
....................             mo_ie=crxbuf[0];              //courant moteur elevation  
0E64:  MOVF   59,W
0E65:  MOVWF  41
....................             mo_ia=crxbuf[1];              //courant moteur azimut  
0E66:  MOVF   5A,W
0E67:  MOVWF  42
....................             mo_ovle=crxbuf[2];            //surcharge moteur elevation  
0E68:  MOVF   5B,W
0E69:  MOVWF  43
....................             mo_ovla=crxbuf[3];            //surcharge moteur azimut  
0E6A:  MOVF   5C,W
0E6B:  MOVWF  44
....................             on=crxbuf[4];                 //indicateur de deplacement  
0E6C:  MOVF   5D,W
0E6D:  MOVWF  49
....................             ang_azim=crxbuf[5];           //angle azimut  
0E6E:  CLRF   4D
0E6F:  MOVF   5E,W
0E70:  MOVWF  4C
....................             ang_elev=crxbuf[6];           //angle elevation  
0E71:  MOVF   5F,W
0E72:  MOVWF  4E
....................             butee=crxbuf[7];              //butee  
0E73:  MOVF   60,W
0E74:  MOVWF  4F
....................             if (ang_elev >= 100){  
0E75:  MOVF   4E,W
0E76:  SUBLW  63
0E77:  BTFSC  03.0
0E78:  GOTO   681
....................                ang_azim=ang_azim+270;  
0E79:  MOVLW  0E
0E7A:  ADDWF  4C,F
0E7B:  BTFSC  03.0
0E7C:  INCF   4D,F
0E7D:  MOVLW  01
0E7E:  ADDWF  4D,F
....................                ang_elev=ang_elev-100;  
0E7F:  MOVLW  64
0E80:  SUBWF  4E,F
0E81:  BSF    03.5
....................             }  
....................          }  
....................       }  
....................    }  
.................... }  
....................   
.................... void can_sr_lum(){can_putd(i_elum,0,0,1,TRUE,TRUE);}     //identifiant i_elum, pas de donnees et request  
*
0A06:  BSF    03.5
0A07:  CLRF   5D
0A08:  CLRF   5C
0A09:  MOVLW  01
0A0A:  MOVWF  5B
0A0B:  CLRF   5A
0A0C:  CLRF   5F
0A0D:  CLRF   5E
0A0E:  CLRF   60
0A0F:  MOVWF  61
0A10:  MOVWF  62
0A11:  MOVWF  63
0A12:  BCF    0A.3
0A13:  BCF    03.5
0A14:  CALL   68A
0A15:  BSF    0A.3
0A16:  NOP
.................... void can_sr_mot(){can_putd(i_emot_m,0,0,1,TRUE,TRUE);}   //identifiant i_emot, pas de donnees et request  
*
0A1A:  BSF    03.5
0A1B:  CLRF   5D
0A1C:  CLRF   5C
0A1D:  MOVLW  04
0A1E:  MOVWF  5B
0A1F:  CLRF   5A
0A20:  CLRF   5F
0A21:  CLRF   5E
0A22:  CLRF   60
0A23:  MOVLW  01
0A24:  MOVWF  61
0A25:  MOVWF  62
0A26:  MOVWF  63
0A27:  BCF    0A.3
0A28:  BCF    03.5
0A29:  CALL   68A
0A2A:  BSF    0A.3
0A2B:  NOP
.................... void can_sr_en(){can_putd(i_ebat,0,0,1,TRUE,TRUE);}      //identifiant i_ebat, pas de donnees et request  
*
0A2F:  BSF    03.5
0A30:  CLRF   5D
0A31:  CLRF   5C
0A32:  MOVLW  03
0A33:  MOVWF  5B
0A34:  CLRF   5A
0A35:  CLRF   5F
0A36:  CLRF   5E
0A37:  CLRF   60
0A38:  MOVLW  01
0A39:  MOVWF  61
0A3A:  MOVWF  62
0A3B:  MOVWF  63
0A3C:  BCF    0A.3
0A3D:  BCF    03.5
0A3E:  CALL   68A
0A3F:  BSF    0A.3
0A40:  NOP
....................   
.................... void can_sd_mot(){  
....................    ctxbuf[0]=mot_a_sens;  
*
075A:  MOVF   47,W
075B:  MOVWF  61
....................    ctxbuf[1]=mot_a_dure;  
075C:  MOVF   48,W
075D:  MOVWF  62
....................    ctxbuf[2]=mot_e_sens;  
075E:  MOVF   45,W
075F:  MOVWF  63
....................    ctxbuf[3]=mot_e_dure;  
0760:  MOVF   46,W
0761:  MOVWF  64
....................    ctxbuf[4]=mot_off;  
0762:  MOVF   4B,W
0763:  MOVWF  65
....................    ctxbuf[5]=park;  
0764:  MOVF   4A,W
0765:  MOVWF  66
....................    can_putd(i_emot_c,&ctxbuf[0],6,1,TRUE,FALSE);   //6 octets de buffer  
0766:  BSF    03.5
0767:  CLRF   5D
0768:  CLRF   5C
0769:  MOVLW  04
076A:  MOVWF  5B
076B:  MOVLW  02
076C:  MOVWF  5A
076D:  CLRF   5F
076E:  MOVLW  61
076F:  MOVWF  5E
0770:  MOVLW  06
0771:  MOVWF  60
0772:  MOVLW  01
0773:  MOVWF  61
0774:  MOVWF  62
0775:  CLRF   63
0776:  BCF    03.5
0777:  CALL   68A
.................... }  
0778:  RETLW  00
....................   
.................... void can_sd_ecl(){  
....................    ctxbuf[0]=ec_com;  
*
07DC:  MOVF   3F,W
07DD:  MOVWF  61
....................    ctxbuf[1]=ec_int;  
07DE:  MOVF   40,W
07DF:  MOVWF  62
....................    can_putd(i_eecl, &ctxbuf[0],2,1,TRUE,FALSE);    //2 octets de buffer  
07E0:  BSF    03.5
07E1:  CLRF   5D
07E2:  CLRF   5C
07E3:  MOVLW  02
07E4:  MOVWF  5B
07E5:  CLRF   5A
07E6:  CLRF   5F
07E7:  MOVLW  61
07E8:  MOVWF  5E
07E9:  MOVLW  02
07EA:  MOVWF  60
07EB:  MOVLW  01
07EC:  MOVWF  61
07ED:  MOVWF  62
07EE:  CLRF   63
07EF:  BCF    03.5
07F0:  CALL   68A
.................... }  
07F1:  RETLW  00
....................  
.................... #include "gest_serie.c"                //gestion de la liaison serie 
....................  /* gestion de la liaison serie */  
....................   
.................... /* definition des commandes recues */  
.................... #define c_e       0x45                      //commande eclairage  
.................... #define c_me      0x4a                      //commande moteur elevation  
.................... #define c_ma      0x4b                      //commande moteur azimut  
.................... #define c_c       0x4c                      //commande correction  
.................... #define data      0x52                      //demande data par "R"  
....................   
.................... /* variable pour la liaison serie */  
.................... int1 s_flag;  
.................... int is;  
.................... int buf_ser[50];  
....................   
.................... /* declaration des fonctions */  
.................... void gest_serie();                     //traitement des commandes et actions  
.................... void serie_init();                     //initialisation pour la liaison serie  
.................... void purge_srxbuf();                   //purge du tampon de reception serie  
....................   
.................... /* definitions des fonctions */  
.................... #int_rda                               //reception de la liaison serie en interruption  
.................... void RDA_isr(){  
....................    int c;  
....................    int i;  
....................      
....................    c=getc();  
*
03A0:  GOTO   392
03A1:  MOVF   78,W
03A2:  BSF    03.6
03A3:  MOVWF  28
....................    if (c!=0){                          //si non nul on stocke dans le buffer  
03A4:  MOVF   28,F
03A5:  BTFSC  03.2
03A6:  GOTO   3AE
....................       buf_ser[is]=c;  
03A7:  MOVLW  A4
03A8:  ADDWF  7E,W
03A9:  MOVWF  04
03AA:  BCF    03.7
03AB:  MOVF   28,W
03AC:  MOVWF  00
....................       is++;  
03AD:  INCF   7E,F
....................    }  
....................    if (c==13){                         //si c'est 0D fin de trame et on traite  
03AE:  MOVF   28,W
03AF:  SUBLW  0D
03B0:  BTFSS  03.2
03B1:  GOTO   3C5
....................       for (i=is;i<50;i++) {buf_ser[i]=0;}  
03B2:  MOVF   7E,W
03B3:  MOVWF  29
03B4:  MOVF   29,W
03B5:  SUBLW  31
03B6:  BTFSS  03.0
03B7:  GOTO   3BF
03B8:  MOVLW  A4
03B9:  ADDWF  29,W
03BA:  MOVWF  04
03BB:  BCF    03.7
03BC:  CLRF   00
03BD:  INCF   29,F
03BE:  GOTO   3B4
....................       is=0;  
03BF:  CLRF   7E
....................       s_flag=1;  
03C0:  BCF    03.6
03C1:  BSF    6D.3
....................       nouvelle_trame_serie++;  
03C2:  INCF   54,F
....................         
....................    }  
....................    else if (is==49){is=0;}             //si on arrive en fin de buffer sans avoir OD (pas bien !) on reinitialise  
03C3:  GOTO   3CA
03C4:  BSF    03.6
03C5:  MOVF   7E,W
03C6:  SUBLW  31
03C7:  BTFSC  03.2
03C8:  CLRF   7E
03C9:  BCF    03.6
.................... enable_interrupts(int_rda);         // autorisation interruption liaison serie  
03CA:  BSF    03.5
03CB:  BSF    0C.5
.................... }  
....................   
03CC:  BCF    03.5
03CD:  BCF    0C.5
03CE:  BCF    0A.3
03CF:  BCF    0A.4
03D0:  GOTO   029
.................... void gest_serie(){  
....................    int a;  
....................   
....................    if (s_flag==1){  
*
156D:  BTFSS  6D.3
156E:  GOTO   780
....................       switch (buf_ser[0]) {  
156F:  BSF    03.5
1570:  MOVF   24,W
1571:  XORLW  45
1572:  BCF    03.5
1573:  BTFSC  03.2
1574:  GOTO   582
1575:  XORLW  0F
1576:  BTFSC  03.2
1577:  GOTO   5B0
1578:  XORLW  01
1579:  BTFSC  03.2
157A:  GOTO   5E7
157B:  XORLW  07
157C:  BTFSC  03.2
157D:  GOTO   621
157E:  XORLW  1E
157F:  BTFSC  03.2
1580:  GOTO   674
1581:  GOTO   776
....................       case c_e:{                                               //commande eclairage  
....................             ec_com=(buf_ser[1]-0x30)*10+(buf_ser[2]-0x30);  
1582:  MOVLW  30
1583:  BSF    03.5
1584:  SUBWF  25,W
1585:  MOVWF  5B
1586:  MOVWF  5C
1587:  MOVLW  0A
1588:  MOVWF  5D
1589:  BCF    0A.4
158A:  BSF    0A.3
158B:  BCF    03.5
158C:  CALL   790
158D:  BSF    0A.4
158E:  BCF    0A.3
158F:  MOVF   78,W
1590:  BSF    03.5
1591:  MOVWF  5C
1592:  MOVLW  30
1593:  SUBWF  26,W
1594:  ADDWF  5C,W
1595:  BCF    03.5
1596:  MOVWF  3F
....................             ec_int=(buf_ser[3]-0x30)*10+(buf_ser[4]-0x30);  
1597:  MOVLW  30
1598:  BSF    03.5
1599:  SUBWF  27,W
159A:  MOVWF  5B
159B:  MOVWF  5C
159C:  MOVLW  0A
159D:  MOVWF  5D
159E:  BCF    0A.4
159F:  BSF    0A.3
15A0:  BCF    03.5
15A1:  CALL   790
15A2:  BSF    0A.4
15A3:  BCF    0A.3
15A4:  MOVF   78,W
15A5:  BSF    03.5
15A6:  MOVWF  5C
15A7:  MOVLW  30
15A8:  SUBWF  28,W
15A9:  ADDWF  5C,W
15AA:  BCF    03.5
15AB:  MOVWF  40
....................             can_sd_ecl();  
15AC:  BCF    0A.4
15AD:  CALL   7DC
15AE:  BSF    0A.4
....................             break;  
15AF:  GOTO   776
....................          }  
....................       case c_me:{                                              //commande moteur elevation  
....................             mot_a_sens=0;  
15B0:  CLRF   47
....................             mot_a_dure=0;  
15B1:  CLRF   48
....................             mot_off=0;  
15B2:  CLRF   4B
....................             mot_e_sens=(buf_ser[1]-0x30)*10+(buf_ser[2]-0x30);  
15B3:  MOVLW  30
15B4:  BSF    03.5
15B5:  SUBWF  25,W
15B6:  MOVWF  5B
15B7:  MOVWF  5C
15B8:  MOVLW  0A
15B9:  MOVWF  5D
15BA:  BCF    0A.4
15BB:  BSF    0A.3
15BC:  BCF    03.5
15BD:  CALL   790
15BE:  BSF    0A.4
15BF:  BCF    0A.3
15C0:  MOVF   78,W
15C1:  BSF    03.5
15C2:  MOVWF  5C
15C3:  MOVLW  30
15C4:  SUBWF  26,W
15C5:  ADDWF  5C,W
15C6:  BCF    03.5
15C7:  MOVWF  45
....................             mot_e_dure=(buf_ser[3]-0x30)*10+(buf_ser[4]-0x30);  
15C8:  MOVLW  30
15C9:  BSF    03.5
15CA:  SUBWF  27,W
15CB:  MOVWF  5B
15CC:  MOVWF  5C
15CD:  MOVLW  0A
15CE:  MOVWF  5D
15CF:  BCF    0A.4
15D0:  BSF    0A.3
15D1:  BCF    03.5
15D2:  CALL   790
15D3:  BSF    0A.4
15D4:  BCF    0A.3
15D5:  MOVF   78,W
15D6:  BSF    03.5
15D7:  MOVWF  5C
15D8:  MOVLW  30
15D9:  SUBWF  28,W
15DA:  ADDWF  5C,W
15DB:  BCF    03.5
15DC:  MOVWF  46
....................             park=(buf_ser[5]-0x30);  
15DD:  MOVLW  30
15DE:  BSF    03.5
15DF:  SUBWF  29,W
15E0:  BCF    03.5
15E1:  MOVWF  4A
....................             can_sd_mot();  
15E2:  BCF    0A.4
15E3:  CALL   75A
15E4:  BSF    0A.4
....................             park=0;  
15E5:  CLRF   4A
....................             break;  
15E6:  GOTO   776
....................          }  
....................       case c_ma:{                                              //commande moteur azimut  
....................             mot_e_sens=0;  
15E7:  CLRF   45
....................             mot_e_dure=0;  
15E8:  CLRF   46
....................             mot_off=0;  
15E9:  CLRF   4B
....................             mot_a_sens=(buf_ser[1]-0x30)*10+(buf_ser[2]-0x30);  
15EA:  MOVLW  30
15EB:  BSF    03.5
15EC:  SUBWF  25,W
15ED:  MOVWF  5B
15EE:  MOVWF  5C
15EF:  MOVLW  0A
15F0:  MOVWF  5D
15F1:  BCF    0A.4
15F2:  BSF    0A.3
15F3:  BCF    03.5
15F4:  CALL   790
15F5:  BSF    0A.4
15F6:  BCF    0A.3
15F7:  MOVF   78,W
15F8:  BSF    03.5
15F9:  MOVWF  5C
15FA:  MOVLW  30
15FB:  SUBWF  26,W
15FC:  ADDWF  5C,W
15FD:  BCF    03.5
15FE:  MOVWF  47
....................             mot_a_dure=(buf_ser[3]-0x30)*10+(buf_ser[4]-0x30);  
15FF:  MOVLW  30
1600:  BSF    03.5
1601:  SUBWF  27,W
1602:  MOVWF  5B
1603:  MOVWF  5C
1604:  MOVLW  0A
1605:  MOVWF  5D
1606:  BCF    0A.4
1607:  BSF    0A.3
1608:  BCF    03.5
1609:  CALL   790
160A:  BSF    0A.4
160B:  BCF    0A.3
160C:  MOVF   78,W
160D:  BSF    03.5
160E:  MOVWF  5C
160F:  MOVLW  30
1610:  SUBWF  28,W
1611:  ADDWF  5C,W
1612:  BCF    03.5
1613:  MOVWF  48
....................             park=(buf_ser[5]-0x30);  
1614:  MOVLW  30
1615:  BSF    03.5
1616:  SUBWF  29,W
1617:  BCF    03.5
1618:  MOVWF  4A
....................             can_sd_mot();  
1619:  BCF    0A.4
161A:  CALL   75A
161B:  BSF    0A.4
....................             if (park==1){cor_flag=0;}  
161C:  DECFSZ 4A,W
161D:  GOTO   61F
161E:  BCF    53.7
....................             park=0;  
161F:  CLRF   4A
....................             break;  
1620:  GOTO   776
....................          }  
....................       case c_c:{                                               //commande correction  
....................             a=(buf_ser[1]-0x30)*10+(buf_ser[2]-0x30);  
1621:  MOVLW  30
1622:  BSF    03.5
1623:  SUBWF  25,W
1624:  MOVWF  5B
1625:  MOVWF  5C
1626:  MOVLW  0A
1627:  MOVWF  5D
1628:  BCF    0A.4
1629:  BSF    0A.3
162A:  BCF    03.5
162B:  CALL   790
162C:  BSF    0A.4
162D:  BCF    0A.3
162E:  MOVF   78,W
162F:  BSF    03.5
1630:  MOVWF  5C
1631:  MOVLW  30
1632:  SUBWF  26,W
1633:  ADDWF  5C,W
1634:  MOVWF  59
....................             cor_seuil=(buf_ser[3]-0x30)*10+(buf_ser[4]-0x30);  
1635:  MOVLW  30
1636:  SUBWF  27,W
1637:  MOVWF  5B
1638:  MOVWF  5C
1639:  MOVLW  0A
163A:  MOVWF  5D
163B:  BCF    0A.4
163C:  BSF    0A.3
163D:  BCF    03.5
163E:  CALL   790
163F:  BSF    0A.4
1640:  BCF    0A.3
1641:  MOVF   78,W
1642:  BSF    03.5
1643:  MOVWF  5C
1644:  MOVLW  30
1645:  SUBWF  28,W
1646:  ADDWF  5C,W
1647:  BCF    03.5
1648:  MOVWF  52
....................             cor_per=(buf_ser[5]-0x30)*10+(buf_ser[6]-0x30);  
1649:  MOVLW  30
164A:  BSF    03.5
164B:  SUBWF  29,W
164C:  MOVWF  5B
164D:  MOVWF  5C
164E:  MOVLW  0A
164F:  MOVWF  5D
1650:  BCF    0A.4
1651:  BSF    0A.3
1652:  BCF    03.5
1653:  CALL   790
1654:  BSF    0A.4
1655:  BCF    0A.3
1656:  MOVF   78,W
1657:  BSF    03.5
1658:  MOVWF  5C
1659:  MOVLW  30
165A:  SUBWF  2A,W
165B:  ADDWF  5C,W
165C:  BCF    03.5
165D:  MOVWF  51
....................             if (a == 0){cor_mode = 0;}                         //pas de correction automatique  
165E:  BSF    03.5
165F:  MOVF   59,F
1660:  BTFSS  03.2
1661:  GOTO   665
1662:  BCF    03.5
1663:  CLRF   50
1664:  BSF    03.5
....................             if (a == 1){cor_flag = 1;}                         //juste une correction manuelle  
1665:  DECFSZ 59,W
1666:  GOTO   66A
1667:  BCF    03.5
1668:  BSF    53.7
1669:  BSF    03.5
....................             if (a == 2){cor_mode = 1;}                         //correction automatique activee  
166A:  MOVF   59,W
166B:  SUBLW  02
166C:  BTFSS  03.2
166D:  GOTO   672
166E:  MOVLW  01
166F:  BCF    03.5
1670:  MOVWF  50
1671:  BSF    03.5
....................             break;  
1672:  BCF    03.5
1673:  GOTO   776
....................          }  
....................       case data:{  
....................             printf("%X",0xfa);  
1674:  MOVLW  FA
1675:  BSF    03.5
1676:  MOVWF  5A
1677:  MOVLW  37
1678:  MOVWF  5B
1679:  BCF    0A.4
167A:  BSF    0A.3
167B:  BCF    03.5
167C:  CALL   7B7
167D:  BSF    0A.4
167E:  BCF    0A.3
....................             printf("%3U",lum_est);                             //data luminosite  
167F:  MOVF   31,W
1680:  BSF    03.5
1681:  MOVWF  5A
1682:  MOVLW  10
1683:  MOVWF  5B
1684:  BCF    03.5
1685:  CALL   4AF
....................             printf("%3U",lum_ouest);  
1686:  MOVF   32,W
1687:  BSF    03.5
1688:  MOVWF  5A
1689:  MOVLW  10
168A:  MOVWF  5B
168B:  BCF    03.5
168C:  CALL   4AF
....................             printf("%3U",lum_nord);  
168D:  MOVF   33,W
168E:  BSF    03.5
168F:  MOVWF  5A
1690:  MOVLW  10
1691:  MOVWF  5B
1692:  BCF    03.5
1693:  CALL   4AF
....................             printf("%3U",lum_sud);  
1694:  MOVF   34,W
1695:  BSF    03.5
1696:  MOVWF  5A
1697:  MOVLW  10
1698:  MOVWF  5B
1699:  BCF    03.5
169A:  CALL   4AF
....................             printf("%3U",lum_m);  
169B:  MOVF   35,W
169C:  BSF    03.5
169D:  MOVWF  5A
169E:  MOVLW  10
169F:  MOVWF  5B
16A0:  BCF    03.5
16A1:  CALL   4AF
....................             printf("%3U",lum_eca);  
16A2:  MOVF   36,W
16A3:  BSF    03.5
16A4:  MOVWF  5A
16A5:  MOVLW  10
16A6:  MOVWF  5B
16A7:  BCF    03.5
16A8:  CALL   4AF
....................             printf("%3U",lum_ece);  
16A9:  MOVF   37,W
16AA:  BSF    03.5
16AB:  MOVWF  5A
16AC:  MOVLW  10
16AD:  MOVWF  5B
16AE:  BCF    03.5
16AF:  CALL   4AF
....................             printf("%X",0);                                    //reserve  
16B0:  BSF    03.5
16B1:  CLRF   5A
16B2:  MOVLW  37
16B3:  MOVWF  5B
16B4:  BCF    0A.4
16B5:  BSF    0A.3
16B6:  BCF    03.5
16B7:  CALL   7B7
16B8:  BSF    0A.4
16B9:  BCF    0A.3
....................             printf("%3U",en_ve);                               //data energie  
16BA:  MOVF   38,W
16BB:  BSF    03.5
16BC:  MOVWF  5A
16BD:  MOVLW  10
16BE:  MOVWF  5B
16BF:  BCF    03.5
16C0:  CALL   4AF
....................             printf("%3U",en_vs);  
16C1:  MOVF   39,W
16C2:  BSF    03.5
16C3:  MOVWF  5A
16C4:  MOVLW  10
16C5:  MOVWF  5B
16C6:  BCF    03.5
16C7:  CALL   4AF
....................             printf("%3U",en_ie);  
16C8:  MOVF   3A,W
16C9:  BSF    03.5
16CA:  MOVWF  5A
16CB:  MOVLW  10
16CC:  MOVWF  5B
16CD:  BCF    03.5
16CE:  CALL   4AF
....................             printf("%3U",en_is);  
16CF:  MOVF   3B,W
16D0:  BSF    03.5
16D1:  MOVWF  5A
16D2:  MOVLW  10
16D3:  MOVWF  5B
16D4:  BCF    03.5
16D5:  CALL   4AF
....................             printf("%X",charge);  
16D6:  MOVF   3C,W
16D7:  BSF    03.5
16D8:  MOVWF  5A
16D9:  MOVLW  37
16DA:  MOVWF  5B
16DB:  BCF    0A.4
16DC:  BSF    0A.3
16DD:  BCF    03.5
16DE:  CALL   7B7
16DF:  BSF    0A.4
16E0:  BCF    0A.3
....................             printf("%X",full);  
16E1:  MOVF   3D,W
16E2:  BSF    03.5
16E3:  MOVWF  5A
16E4:  MOVLW  37
16E5:  MOVWF  5B
16E6:  BCF    0A.4
16E7:  BSF    0A.3
16E8:  BCF    03.5
16E9:  CALL   7B7
16EA:  BSF    0A.4
16EB:  BCF    0A.3
....................             printf("%X",empty);  
16EC:  MOVF   3E,W
16ED:  BSF    03.5
16EE:  MOVWF  5A
16EF:  MOVLW  37
16F0:  MOVWF  5B
16F1:  BCF    0A.4
16F2:  BSF    0A.3
16F3:  BCF    03.5
16F4:  CALL   7B7
16F5:  BSF    0A.4
16F6:  BCF    0A.3
....................             printf("%3U",ec_com);                              //data eclairage  
16F7:  MOVF   3F,W
16F8:  BSF    03.5
16F9:  MOVWF  5A
16FA:  MOVLW  10
16FB:  MOVWF  5B
16FC:  BCF    03.5
16FD:  CALL   4AF
....................             printf("%3U",ec_int);  
16FE:  MOVF   40,W
16FF:  BSF    03.5
1700:  MOVWF  5A
1701:  MOVLW  10
1702:  MOVWF  5B
1703:  BCF    03.5
1704:  CALL   4AF
....................             printf("%3U",mo_ie);                               //data moteur  
1705:  MOVF   41,W
1706:  BSF    03.5
1707:  MOVWF  5A
1708:  MOVLW  10
1709:  MOVWF  5B
170A:  BCF    03.5
170B:  CALL   4AF
....................             printf("%3U",mo_ia);  
170C:  MOVF   42,W
170D:  BSF    03.5
170E:  MOVWF  5A
170F:  MOVLW  10
1710:  MOVWF  5B
1711:  BCF    03.5
1712:  CALL   4AF
....................             printf("%X",mo_ovle);  
1713:  MOVF   43,W
1714:  BSF    03.5
1715:  MOVWF  5A
1716:  MOVLW  37
1717:  MOVWF  5B
1718:  BCF    0A.4
1719:  BSF    0A.3
171A:  BCF    03.5
171B:  CALL   7B7
171C:  BSF    0A.4
171D:  BCF    0A.3
....................             printf("%X",mo_ovla);  
171E:  MOVF   44,W
171F:  BSF    03.5
1720:  MOVWF  5A
1721:  MOVLW  37
1722:  MOVWF  5B
1723:  BCF    0A.4
1724:  BSF    0A.3
1725:  BCF    03.5
1726:  CALL   7B7
1727:  BSF    0A.4
1728:  BCF    0A.3
....................             printf("%X",on);  
1729:  MOVF   49,W
172A:  BSF    03.5
172B:  MOVWF  5A
172C:  MOVLW  37
172D:  MOVWF  5B
172E:  BCF    0A.4
172F:  BSF    0A.3
1730:  BCF    03.5
1731:  CALL   7B7
1732:  BSF    0A.4
1733:  BCF    0A.3
....................             printf("%3LU",ang_azim);  
1734:  MOVLW  02
1735:  MOVWF  04
1736:  MOVF   4D,W
1737:  BSF    03.5
1738:  MOVWF  5B
1739:  BCF    03.5
173A:  MOVF   4C,W
173B:  BSF    03.5
173C:  MOVWF  5A
173D:  BCF    03.5
173E:  GOTO   4F9
....................             printf("%3U",ang_elev);  
173F:  MOVF   4E,W
1740:  BSF    03.5
1741:  MOVWF  5A
1742:  MOVLW  10
1743:  MOVWF  5B
1744:  BCF    03.5
1745:  CALL   4AF
....................             printf("%X",butee);  
1746:  MOVF   4F,W
1747:  BSF    03.5
1748:  MOVWF  5A
1749:  MOVLW  37
174A:  MOVWF  5B
174B:  BCF    0A.4
174C:  BSF    0A.3
174D:  BCF    03.5
174E:  CALL   7B7
174F:  BSF    0A.4
1750:  BCF    0A.3
....................             printf("%X",cor_mode);                             //data correction  
1751:  MOVF   50,W
1752:  BSF    03.5
1753:  MOVWF  5A
1754:  MOVLW  37
1755:  MOVWF  5B
1756:  BCF    0A.4
1757:  BSF    0A.3
1758:  BCF    03.5
1759:  CALL   7B7
175A:  BSF    0A.4
175B:  BCF    0A.3
....................             printf("%3U",cor_per);  
175C:  MOVF   51,W
175D:  BSF    03.5
175E:  MOVWF  5A
175F:  MOVLW  10
1760:  MOVWF  5B
1761:  BCF    03.5
1762:  CALL   4AF
....................             printf("%3U",cor_seuil);  
1763:  MOVF   52,W
1764:  BSF    03.5
1765:  MOVWF  5A
1766:  MOVLW  10
1767:  MOVWF  5B
1768:  BCF    03.5
1769:  CALL   4AF
....................             printf("%X",13);  
176A:  MOVLW  0D
176B:  BSF    03.5
176C:  MOVWF  5A
176D:  MOVLW  37
176E:  MOVWF  5B
176F:  BCF    0A.4
1770:  BSF    0A.3
1771:  BCF    03.5
1772:  CALL   7B7
1773:  BSF    0A.4
1774:  BCF    0A.3
....................             break;  
1775:  GOTO   776
....................          }  
....................       }  
....................       purge_srxbuf();  
1776:  BCF    0A.4
1777:  CALL   4E6
1778:  BSF    0A.4
....................       s_flag=0;  
1779:  BCF    6D.3
....................       nouvelle_trame_serie--;  
177A:  DECFSZ 54,F
....................       if (nouvelle_trame_serie==0)  
177B:  GOTO   780
....................          {  
....................          purge_srxbuf();  
177C:  BCF    0A.4
177D:  CALL   4E6
177E:  BSF    0A.4
....................          s_flag=0;  
177F:  BCF    6D.3
....................          }  
....................    }  
.................... }  
1780:  BSF    0A.3
1781:  BSF    0A.4
1782:  GOTO   2A5 (RETURN)
....................   
.................... void serie_init(){  
....................    is=0;  
*
08B4:  CLRF   7E
....................    s_flag=0;  
08B5:  BCF    03.5
08B6:  BCF    6D.3
....................    purge_srxbuf();  
08B7:  BCF    0A.3
08B8:  CALL   4E6
08B9:  BSF    0A.3
....................    enable_interrupts(int_rda);         // autorisation interruption liaison serie  
08BA:  BSF    03.5
08BB:  BSF    0C.5
.................... }  
....................   
.................... void purge_srxbuf(){  
....................    int i;  
....................    for (i=0;i<50;i++){buf_ser[i]=0;}  
*
04E6:  BSF    03.5
04E7:  CLRF   5A
04E8:  MOVF   5A,W
04E9:  SUBLW  31
04EA:  BTFSS  03.0
04EB:  GOTO   4F3
04EC:  MOVLW  A4
04ED:  ADDWF  5A,W
04EE:  MOVWF  04
04EF:  BCF    03.7
04F0:  CLRF   00
04F1:  INCF   5A,F
04F2:  GOTO   4E8
.................... }  
04F3:  BCF    03.5
04F4:  RETLW  00
....................  
.................... #include "gest_affi.c"                 //gestion affichages sur lcd 
....................  /* gestion des affichages sur LCD */  
....................   
.................... int code_affi;  
....................   
.................... /* indicateur pour affichage cyclique sur LCD */  
.................... int1 afl_flag;                         //affichage luminosite  
.................... int1 afb_flag;                         //affichage batterie  
.................... int1 afe_flag;                         //affichage eclairage  
....................   
.................... /* definition des fonctions */  
.................... void affi_init();                      //initialisation de l'affichage LCD  
.................... void affi_lum();                       //affichage des informations de luminosite  
.................... void affi_bat();                       //affichage des informations d'energie  
.................... void affi_ecl();                       //affichage des informations d'eclairage  
.................... void affi_auto();                      //affichage mode automatique  
.................... void affi_manu();                      //affichage mode manuel  
.................... void affi_normal();                    //affichage mode manuel  
.................... void affi_defilant();                  //affichage mode manuel  
.................... void affi_mod();                       //affichage mode manuel  
.................... void affi_mat();                       //affichage mode manuel  
.................... void affi_cora();                      //affichage correction azimut  
.................... void affi_core();                      //affichage correction elevation  
.................... void affi_park();                      //affichage parking  
....................   
....................   
.................... /* definitions des fonctions */  
....................   
.................... void affi_init(){  
....................    disp_lcd = TRUE;                    // validation affichage LCD  
*
0800:  BSF    53.2
....................    lcd_init();                         // initialisation LCD  
....................    afl_flag=1;                         // indicateur pour affichage luminosite a 1  
*
084E:  BCF    03.5
084F:  BSF    6D.4
....................    affi_mat();                         // message d'accueil  
*
08B3:  NOP
.................... }  
....................   
.................... void gest_affi(){  
....................    if(afr_flag==1){  
*
136D:  BTFSS  6D.2
136E:  GOTO   4A2
....................       switch (code_affi) {  
136F:  BSF    03.5
1370:  MOVF   56,W
1371:  ADDLW  FA
1372:  BTFSC  03.0
1373:  GOTO   4A0
1374:  ADDLW  06
1375:  BCF    03.5
1376:  GOTO   4A5
....................          case 00:  affi_normal();  
....................          break;  
*
146A:  BSF    03.5
146B:  GOTO   4A0
....................          case 01:  affi_defilant();  
....................          break;  
*
1484:  BSF    03.5
1485:  GOTO   4A0
....................          case 02:  affi_bat();  
1486:  CALL   2BD
....................          break;  
1487:  BSF    03.5
1488:  GOTO   4A0
....................          case 03:  affi_lum();  
1489:  CALL   20D
....................          break;  
148A:  BSF    03.5
148B:  GOTO   4A0
....................          case 04:  affi_ecl();  
148C:  BCF    0A.4
148D:  BSF    0A.3
148E:  CALL   6E2
148F:  BSF    0A.4
1490:  BCF    0A.3
....................          break;  
1491:  BSF    03.5
1492:  GOTO   4A0
....................          case 05:  affi_mod();  
....................          break;  
*
149D:  BSF    03.5
149E:  GOTO   4A0
149F:  BSF    03.5
....................       }  
....................       afr_flag=0;  
14A0:  BCF    03.5
14A1:  BCF    6D.2
....................    }  
.................... }  
14A2:  BSF    0A.3
14A3:  BSF    0A.4
14A4:  GOTO   2A2 (RETURN)
....................   
.................... void affi_normal(){  
....................    printf(displays, "\fBAT : U%3u ",en_vs);  
*
1377:  BSF    03.5
1378:  CLRF   59
1379:  MOVF   59,W
137A:  BCF    0A.4
137B:  BCF    03.5
137C:  CALL   04D
137D:  BSF    0A.4
137E:  BSF    03.5
137F:  INCF   59,F
1380:  MOVWF  77
1381:  MOVWF  5D
1382:  BCF    0A.4
1383:  BCF    03.5
1384:  CALL   491
1385:  BSF    0A.4
1386:  MOVLW  08
1387:  BSF    03.5
1388:  SUBWF  59,W
1389:  BTFSS  03.2
138A:  GOTO   379
138B:  BCF    03.5
138C:  MOVF   39,W
138D:  BSF    03.5
138E:  MOVWF  5B
138F:  MOVLW  10
1390:  MOVWF  5C
1391:  BCF    0A.4
1392:  BSF    0A.3
1393:  BCF    03.5
1394:  CALL   6A0
1395:  BSF    0A.4
1396:  BCF    0A.3
1397:  MOVLW  20
1398:  BSF    03.5
1399:  MOVWF  5D
139A:  BCF    0A.4
139B:  BCF    03.5
139C:  CALL   491
139D:  BSF    0A.4
....................    printf(displays, "I%3u ",en_is);  
139E:  MOVLW  49
139F:  BSF    03.5
13A0:  MOVWF  5D
13A1:  BCF    0A.4
13A2:  BCF    03.5
13A3:  CALL   491
13A4:  BSF    0A.4
13A5:  MOVF   3B,W
13A6:  BSF    03.5
13A7:  MOVWF  5B
13A8:  MOVLW  10
13A9:  MOVWF  5C
13AA:  BCF    0A.4
13AB:  BSF    0A.3
13AC:  BCF    03.5
13AD:  CALL   6A0
13AE:  BSF    0A.4
13AF:  BCF    0A.3
13B0:  MOVLW  20
13B1:  BSF    03.5
13B2:  MOVWF  5D
13B3:  BCF    0A.4
13B4:  BCF    03.5
13B5:  CALL   491
13B6:  BSF    0A.4
....................    printf(displays, "\nECL : ");  
13B7:  BSF    03.5
13B8:  CLRF   59
13B9:  MOVF   59,W
13BA:  BCF    0A.4
13BB:  BCF    03.5
13BC:  CALL   05E
13BD:  BSF    0A.4
13BE:  BSF    03.5
13BF:  INCF   59,F
13C0:  MOVWF  77
13C1:  MOVWF  5D
13C2:  BCF    0A.4
13C3:  BCF    03.5
13C4:  CALL   491
13C5:  BSF    0A.4
13C6:  MOVLW  07
13C7:  BSF    03.5
13C8:  SUBWF  59,W
13C9:  BTFSS  03.2
13CA:  GOTO   3B9
....................    if(ec_com==0){printf(displays, "all off");}  
13CB:  BCF    03.5
13CC:  MOVF   3F,F
13CD:  BTFSS  03.2
13CE:  GOTO   3E4
13CF:  BSF    03.5
13D0:  CLRF   59
13D1:  MOVF   59,W
13D2:  BCF    0A.4
13D3:  BCF    03.5
13D4:  CALL   06A
13D5:  BSF    0A.4
13D6:  BSF    03.5
13D7:  INCF   59,F
13D8:  MOVWF  77
13D9:  MOVWF  5D
13DA:  BCF    0A.4
13DB:  BCF    03.5
13DC:  CALL   491
13DD:  BSF    0A.4
13DE:  MOVLW  07
13DF:  BSF    03.5
13E0:  SUBWF  59,W
13E1:  BTFSS  03.2
13E2:  GOTO   3D1
13E3:  BCF    03.5
....................    if(ec_com==1){printf(displays, "niveau %3u",ec_int);}  
13E4:  DECFSZ 3F,W
13E5:  GOTO   406
13E6:  BSF    03.5
13E7:  CLRF   59
13E8:  MOVF   59,W
13E9:  BCF    0A.4
13EA:  BCF    03.5
13EB:  CALL   076
13EC:  BSF    0A.4
13ED:  BSF    03.5
13EE:  INCF   59,F
13EF:  MOVWF  77
13F0:  MOVWF  5D
13F1:  BCF    0A.4
13F2:  BCF    03.5
13F3:  CALL   491
13F4:  BSF    0A.4
13F5:  MOVLW  07
13F6:  BSF    03.5
13F7:  SUBWF  59,W
13F8:  BTFSS  03.2
13F9:  GOTO   3E8
13FA:  BCF    03.5
13FB:  MOVF   40,W
13FC:  BSF    03.5
13FD:  MOVWF  5B
13FE:  MOVLW  10
13FF:  MOVWF  5C
1400:  BCF    0A.4
1401:  BSF    0A.3
1402:  BCF    03.5
1403:  CALL   6A0
1404:  BSF    0A.4
1405:  BCF    0A.3
....................    if(ec_com==2){printf(displays, "bloc 1 on");}  
1406:  MOVF   3F,W
1407:  SUBLW  02
1408:  BTFSS  03.2
1409:  GOTO   41F
140A:  BSF    03.5
140B:  CLRF   59
140C:  MOVF   59,W
140D:  BCF    0A.4
140E:  BCF    03.5
140F:  CALL   085
1410:  BSF    0A.4
1411:  BSF    03.5
1412:  INCF   59,F
1413:  MOVWF  77
1414:  MOVWF  5D
1415:  BCF    0A.4
1416:  BCF    03.5
1417:  CALL   491
1418:  BSF    0A.4
1419:  MOVLW  09
141A:  BSF    03.5
141B:  SUBWF  59,W
141C:  BTFSS  03.2
141D:  GOTO   40C
141E:  BCF    03.5
....................    if(ec_com==3){printf(displays, "bloc 2 on");}  
141F:  MOVF   3F,W
1420:  SUBLW  03
1421:  BTFSS  03.2
1422:  GOTO   438
1423:  BSF    03.5
1424:  CLRF   59
1425:  MOVF   59,W
1426:  BCF    0A.4
1427:  BCF    03.5
1428:  CALL   093
1429:  BSF    0A.4
142A:  BSF    03.5
142B:  INCF   59,F
142C:  MOVWF  77
142D:  MOVWF  5D
142E:  BCF    0A.4
142F:  BCF    03.5
1430:  CALL   491
1431:  BSF    0A.4
1432:  MOVLW  09
1433:  BSF    03.5
1434:  SUBWF  59,W
1435:  BTFSS  03.2
1436:  GOTO   425
1437:  BCF    03.5
....................    if(ec_com==4){printf(displays, "bloc 3 on");}  
1438:  MOVF   3F,W
1439:  SUBLW  04
143A:  BTFSS  03.2
143B:  GOTO   451
143C:  BSF    03.5
143D:  CLRF   59
143E:  MOVF   59,W
143F:  BCF    0A.4
1440:  BCF    03.5
1441:  CALL   0A1
1442:  BSF    0A.4
1443:  BSF    03.5
1444:  INCF   59,F
1445:  MOVWF  77
1446:  MOVWF  5D
1447:  BCF    0A.4
1448:  BCF    03.5
1449:  CALL   491
144A:  BSF    0A.4
144B:  MOVLW  09
144C:  BSF    03.5
144D:  SUBWF  59,W
144E:  BTFSS  03.2
144F:  GOTO   43E
1450:  BCF    03.5
....................    if(ec_com==5){printf(displays, "bloc 4 on");}  
1451:  MOVF   3F,W
1452:  SUBLW  05
1453:  BTFSS  03.2
1454:  GOTO   46A
1455:  BSF    03.5
1456:  CLRF   59
1457:  MOVF   59,W
1458:  BCF    0A.4
1459:  BCF    03.5
145A:  CALL   0AF
145B:  BSF    0A.4
145C:  BSF    03.5
145D:  INCF   59,F
145E:  MOVWF  77
145F:  MOVWF  5D
1460:  BCF    0A.4
1461:  BCF    03.5
1462:  CALL   491
1463:  BSF    0A.4
1464:  MOVLW  09
1465:  BSF    03.5
1466:  SUBWF  59,W
1467:  BTFSS  03.2
1468:  GOTO   457
1469:  BCF    03.5
.................... }  
....................   
.................... void affi_defilant(){  
....................    if (afg_flag==1){                            //si demande de modification par le timer  
*
146C:  BTFSS  6D.0
146D:  GOTO   484
....................       if (afl_flag==1){                         //luminosite  
146E:  BTFSS  6D.4
146F:  GOTO   474
....................          affi_lum();  
1470:  CALL   20D
....................          afl_flag=0;  
1471:  BCF    6D.4
....................          afb_flag=1;  
1472:  BSF    6D.5
....................       }  
....................       else if (afb_flag==1){                    //energie  
1473:  GOTO   483
1474:  BTFSS  6D.5
1475:  GOTO   47A
....................          affi_bat();  
1476:  CALL   2BD
....................          afb_flag=0;  
1477:  BCF    6D.5
....................          afe_flag=1;  
1478:  BSF    6D.6
....................       }  
....................       else if (afe_flag==1){                    //eclairage  
1479:  GOTO   483
147A:  BTFSS  6D.6
147B:  GOTO   483
....................          affi_ecl();  
147C:  BCF    0A.4
147D:  BSF    0A.3
147E:  CALL   6E2
147F:  BSF    0A.4
1480:  BCF    0A.3
....................          afe_flag=0;  
1481:  BCF    6D.6
....................          afl_flag=1;  
1482:  BSF    6D.4
....................       }  
....................       afg_flag=0;  
1483:  BCF    6D.0
....................    }  
.................... }  
....................   
.................... void affi_bat(){  
....................    printf(displays, "\fB%3u",en_vs);  
*
12BD:  MOVLW  0C
12BE:  BSF    03.5
12BF:  MOVWF  5D
12C0:  BCF    0A.4
12C1:  BCF    03.5
12C2:  CALL   491
12C3:  BSF    0A.4
12C4:  MOVLW  42
12C5:  BSF    03.5
12C6:  MOVWF  5D
12C7:  BCF    0A.4
12C8:  BCF    03.5
12C9:  CALL   491
12CA:  BSF    0A.4
12CB:  MOVF   39,W
12CC:  BSF    03.5
12CD:  MOVWF  5B
12CE:  MOVLW  10
12CF:  MOVWF  5C
12D0:  BCF    0A.4
12D1:  BSF    0A.3
12D2:  BCF    03.5
12D3:  CALL   6A0
12D4:  BSF    0A.4
12D5:  BCF    0A.3
....................    printf(displays, "S%3u",en_is);  
12D6:  MOVLW  53
12D7:  BSF    03.5
12D8:  MOVWF  5D
12D9:  BCF    0A.4
12DA:  BCF    03.5
12DB:  CALL   491
12DC:  BSF    0A.4
12DD:  MOVF   3B,W
12DE:  BSF    03.5
12DF:  MOVWF  5B
12E0:  MOVLW  10
12E1:  MOVWF  5C
12E2:  BCF    0A.4
12E3:  BSF    0A.3
12E4:  BCF    03.5
12E5:  CALL   6A0
12E6:  BSF    0A.4
12E7:  BCF    0A.3
....................    printf(displays, "P%3u",en_ve);  
12E8:  MOVLW  50
12E9:  BSF    03.5
12EA:  MOVWF  5D
12EB:  BCF    0A.4
12EC:  BCF    03.5
12ED:  CALL   491
12EE:  BSF    0A.4
12EF:  MOVF   38,W
12F0:  BSF    03.5
12F1:  MOVWF  5B
12F2:  MOVLW  10
12F3:  MOVWF  5C
12F4:  BCF    0A.4
12F5:  BSF    0A.3
12F6:  BCF    03.5
12F7:  CALL   6A0
12F8:  BSF    0A.4
12F9:  BCF    0A.3
....................    printf(displays, "E%3u",en_ie);  
12FA:  MOVLW  45
12FB:  BSF    03.5
12FC:  MOVWF  5D
12FD:  BCF    0A.4
12FE:  BCF    03.5
12FF:  CALL   491
1300:  BSF    0A.4
1301:  MOVF   3A,W
1302:  BSF    03.5
1303:  MOVWF  5B
1304:  MOVLW  10
1305:  MOVWF  5C
1306:  BCF    0A.4
1307:  BSF    0A.3
1308:  BCF    03.5
1309:  CALL   6A0
130A:  BSF    0A.4
130B:  BCF    0A.3
....................    printf(displays, "\nCh: %u",charge);  
130C:  BSF    03.5
130D:  CLRF   59
130E:  MOVF   59,W
130F:  BCF    0A.4
1310:  BCF    03.5
1311:  CALL   0BD
1312:  BSF    0A.4
1313:  BSF    03.5
1314:  INCF   59,F
1315:  MOVWF  77
1316:  MOVWF  5D
1317:  BCF    0A.4
1318:  BCF    03.5
1319:  CALL   491
131A:  BSF    0A.4
131B:  MOVLW  05
131C:  BSF    03.5
131D:  SUBWF  59,W
131E:  BTFSS  03.2
131F:  GOTO   30E
1320:  BCF    03.5
1321:  MOVF   3C,W
1322:  BSF    03.5
1323:  MOVWF  5B
1324:  MOVLW  18
1325:  MOVWF  5C
1326:  BCF    0A.4
1327:  BSF    0A.3
1328:  BCF    03.5
1329:  CALL   6A0
132A:  BSF    0A.4
132B:  BCF    0A.3
....................    printf(displays, "Fu: %u",full);  
132C:  BSF    03.5
132D:  CLRF   59
132E:  MOVF   59,W
132F:  BCF    0A.4
1330:  BCF    03.5
1331:  CALL   0C9
1332:  BSF    0A.4
1333:  BSF    03.5
1334:  INCF   59,F
1335:  MOVWF  77
1336:  MOVWF  5D
1337:  BCF    0A.4
1338:  BCF    03.5
1339:  CALL   491
133A:  BSF    0A.4
133B:  MOVLW  04
133C:  BSF    03.5
133D:  SUBWF  59,W
133E:  BTFSS  03.2
133F:  GOTO   32E
1340:  BCF    03.5
1341:  MOVF   3D,W
1342:  BSF    03.5
1343:  MOVWF  5B
1344:  MOVLW  18
1345:  MOVWF  5C
1346:  BCF    0A.4
1347:  BSF    0A.3
1348:  BCF    03.5
1349:  CALL   6A0
134A:  BSF    0A.4
134B:  BCF    0A.3
....................    printf(displays, "Em: %u",empty);  
134C:  BSF    03.5
134D:  CLRF   59
134E:  MOVF   59,W
134F:  BCF    0A.4
1350:  BCF    03.5
1351:  CALL   0D4
1352:  BSF    0A.4
1353:  BSF    03.5
1354:  INCF   59,F
1355:  MOVWF  77
1356:  MOVWF  5D
1357:  BCF    0A.4
1358:  BCF    03.5
1359:  CALL   491
135A:  BSF    0A.4
135B:  MOVLW  04
135C:  BSF    03.5
135D:  SUBWF  59,W
135E:  BTFSS  03.2
135F:  GOTO   34E
1360:  BCF    03.5
1361:  MOVF   3E,W
1362:  BSF    03.5
1363:  MOVWF  5B
1364:  MOVLW  18
1365:  MOVWF  5C
1366:  BCF    0A.4
1367:  BSF    0A.3
1368:  BCF    03.5
1369:  CALL   6A0
136A:  BSF    0A.4
136B:  BCF    0A.3
.................... }  
136C:  RETLW  00
....................   
.................... void affi_lum(){  
....................    printf(displays, "\fO%3u",lum_ouest);  
*
120D:  MOVLW  0C
120E:  BSF    03.5
120F:  MOVWF  5D
1210:  BCF    0A.4
1211:  BCF    03.5
1212:  CALL   491
1213:  BSF    0A.4
1214:  MOVLW  4F
1215:  BSF    03.5
1216:  MOVWF  5D
1217:  BCF    0A.4
1218:  BCF    03.5
1219:  CALL   491
121A:  BSF    0A.4
121B:  MOVF   32,W
121C:  BSF    03.5
121D:  MOVWF  5B
121E:  MOVLW  10
121F:  MOVWF  5C
1220:  BCF    0A.4
1221:  BSF    0A.3
1222:  BCF    03.5
1223:  CALL   6A0
1224:  BSF    0A.4
1225:  BCF    0A.3
....................    printf(displays, "E%3u",lum_est);  
1226:  MOVLW  45
1227:  BSF    03.5
1228:  MOVWF  5D
1229:  BCF    0A.4
122A:  BCF    03.5
122B:  CALL   491
122C:  BSF    0A.4
122D:  MOVF   31,W
122E:  BSF    03.5
122F:  MOVWF  5B
1230:  MOVLW  10
1231:  MOVWF  5C
1232:  BCF    0A.4
1233:  BSF    0A.3
1234:  BCF    03.5
1235:  CALL   6A0
1236:  BSF    0A.4
1237:  BCF    0A.3
....................    printf(displays, "N%3u",lum_nord);  
1238:  MOVLW  4E
1239:  BSF    03.5
123A:  MOVWF  5D
123B:  BCF    0A.4
123C:  BCF    03.5
123D:  CALL   491
123E:  BSF    0A.4
123F:  MOVF   33,W
1240:  BSF    03.5
1241:  MOVWF  5B
1242:  MOVLW  10
1243:  MOVWF  5C
1244:  BCF    0A.4
1245:  BSF    0A.3
1246:  BCF    03.5
1247:  CALL   6A0
1248:  BSF    0A.4
1249:  BCF    0A.3
....................    printf(displays, "S%3u",lum_sud);  
124A:  MOVLW  53
124B:  BSF    03.5
124C:  MOVWF  5D
124D:  BCF    0A.4
124E:  BCF    03.5
124F:  CALL   491
1250:  BSF    0A.4
1251:  MOVF   34,W
1252:  BSF    03.5
1253:  MOVWF  5B
1254:  MOVLW  10
1255:  MOVWF  5C
1256:  BCF    0A.4
1257:  BSF    0A.3
1258:  BCF    03.5
1259:  CALL   6A0
125A:  BSF    0A.4
125B:  BCF    0A.3
....................    printf(displays, "\nM%3u",lum_m);  
125C:  MOVLW  0A
125D:  BSF    03.5
125E:  MOVWF  5D
125F:  BCF    0A.4
1260:  BCF    03.5
1261:  CALL   491
1262:  BSF    0A.4
1263:  MOVLW  4D
1264:  BSF    03.5
1265:  MOVWF  5D
1266:  BCF    0A.4
1267:  BCF    03.5
1268:  CALL   491
1269:  BSF    0A.4
126A:  MOVF   35,W
126B:  BSF    03.5
126C:  MOVWF  5B
126D:  MOVLW  10
126E:  MOVWF  5C
126F:  BCF    0A.4
1270:  BSF    0A.3
1271:  BCF    03.5
1272:  CALL   6A0
1273:  BSF    0A.4
1274:  BCF    0A.3
....................    printf(displays, " EA%3u",lum_eca);  
1275:  MOVLW  20
1276:  BSF    03.5
1277:  MOVWF  5D
1278:  BCF    0A.4
1279:  BCF    03.5
127A:  CALL   491
127B:  BSF    0A.4
127C:  MOVLW  45
127D:  BSF    03.5
127E:  MOVWF  5D
127F:  BCF    0A.4
1280:  BCF    03.5
1281:  CALL   491
1282:  BSF    0A.4
1283:  MOVLW  41
1284:  BSF    03.5
1285:  MOVWF  5D
1286:  BCF    0A.4
1287:  BCF    03.5
1288:  CALL   491
1289:  BSF    0A.4
128A:  MOVF   36,W
128B:  BSF    03.5
128C:  MOVWF  5B
128D:  MOVLW  10
128E:  MOVWF  5C
128F:  BCF    0A.4
1290:  BSF    0A.3
1291:  BCF    03.5
1292:  CALL   6A0
1293:  BSF    0A.4
1294:  BCF    0A.3
....................    printf(displays, " EE%3u\n",lum_ece);  
1295:  MOVLW  20
1296:  BSF    03.5
1297:  MOVWF  5D
1298:  BCF    0A.4
1299:  BCF    03.5
129A:  CALL   491
129B:  BSF    0A.4
129C:  MOVLW  45
129D:  BSF    03.5
129E:  MOVWF  5D
129F:  BCF    0A.4
12A0:  BCF    03.5
12A1:  CALL   491
12A2:  BSF    0A.4
12A3:  MOVLW  45
12A4:  BSF    03.5
12A5:  MOVWF  5D
12A6:  BCF    0A.4
12A7:  BCF    03.5
12A8:  CALL   491
12A9:  BSF    0A.4
12AA:  MOVF   37,W
12AB:  BSF    03.5
12AC:  MOVWF  5B
12AD:  MOVLW  10
12AE:  MOVWF  5C
12AF:  BCF    0A.4
12B0:  BSF    0A.3
12B1:  BCF    03.5
12B2:  CALL   6A0
12B3:  BSF    0A.4
12B4:  BCF    0A.3
12B5:  MOVLW  0A
12B6:  BSF    03.5
12B7:  MOVWF  5D
12B8:  BCF    0A.4
12B9:  BCF    03.5
12BA:  CALL   491
12BB:  BSF    0A.4
.................... }  
12BC:  RETLW  00
....................   
.................... void affi_ecl(){  
....................    if(ec_com==0){  
*
0EE2:  MOVF   3F,F
0EE3:  BTFSS  03.2
0EE4:  GOTO   6FA
....................       printf(displays, "\fpave: off\n");  
0EE5:  BSF    03.5
0EE6:  CLRF   5A
0EE7:  MOVF   5A,W
0EE8:  BCF    0A.3
0EE9:  BCF    03.5
0EEA:  CALL   0DF
0EEB:  BSF    0A.3
0EEC:  BSF    03.5
0EED:  INCF   5A,F
0EEE:  MOVWF  77
0EEF:  MOVWF  5D
0EF0:  BCF    0A.3
0EF1:  BCF    03.5
0EF2:  CALL   491
0EF3:  BSF    0A.3
0EF4:  MOVLW  0B
0EF5:  BSF    03.5
0EF6:  SUBWF  5A,W
0EF7:  BTFSS  03.2
0EF8:  GOTO   6E7
0EF9:  BCF    03.5
....................    }  
....................    if(ec_com==1){  
0EFA:  DECFSZ 3F,W
0EFB:  GOTO   72B
....................       printf(displays, "\fpave: on\n");  
0EFC:  BSF    03.5
0EFD:  CLRF   5A
0EFE:  MOVF   5A,W
0EFF:  BCF    0A.3
0F00:  BCF    03.5
0F01:  CALL   0EF
0F02:  BSF    0A.3
0F03:  BSF    03.5
0F04:  INCF   5A,F
0F05:  MOVWF  77
0F06:  MOVWF  5D
0F07:  BCF    0A.3
0F08:  BCF    03.5
0F09:  CALL   491
0F0A:  BSF    0A.3
0F0B:  MOVLW  0A
0F0C:  BSF    03.5
0F0D:  SUBWF  5A,W
0F0E:  BTFSS  03.2
0F0F:  GOTO   6FE
....................       printf(displays, "niveau:  %3u",ec_int);  
0F10:  CLRF   5A
0F11:  MOVF   5A,W
0F12:  BCF    0A.3
0F13:  BCF    03.5
0F14:  CALL   0FE
0F15:  BSF    0A.3
0F16:  BSF    03.5
0F17:  INCF   5A,F
0F18:  MOVWF  77
0F19:  MOVWF  5D
0F1A:  BCF    0A.3
0F1B:  BCF    03.5
0F1C:  CALL   491
0F1D:  BSF    0A.3
0F1E:  MOVLW  09
0F1F:  BSF    03.5
0F20:  SUBWF  5A,W
0F21:  BTFSS  03.2
0F22:  GOTO   711
0F23:  BCF    03.5
0F24:  MOVF   40,W
0F25:  BSF    03.5
0F26:  MOVWF  5B
0F27:  MOVLW  10
0F28:  MOVWF  5C
0F29:  BCF    03.5
0F2A:  CALL   6A0
....................    }  
....................    if(ec_com==2){  
0F2B:  MOVF   3F,W
0F2C:  SUBLW  02
0F2D:  BTFSS  03.2
0F2E:  GOTO   744
....................       printf(displays, "\fbloc 1: on\n");  
0F2F:  BSF    03.5
0F30:  CLRF   5A
0F31:  MOVF   5A,W
0F32:  BCF    0A.3
0F33:  BCF    03.5
0F34:  CALL   10F
0F35:  BSF    0A.3
0F36:  BSF    03.5
0F37:  INCF   5A,F
0F38:  MOVWF  77
0F39:  MOVWF  5D
0F3A:  BCF    0A.3
0F3B:  BCF    03.5
0F3C:  CALL   491
0F3D:  BSF    0A.3
0F3E:  MOVLW  0C
0F3F:  BSF    03.5
0F40:  SUBWF  5A,W
0F41:  BTFSS  03.2
0F42:  GOTO   731
0F43:  BCF    03.5
....................    }  
....................    if(ec_com==3){  
0F44:  MOVF   3F,W
0F45:  SUBLW  03
0F46:  BTFSS  03.2
0F47:  GOTO   75D
....................       printf(displays, "\fbloc 2: on\n");  
0F48:  BSF    03.5
0F49:  CLRF   5A
0F4A:  MOVF   5A,W
0F4B:  BCF    0A.3
0F4C:  BCF    03.5
0F4D:  CALL   120
0F4E:  BSF    0A.3
0F4F:  BSF    03.5
0F50:  INCF   5A,F
0F51:  MOVWF  77
0F52:  MOVWF  5D
0F53:  BCF    0A.3
0F54:  BCF    03.5
0F55:  CALL   491
0F56:  BSF    0A.3
0F57:  MOVLW  0C
0F58:  BSF    03.5
0F59:  SUBWF  5A,W
0F5A:  BTFSS  03.2
0F5B:  GOTO   74A
0F5C:  BCF    03.5
....................    }  
....................    if(ec_com==4){  
0F5D:  MOVF   3F,W
0F5E:  SUBLW  04
0F5F:  BTFSS  03.2
0F60:  GOTO   776
....................       printf(displays, "\fbloc 3: on\n");  
0F61:  BSF    03.5
0F62:  CLRF   5A
0F63:  MOVF   5A,W
0F64:  BCF    0A.3
0F65:  BCF    03.5
0F66:  CALL   131
0F67:  BSF    0A.3
0F68:  BSF    03.5
0F69:  INCF   5A,F
0F6A:  MOVWF  77
0F6B:  MOVWF  5D
0F6C:  BCF    0A.3
0F6D:  BCF    03.5
0F6E:  CALL   491
0F6F:  BSF    0A.3
0F70:  MOVLW  0C
0F71:  BSF    03.5
0F72:  SUBWF  5A,W
0F73:  BTFSS  03.2
0F74:  GOTO   763
0F75:  BCF    03.5
....................    }  
....................    if(ec_com==5){  
0F76:  MOVF   3F,W
0F77:  SUBLW  05
0F78:  BTFSS  03.2
0F79:  GOTO   78F
....................       printf(displays, "\fbloc 4: on\n");  
0F7A:  BSF    03.5
0F7B:  CLRF   5A
0F7C:  MOVF   5A,W
0F7D:  BCF    0A.3
0F7E:  BCF    03.5
0F7F:  CALL   142
0F80:  BSF    0A.3
0F81:  BSF    03.5
0F82:  INCF   5A,F
0F83:  MOVWF  77
0F84:  MOVWF  5D
0F85:  BCF    0A.3
0F86:  BCF    03.5
0F87:  CALL   491
0F88:  BSF    0A.3
0F89:  MOVLW  0C
0F8A:  BSF    03.5
0F8B:  SUBWF  5A,W
0F8C:  BTFSS  03.2
0F8D:  GOTO   77C
0F8E:  BCF    03.5
....................    }  
.................... }  
0F8F:  RETLW  00
....................   
.................... void affi_mat(){  
....................    printf(displays,"\fMAT ELECTRONIQUE");  
*
0850:  BSF    03.5
0851:  CLRF   59
0852:  MOVF   59,W
0853:  BCF    0A.3
0854:  BCF    03.5
0855:  CALL   153
0856:  BSF    0A.3
0857:  BSF    03.5
0858:  INCF   59,F
0859:  MOVWF  77
085A:  MOVWF  5D
085B:  BCF    0A.3
085C:  BCF    03.5
085D:  CALL   491
085E:  BSF    0A.3
085F:  MOVLW  11
0860:  BSF    03.5
0861:  SUBWF  59,W
0862:  BTFSS  03.2
0863:  GOTO   052
....................    printf(displays,"\nV1.0 01 2005\n");  
0864:  CLRF   59
0865:  MOVF   59,W
0866:  BCF    0A.3
0867:  BCF    03.5
0868:  CALL   169
0869:  BSF    0A.3
086A:  BSF    03.5
086B:  INCF   59,F
086C:  MOVWF  77
086D:  MOVWF  5D
086E:  BCF    0A.3
086F:  BCF    03.5
0870:  CALL   491
0871:  BSF    0A.3
0872:  MOVLW  0E
0873:  BSF    03.5
0874:  SUBWF  59,W
0875:  BTFSS  03.2
0876:  GOTO   065
....................    delay_ms(2000);  
0877:  MOVLW  08
0878:  MOVWF  59
0879:  MOVLW  FA
087A:  MOVWF  5B
087B:  BCF    0A.3
087C:  BCF    03.5
087D:  CALL   430
087E:  BSF    0A.3
087F:  BSF    03.5
0880:  DECFSZ 59,F
0881:  GOTO   079
....................    printf(displays,"\fSED-PANSOL50W");  
0882:  CLRF   59
0883:  MOVF   59,W
0884:  BCF    0A.3
0885:  BCF    03.5
0886:  CALL   17C
0887:  BSF    0A.3
0888:  BSF    03.5
0889:  INCF   59,F
088A:  MOVWF  77
088B:  MOVWF  5D
088C:  BCF    0A.3
088D:  BCF    03.5
088E:  CALL   491
088F:  BSF    0A.3
0890:  MOVLW  0E
0891:  BSF    03.5
0892:  SUBWF  59,W
0893:  BTFSS  03.2
0894:  GOTO   083
....................    printf(displays,"\nBCAN-MAT V1.0\n");  
0895:  CLRF   59
0896:  MOVF   59,W
0897:  BCF    0A.3
0898:  BCF    03.5
0899:  CALL   18F
089A:  BSF    0A.3
089B:  BSF    03.5
089C:  INCF   59,F
089D:  MOVWF  77
089E:  MOVWF  5D
089F:  BCF    0A.3
08A0:  BCF    03.5
08A1:  CALL   491
08A2:  BSF    0A.3
08A3:  MOVLW  0F
08A4:  BSF    03.5
08A5:  SUBWF  59,W
08A6:  BTFSS  03.2
08A7:  GOTO   096
....................    delay_ms(2000);  
08A8:  MOVLW  08
08A9:  MOVWF  59
08AA:  MOVLW  FA
08AB:  MOVWF  5B
08AC:  BCF    0A.3
08AD:  BCF    03.5
08AE:  CALL   430
08AF:  BSF    0A.3
08B0:  BSF    03.5
08B1:  DECFSZ 59,F
08B2:  GOTO   0AA
.................... }  
....................   
.................... void affi_auto(){  
....................    printf(displays,"\fMode automatique");  
*
079A:  BSF    03.5
079B:  CLRF   5A
079C:  MOVF   5A,W
079D:  BCF    03.5
079E:  CALL   1A3
079F:  BSF    03.5
07A0:  INCF   5A,F
07A1:  MOVWF  77
07A2:  MOVWF  5D
07A3:  BCF    03.5
07A4:  CALL   491
07A5:  MOVLW  11
07A6:  BSF    03.5
07A7:  SUBWF  5A,W
07A8:  BTFSS  03.2
07A9:  GOTO   79C
....................    printf(displays,"\nPANSOL V1.0\n");  
07AA:  CLRF   5A
07AB:  MOVF   5A,W
07AC:  BCF    03.5
07AD:  CALL   1B9
07AE:  BSF    03.5
07AF:  INCF   5A,F
07B0:  MOVWF  77
07B1:  MOVWF  5D
07B2:  BCF    03.5
07B3:  CALL   491
07B4:  MOVLW  0D
07B5:  BSF    03.5
07B6:  SUBWF  5A,W
07B7:  BTFSS  03.2
07B8:  GOTO   7AB
.................... }  
07B9:  BCF    03.5
07BA:  RETLW  00
....................   
.................... void affi_cora(){  
....................    printf(displays,"\fCorrection");  
*
0AF3:  BSF    03.5
0AF4:  CLRF   59
0AF5:  MOVF   59,W
0AF6:  BCF    0A.3
0AF7:  BCF    03.5
0AF8:  CALL   1CB
0AF9:  BSF    0A.3
0AFA:  BSF    03.5
0AFB:  INCF   59,F
0AFC:  MOVWF  77
0AFD:  MOVWF  5D
0AFE:  BCF    0A.3
0AFF:  BCF    03.5
0B00:  CALL   491
0B01:  BSF    0A.3
0B02:  MOVLW  0B
0B03:  BSF    03.5
0B04:  SUBWF  59,W
0B05:  BTFSS  03.2
0B06:  GOTO   2F5
....................    printf(displays,"\nazimut\n");  
0B07:  CLRF   59
0B08:  MOVF   59,W
0B09:  BCF    0A.3
0B0A:  BCF    03.5
0B0B:  CALL   1DB
0B0C:  BSF    0A.3
0B0D:  BSF    03.5
0B0E:  INCF   59,F
0B0F:  MOVWF  77
0B10:  MOVWF  5D
0B11:  BCF    0A.3
0B12:  BCF    03.5
0B13:  CALL   491
0B14:  BSF    0A.3
0B15:  MOVLW  08
0B16:  BSF    03.5
0B17:  SUBWF  59,W
0B18:  BTFSS  03.2
0B19:  GOTO   308
.................... }  
....................   
.................... void affi_core(){  
....................    printf(displays,"\fCorrection");  
*
0B2B:  BSF    03.5
0B2C:  CLRF   59
0B2D:  MOVF   59,W
0B2E:  BCF    0A.3
0B2F:  BCF    03.5
0B30:  CALL   1CB
0B31:  BSF    0A.3
0B32:  BSF    03.5
0B33:  INCF   59,F
0B34:  MOVWF  77
0B35:  MOVWF  5D
0B36:  BCF    0A.3
0B37:  BCF    03.5
0B38:  CALL   491
0B39:  BSF    0A.3
0B3A:  MOVLW  0B
0B3B:  BSF    03.5
0B3C:  SUBWF  59,W
0B3D:  BTFSS  03.2
0B3E:  GOTO   32D
....................    printf(displays,"\nelevation\n");  
0B3F:  CLRF   59
0B40:  MOVF   59,W
0B41:  BCF    0A.3
0B42:  BCF    03.5
0B43:  CALL   1E8
0B44:  BSF    0A.3
0B45:  BSF    03.5
0B46:  INCF   59,F
0B47:  MOVWF  77
0B48:  MOVWF  5D
0B49:  BCF    0A.3
0B4A:  BCF    03.5
0B4B:  CALL   491
0B4C:  BSF    0A.3
0B4D:  MOVLW  0B
0B4E:  BSF    03.5
0B4F:  SUBWF  59,W
0B50:  BTFSS  03.2
0B51:  GOTO   340
.................... }  
....................   
.................... void affi_park(){  
....................    printf(displays,"\fParking");  
*
0779:  BSF    03.5
077A:  CLRF   5A
077B:  MOVF   5A,W
077C:  BCF    03.5
077D:  CALL   1F8
077E:  BSF    03.5
077F:  INCF   5A,F
0780:  MOVWF  77
0781:  MOVWF  5D
0782:  BCF    03.5
0783:  CALL   491
0784:  MOVLW  08
0785:  BSF    03.5
0786:  SUBWF  5A,W
0787:  BTFSS  03.2
0788:  GOTO   77B
....................    printf(displays,"\nen cours\n");  
0789:  CLRF   5A
078A:  MOVF   5A,W
078B:  BCF    03.5
078C:  CALL   20B
078D:  BSF    03.5
078E:  INCF   5A,F
078F:  MOVWF  77
0790:  MOVWF  5D
0791:  BCF    03.5
0792:  CALL   491
0793:  MOVLW  0A
0794:  BSF    03.5
0795:  SUBWF  5A,W
0796:  BTFSS  03.2
0797:  GOTO   78A
.................... }  
0798:  BCF    03.5
0799:  RETLW  00
....................   
.................... void affi_manu(){  
....................    printf(displays,"\fMode manuel");  
*
07BB:  BSF    03.5
07BC:  CLRF   5A
07BD:  MOVF   5A,W
07BE:  BCF    03.5
07BF:  CALL   21A
07C0:  BSF    03.5
07C1:  INCF   5A,F
07C2:  MOVWF  77
07C3:  MOVWF  5D
07C4:  BCF    03.5
07C5:  CALL   491
07C6:  MOVLW  0C
07C7:  BSF    03.5
07C8:  SUBWF  5A,W
07C9:  BTFSS  03.2
07CA:  GOTO   7BD
....................    printf(displays,"\nPANSOL V1.0\n");  
07CB:  CLRF   5A
07CC:  MOVF   5A,W
07CD:  BCF    03.5
07CE:  CALL   1B9
07CF:  BSF    03.5
07D0:  INCF   5A,F
07D1:  MOVWF  77
07D2:  MOVWF  5D
07D3:  BCF    03.5
07D4:  CALL   491
07D5:  MOVLW  0D
07D6:  BSF    03.5
07D7:  SUBWF  5A,W
07D8:  BTFSS  03.2
07D9:  GOTO   7CC
.................... }  
07DA:  BCF    03.5
07DB:  RETLW  00
....................   
.................... void affi_mode(){  
....................    printf(displays,"\fMode ?);  
*
1899:  BSF    03.5
189A:  CLRF   59
189B:  MOVF   59,W
189C:  BCF    0A.4
189D:  BCF    0A.3
189E:  BCF    03.5
189F:  CALL   22B
18A0:  BSF    0A.4
18A1:  BSF    0A.3
18A2:  BSF    03.5
18A3:  INCF   59,F
18A4:  MOVWF  77
18A5:  MOVWF  5D
18A6:  BCF    0A.4
18A7:  BCF    0A.3
18A8:  BCF    03.5
18A9:  CALL   491
18AA:  BSF    0A.4
18AB:  BSF    0A.3
18AC:  MOVLW  07
18AD:  BSF    03.5
18AE:  SUBWF  59,W
18AF:  BTFSS  03.2
18B0:  GOTO   09B
....................    printf(displays,"\nchoix # 4 5");  
18B1:  CLRF   59
18B2:  MOVF   59,W
18B3:  BCF    0A.4
18B4:  BCF    0A.3
18B5:  BCF    03.5
18B6:  CALL   237
18B7:  BSF    0A.4
18B8:  BSF    0A.3
18B9:  BSF    03.5
18BA:  INCF   59,F
18BB:  MOVWF  77
18BC:  MOVWF  5D
18BD:  BCF    0A.4
18BE:  BCF    0A.3
18BF:  BCF    03.5
18C0:  CALL   491
18C1:  BSF    0A.4
18C2:  BSF    0A.3
18C3:  MOVLW  0C
18C4:  BSF    03.5
18C5:  SUBWF  59,W
18C6:  BTFSS  03.2
18C7:  GOTO   0B2
.................... }  
....................   
.................... void affi_eclair(){  
....................    printf(displays,"\fEclairage ?);  
*
1863:  CLRF   59
1864:  MOVF   59,W
1865:  BCF    0A.4
1866:  BCF    0A.3
1867:  BCF    03.5
1868:  CALL   248
1869:  BSF    0A.4
186A:  BSF    0A.3
186B:  BSF    03.5
186C:  INCF   59,F
186D:  MOVWF  77
186E:  MOVWF  5D
186F:  BCF    0A.4
1870:  BCF    0A.3
1871:  BCF    03.5
1872:  CALL   491
1873:  BSF    0A.4
1874:  BSF    0A.3
1875:  MOVLW  0C
1876:  BSF    03.5
1877:  SUBWF  59,W
1878:  BTFSS  03.2
1879:  GOTO   064
....................    printf(displays,"\nchoix # 2a9");  
187A:  CLRF   59
187B:  MOVF   59,W
187C:  BCF    0A.4
187D:  BCF    0A.3
187E:  BCF    03.5
187F:  CALL   259
1880:  BSF    0A.4
1881:  BSF    0A.3
1882:  BSF    03.5
1883:  INCF   59,F
1884:  MOVWF  77
1885:  MOVWF  5D
1886:  BCF    0A.4
1887:  BCF    0A.3
1888:  BCF    03.5
1889:  CALL   491
188A:  BSF    0A.4
188B:  BSF    0A.3
188C:  MOVLW  0C
188D:  BSF    03.5
188E:  SUBWF  59,W
188F:  BTFSS  03.2
1890:  GOTO   07B
.................... }  
....................   
.................... void affi_affi(){  
....................    printf(displays,"\fAffichage ?);  
*
18D1:  CLRF   59
18D2:  MOVF   59,W
18D3:  BCF    0A.4
18D4:  BCF    0A.3
18D5:  BCF    03.5
18D6:  CALL   26A
18D7:  BSF    0A.4
18D8:  BSF    0A.3
18D9:  BSF    03.5
18DA:  INCF   59,F
18DB:  MOVWF  77
18DC:  MOVWF  5D
18DD:  BCF    0A.4
18DE:  BCF    0A.3
18DF:  BCF    03.5
18E0:  CALL   491
18E1:  BSF    0A.4
18E2:  BSF    0A.3
18E3:  MOVLW  0C
18E4:  BSF    03.5
18E5:  SUBWF  59,W
18E6:  BTFSS  03.2
18E7:  GOTO   0D2
....................    printf(displays,"\nchoix # 4a8");  
18E8:  CLRF   59
18E9:  MOVF   59,W
18EA:  BCF    0A.4
18EB:  BCF    0A.3
18EC:  BCF    03.5
18ED:  CALL   27B
18EE:  BSF    0A.4
18EF:  BSF    0A.3
18F0:  BSF    03.5
18F1:  INCF   59,F
18F2:  MOVWF  77
18F3:  MOVWF  5D
18F4:  BCF    0A.4
18F5:  BCF    0A.3
18F6:  BCF    03.5
18F7:  CALL   491
18F8:  BSF    0A.4
18F9:  BSF    0A.3
18FA:  MOVLW  0C
18FB:  BSF    03.5
18FC:  SUBWF  59,W
18FD:  BTFSS  03.2
18FE:  GOTO   0E9
.................... }  
....................   
.................... void affi_mot(){  
....................    printf(displays,"\fMoteur ?);  
*
1908:  CLRF   59
1909:  MOVF   59,W
190A:  BCF    0A.4
190B:  BCF    0A.3
190C:  BCF    03.5
190D:  CALL   28C
190E:  BSF    0A.4
190F:  BSF    0A.3
1910:  BSF    03.5
1911:  INCF   59,F
1912:  MOVWF  77
1913:  MOVWF  5D
1914:  BCF    0A.4
1915:  BCF    0A.3
1916:  BCF    03.5
1917:  CALL   491
1918:  BSF    0A.4
1919:  BSF    0A.3
191A:  MOVLW  09
191B:  BSF    03.5
191C:  SUBWF  59,W
191D:  BTFSS  03.2
191E:  GOTO   109
....................    printf(displays,"\nchoix # 1 2 6a9");  
191F:  CLRF   59
1920:  MOVF   59,W
1921:  BCF    0A.4
1922:  BCF    0A.3
1923:  BCF    03.5
1924:  CALL   29A
1925:  BSF    0A.4
1926:  BSF    0A.3
1927:  BSF    03.5
1928:  INCF   59,F
1929:  MOVWF  77
192A:  MOVWF  5D
192B:  BCF    0A.4
192C:  BCF    0A.3
192D:  BCF    03.5
192E:  CALL   491
192F:  BSF    0A.4
1930:  BSF    0A.3
1931:  MOVLW  10
1932:  BSF    03.5
1933:  SUBWF  59,W
1934:  BTFSS  03.2
1935:  GOTO   120
.................... }  
....................   
.................... void affi_cor(){  
....................    printf(displays,"\fCorrection ?);  
*
193F:  CLRF   59
1940:  MOVF   59,W
1941:  BCF    0A.4
1942:  BCF    0A.3
1943:  BCF    03.5
1944:  CALL   2AF
1945:  BSF    0A.4
1946:  BSF    0A.3
1947:  BSF    03.5
1948:  INCF   59,F
1949:  MOVWF  77
194A:  MOVWF  5D
194B:  BCF    0A.4
194C:  BCF    0A.3
194D:  BCF    03.5
194E:  CALL   491
194F:  BSF    0A.4
1950:  BSF    0A.3
1951:  MOVLW  0D
1952:  BSF    03.5
1953:  SUBWF  59,W
1954:  BTFSS  03.2
1955:  GOTO   140
....................    printf(displays,"\nchoix # 1 ");  
1956:  CLRF   59
1957:  MOVF   59,W
1958:  BCF    0A.4
1959:  BCF    0A.3
195A:  BCF    03.5
195B:  CALL   2C1
195C:  BSF    0A.4
195D:  BSF    0A.3
195E:  BSF    03.5
195F:  INCF   59,F
1960:  MOVWF  77
1961:  MOVWF  5D
1962:  BCF    0A.4
1963:  BCF    0A.3
1964:  BCF    03.5
1965:  CALL   491
1966:  BSF    0A.4
1967:  BSF    0A.3
1968:  MOVLW  0B
1969:  BSF    03.5
196A:  SUBWF  59,W
196B:  BTFSS  03.2
196C:  GOTO   157
196D:  BCF    03.5
.................... }  
....................   
.................... void affi_mod(){  
....................    if(normal==1){affi_auto();}  
*
1493:  BTFSS  53.0
1494:  GOTO   499
1495:  BCF    0A.4
1496:  CALL   79A
1497:  BSF    0A.4
....................    else {affi_manu();}  
1498:  GOTO   49C
1499:  BCF    0A.4
149A:  CALL   7BB
149B:  BSF    0A.4
149C:  NOP
.................... }  
....................  
.................... #include "gest_mode.c"                 //gestion modes de fonctionnement 
....................  /* gestion des modes de fonctionnement */  
....................   
.................... /* declaration des fonctions */  
.................... void mode_init();  
.................... void gest_mode();  
.................... void mode_manuel();  
.................... void mode_normal();  
.................... void gest_lum();  
.................... void gest_corr();  
....................   
.................... /* definition des fonctions */  
.................... void mode_init(){  
....................    normal=1;                                    //mode automatique  
*
09E1:  BSF    53.0
....................    cor_seuil=4;                                 //seuil d'ecart de luminosite pour declencher une correction  
09E2:  MOVLW  04
09E3:  MOVWF  52
....................    cor_per=15;                                  //periode entre 2 eventuelles correction en minutes  
09E4:  MOVLW  0F
09E5:  MOVWF  51
....................    cor_mode=1;                                  //mode correction activee  
09E6:  MOVLW  01
09E7:  MOVWF  50
....................    code_affi=00;                                //affichage normal  
09E8:  BSF    03.5
09E9:  CLRF   56
....................    park=1;  
09EA:  BCF    03.5
09EB:  MOVWF  4A
....................    can_sd_mot();  
09EC:  BCF    0A.3
09ED:  CALL   75A
09EE:  BSF    0A.3
....................    park=0;  
09EF:  CLRF   4A
.................... }  
....................   
.................... void gest_mode(){  
....................    if (normal==1){mode_normal();}  
*
0A02:  BTFSS  53.0
0A03:  GOTO   684
....................    if (manuel==1){mode_manuel();}  
*
0E84:  BTFSS  53.1
0E85:  GOTO   686
.................... }  
0E86:  BSF    0A.3
0E87:  BSF    0A.4
0E88:  GOTO   059 (RETURN)
....................   
.................... void mode_manuel(){}  
....................   
.................... void mode_normal(){  
....................    if (lum_flag==1){  
*
0A04:  BTFSS  53.4
0A05:  GOTO   218
....................       can_sr_lum();                             //demande donnees module luminosite  
....................       lum_flag=0;  
*
0A17:  BCF    53.4
....................    }  
....................    if (mot_flag==1){  
0A18:  BTFSS  53.6
0A19:  GOTO   22D
....................       can_sr_mot();                             //demande donnees module moteur  
....................       mot_flag=0;  
*
0A2C:  BCF    53.6
....................    }  
....................    if (bat_flag==1){  
0A2D:  BTFSS  53.5
0A2E:  GOTO   242
....................       can_sr_en();                              //demande donnees module energie  
....................       bat_flag=0;  
*
0A41:  BCF    53.5
....................    }  
....................    gest_lum();  
....................    gest_corr();  
....................    can_receive();                               //y-a-t-il des donnees qui arrivent du bus can ? 
*
0E82:  NOP
0E83:  BCF    03.5
.................... }  
....................   
.................... void gest_corr(){  
....................    lum_eca=0;  
*
0A83:  CLRF   36
....................    lum_ece=0;  
0A84:  CLRF   37
....................    if (n>(s+1)){  
0A85:  MOVLW  01
0A86:  ADDWF  2F,W
0A87:  MOVWF  78
0A88:  MOVF   30,W
0A89:  MOVWF  7A
0A8A:  BTFSC  03.0
0A8B:  INCF   7A,F
0A8C:  MOVF   7A,W
0A8D:  SUBWF  2E,W
0A8E:  BTFSS  03.0
0A8F:  GOTO   29C
0A90:  BTFSS  03.2
0A91:  GOTO   296
0A92:  MOVF   2D,W
0A93:  SUBWF  78,W
0A94:  BTFSC  03.0
0A95:  GOTO   29C
....................       lum_ece=n-s;                        //ecart luminosite elevation  
0A96:  MOVF   2F,W
0A97:  SUBWF  2D,W
0A98:  MOVWF  37
....................       mot_e_sens=2;  
0A99:  MOVLW  02
0A9A:  MOVWF  45
....................    }  
....................    else if (s>(n+1)){  
0A9B:  GOTO   2B2
0A9C:  MOVLW  01
0A9D:  ADDWF  2D,W
0A9E:  MOVWF  78
0A9F:  MOVF   2E,W
0AA0:  MOVWF  7A
0AA1:  BTFSC  03.0
0AA2:  INCF   7A,F
0AA3:  MOVF   7A,W
0AA4:  SUBWF  30,W
0AA5:  BTFSS  03.0
0AA6:  GOTO   2B2
0AA7:  BTFSS  03.2
0AA8:  GOTO   2AD
0AA9:  MOVF   2F,W
0AAA:  SUBWF  78,W
0AAB:  BTFSC  03.0
0AAC:  GOTO   2B2
....................       lum_ece=s-n;                        //ecart luminosite elevation  
0AAD:  MOVF   2D,W
0AAE:  SUBWF  2F,W
0AAF:  MOVWF  37
....................       mot_e_sens=1;  
0AB0:  MOVLW  01
0AB1:  MOVWF  45
....................    }  
....................    if (e>(o+1)){  
0AB2:  MOVLW  01
0AB3:  ADDWF  2B,W
0AB4:  MOVWF  78
0AB5:  MOVF   2C,W
0AB6:  MOVWF  7A
0AB7:  BTFSC  03.0
0AB8:  INCF   7A,F
0AB9:  MOVF   7A,W
0ABA:  SUBWF  2A,W
0ABB:  BTFSS  03.0
0ABC:  GOTO   2C9
0ABD:  BTFSS  03.2
0ABE:  GOTO   2C3
0ABF:  MOVF   29,W
0AC0:  SUBWF  78,W
0AC1:  BTFSC  03.0
0AC2:  GOTO   2C9
....................       lum_eca=e-o;                        //ecart luminosite azimut  
0AC3:  MOVF   2B,W
0AC4:  SUBWF  29,W
0AC5:  MOVWF  36
....................       mot_a_sens=2;  
0AC6:  MOVLW  02
0AC7:  MOVWF  47
....................    }  
....................    else if (o>(e+1)){  
0AC8:  GOTO   2DF
0AC9:  MOVLW  01
0ACA:  ADDWF  29,W
0ACB:  MOVWF  78
0ACC:  MOVF   2A,W
0ACD:  MOVWF  7A
0ACE:  BTFSC  03.0
0ACF:  INCF   7A,F
0AD0:  MOVF   7A,W
0AD1:  SUBWF  2C,W
0AD2:  BTFSS  03.0
0AD3:  GOTO   2DF
0AD4:  BTFSS  03.2
0AD5:  GOTO   2DA
0AD6:  MOVF   2B,W
0AD7:  SUBWF  78,W
0AD8:  BTFSC  03.0
0AD9:  GOTO   2DF
....................       lum_eca=o-e;                        //ecart luminosite azimut  
0ADA:  MOVF   29,W
0ADB:  SUBWF  2B,W
0ADC:  MOVWF  36
....................       mot_a_sens=1;  
0ADD:  MOVLW  01
0ADE:  MOVWF  47
....................    }  
....................    if ((cor_flag==1)&&(lum_m>100)){       // correction ? 
0ADF:  BTFSS  53.7
0AE0:  GOTO   367
0AE1:  MOVF   35,W
0AE2:  SUBLW  64
0AE3:  BTFSC  03.0
0AE4:  GOTO   367
....................       if ((lum_eca > cor_seuil)&&(lum_eca>lum_ece)){           //azimut en priorite  
0AE5:  MOVF   36,W
0AE6:  SUBWF  52,W
0AE7:  BTFSC  03.0
0AE8:  GOTO   321
0AE9:  MOVF   36,W
0AEA:  SUBWF  37,W
0AEB:  BTFSC  03.0
0AEC:  GOTO   321
....................          mot_a_dure = 1;  
0AED:  MOVLW  01
0AEE:  MOVWF  48
....................          mot_e_sens=0;  
0AEF:  CLRF   45
....................          can_sd_mot();  
0AF0:  BCF    0A.3
0AF1:  CALL   75A
0AF2:  BSF    0A.3
....................          affi_cora();  
....................          delay_ms(200);  
*
0B1A:  MOVLW  C8
0B1B:  MOVWF  5B
0B1C:  BCF    0A.3
0B1D:  BCF    03.5
0B1E:  CALL   430
0B1F:  BSF    0A.3
....................   
....................       }  
....................       else if (lum_ece > cor_seuil){      //sinon eventuellement elevation  
0B20:  GOTO   358
0B21:  MOVF   37,W
0B22:  SUBWF  52,W
0B23:  BTFSC  03.0
0B24:  GOTO   358
....................          mot_e_dure = 1;  
0B25:  MOVLW  01
0B26:  MOVWF  46
....................          mot_a_sens=0;  
0B27:  CLRF   47
....................          can_sd_mot();  
0B28:  BCF    0A.3
0B29:  CALL   75A
0B2A:  BSF    0A.3
....................          affi_core();  
....................          delay_ms(200);  
*
0B52:  MOVLW  C8
0B53:  MOVWF  5B
0B54:  BCF    0A.3
0B55:  BCF    03.5
0B56:  CALL   430
0B57:  BSF    0A.3
....................       }  
....................       if ((lum_ece<cor_seuil)&&(lum_eca<cor_seuil)){  
0B58:  MOVF   52,W
0B59:  SUBWF  37,W
0B5A:  BTFSC  03.0
0B5B:  GOTO   367
0B5C:  MOVF   52,W
0B5D:  SUBWF  36,W
0B5E:  BTFSC  03.0
0B5F:  GOTO   367
....................          cor_flag=0;  
0B60:  BCF    53.7
....................          mot_off=1;  
0B61:  MOVLW  01
0B62:  MOVWF  4B
....................          can_sd_mot();  
0B63:  BCF    0A.3
0B64:  CALL   75A
0B65:  BSF    0A.3
....................          mot_off=0;  
0B66:  CLRF   4B
....................       }  
....................    }  
....................    if ((cor_flag==1)&&(lum_m<100)&&(ang_azim>=270)){       // parking, il fait nuit  
0B67:  BTFSS  53.7
0B68:  GOTO   387
0B69:  MOVF   35,W
0B6A:  SUBLW  63
0B6B:  BTFSS  03.0
0B6C:  GOTO   387
0B6D:  MOVF   4D,W
0B6E:  SUBLW  00
0B6F:  BTFSC  03.0
0B70:  GOTO   387
0B71:  XORLW  FF
0B72:  BTFSS  03.2
0B73:  GOTO   378
0B74:  MOVF   4C,W
0B75:  SUBLW  0D
0B76:  BTFSC  03.0
0B77:  GOTO   387
....................       cor_flag=0;                         //pas de correction si parking  
0B78:  BCF    53.7
....................       affi_park();  
0B79:  BCF    0A.3
0B7A:  CALL   779
0B7B:  BSF    0A.3
....................       mot_a_sens=0;  
0B7C:  CLRF   47
....................       mot_a_dure=0;  
0B7D:  CLRF   48
....................       mot_e_sens=0;  
0B7E:  CLRF   45
....................       mot_e_dure=0;  
0B7F:  CLRF   46
....................       mot_off=0;  
0B80:  CLRF   4B
....................       park=1;  
0B81:  MOVLW  01
0B82:  MOVWF  4A
....................       can_sd_mot();  
0B83:  BCF    0A.3
0B84:  CALL   75A
0B85:  BSF    0A.3
....................       park=0;  
0B86:  CLRF   4A
....................    }  
.................... }  
....................   
.................... void gest_lum(){  
....................    int16 a;  
....................   
....................    lum_est=e/4;  
*
0A42:  RRF    2A,W
0A43:  MOVWF  7A
0A44:  RRF    29,W
0A45:  MOVWF  79
0A46:  RRF    7A,F
0A47:  RRF    79,F
0A48:  MOVF   79,W
0A49:  MOVWF  31
....................    lum_ouest=o/4;  
0A4A:  RRF    2C,W
0A4B:  MOVWF  7A
0A4C:  RRF    2B,W
0A4D:  MOVWF  79
0A4E:  RRF    7A,F
0A4F:  RRF    79,F
0A50:  MOVF   79,W
0A51:  MOVWF  32
....................    lum_nord=n/4;  
0A52:  RRF    2E,W
0A53:  MOVWF  7A
0A54:  RRF    2D,W
0A55:  MOVWF  79
0A56:  RRF    7A,F
0A57:  RRF    79,F
0A58:  MOVF   79,W
0A59:  MOVWF  33
....................    lum_sud=s/4;  
0A5A:  RRF    30,W
0A5B:  MOVWF  7A
0A5C:  RRF    2F,W
0A5D:  MOVWF  79
0A5E:  RRF    7A,F
0A5F:  RRF    79,F
0A60:  MOVF   79,W
0A61:  MOVWF  34
....................   
....................    a=lum_est;  
0A62:  BSF    03.5
0A63:  CLRF   5A
0A64:  BCF    03.5
0A65:  MOVF   31,W
0A66:  BSF    03.5
0A67:  MOVWF  59
....................    a=a+lum_ouest;  
0A68:  BCF    03.5
0A69:  MOVF   32,W
0A6A:  BSF    03.5
0A6B:  ADDWF  59,F
0A6C:  BTFSC  03.0
0A6D:  INCF   5A,F
....................    a=a+lum_nord;  
0A6E:  BCF    03.5
0A6F:  MOVF   33,W
0A70:  BSF    03.5
0A71:  ADDWF  59,F
0A72:  BTFSC  03.0
0A73:  INCF   5A,F
....................    a=a+lum_sud;  
0A74:  BCF    03.5
0A75:  MOVF   34,W
0A76:  BSF    03.5
0A77:  ADDWF  59,F
0A78:  BTFSC  03.0
0A79:  INCF   5A,F
....................    lum_m=a/4;  
0A7A:  RRF    5A,W
0A7B:  MOVWF  7A
0A7C:  RRF    59,W
0A7D:  MOVWF  79
0A7E:  RRF    7A,F
0A7F:  RRF    79,F
0A80:  MOVF   79,W
0A81:  BCF    03.5
0A82:  MOVWF  35
.................... }  
....................  
.................... #include "gest_clav.c"                 //gestion du clavier 
....................  /* gestion du clavier */  
....................   
.................... /* variables */  
.................... int1 m_flag;                           //mode  
.................... int1 a_flag;                           //affichage  
.................... int1 e_flag;                           //eclairage  
.................... int1 d_flag;                           //deplacement  
.................... int1 c_flag;                           //correction  
....................   
.................... int code;  
....................   
.................... /* declaration des fonctions */  
.................... void gest_clavier();                   //gestion des appels clavier  
.................... void commande(byte data);              //traitement code  
....................   
.................... /* definitions des fonctions */  
.................... #INT_RB                //Port B any change on B4-B7  
.................... void RDA_RB(){  
....................    int a,b,c,d,e;  
....................    e=input(PIN_B5);  
*
03D1:  BSF    03.5
03D2:  BSF    06.5
03D3:  BCF    03.5
03D4:  BSF    03.6
03D5:  CLRF   30
03D6:  BCF    03.6
03D7:  BTFSS  06.5
03D8:  GOTO   3DC
03D9:  BSF    03.6
03DA:  INCF   30,F
03DB:  BCF    03.6
....................    if(e==0){  
03DC:  BSF    03.6
03DD:  MOVF   30,F
03DE:  BTFSS  03.2
03DF:  GOTO   42B
....................       a=input(PIN_C2);  
03E0:  BCF    03.6
03E1:  BSF    6C.2
03E2:  MOVF   6C,W
03E3:  BSF    03.5
03E4:  MOVWF  07
03E5:  BCF    03.5
03E6:  BSF    03.6
03E7:  CLRF   2C
03E8:  BCF    03.6
03E9:  BTFSS  07.2
03EA:  GOTO   3EE
03EB:  BSF    03.6
03EC:  INCF   2C,F
03ED:  BCF    03.6
....................       b=input(PIN_C1);  
03EE:  BSF    6C.1
03EF:  MOVF   6C,W
03F0:  BSF    03.5
03F1:  MOVWF  07
03F2:  BCF    03.5
03F3:  BSF    03.6
03F4:  CLRF   2D
03F5:  BCF    03.6
03F6:  BTFSS  07.1
03F7:  GOTO   3FB
03F8:  BSF    03.6
03F9:  INCF   2D,F
03FA:  BCF    03.6
....................       c=input(PIN_B2);  
03FB:  BSF    03.5
03FC:  BSF    06.2
03FD:  BCF    03.5
03FE:  BSF    03.6
03FF:  CLRF   2E
0400:  BCF    03.6
0401:  BTFSS  06.2
0402:  GOTO   406
0403:  BSF    03.6
0404:  INCF   2E,F
0405:  BCF    03.6
....................       d=input(PIN_B4);  
0406:  BSF    03.5
0407:  BSF    06.4
0408:  BCF    03.5
0409:  BSF    03.6
040A:  CLRF   2F
040B:  BCF    03.6
040C:  BTFSS  06.4
040D:  GOTO   411
040E:  BSF    03.6
040F:  INCF   2F,F
0410:  BCF    03.6
....................       code=a+b*2+c*4+d*8;  
0411:  BCF    03.0
0412:  BSF    03.6
0413:  RLF    2D,W
0414:  ADDWF  2C,W
0415:  MOVWF  31
0416:  RLF    2E,W
0417:  MOVWF  77
0418:  RLF    77,F
0419:  MOVLW  FC
041A:  ANDWF  77,F
041B:  MOVF   77,W
041C:  ADDWF  31,W
041D:  MOVWF  32
041E:  RLF    2F,W
041F:  MOVWF  77
0420:  RLF    77,F
0421:  RLF    77,F
0422:  MOVLW  F8
0423:  ANDWF  77,F
0424:  MOVF   77,W
0425:  ADDWF  32,W
0426:  BSF    03.5
0427:  BCF    03.6
0428:  MOVWF  58
0429:  BCF    03.5
042A:  BSF    03.6
....................    }  
.................... }  
....................   
042B:  BCF    03.6
042C:  BCF    0B.0
042D:  BCF    0A.3
042E:  BCF    0A.4
042F:  GOTO   029
.................... void gest_clavier(){  
....................    if (afm_flag==0){                      //on entre dans le mode menu si 0  
*
185A:  BTFSC  6D.1
185B:  GOTO   16E
....................       if (code==1){  
185C:  BSF    03.5
185D:  DECFSZ 58,W
185E:  GOTO   092
....................          afm_flag=1;                      //touche 1 pour commande eclairage  
185F:  BCF    03.5
1860:  BSF    6D.1
....................          e_flag=1;  
1861:  BSF    03.5
1862:  BSF    57.1
....................          affi_eclair();  
....................       }  
....................       else if (code==2){  
*
1891:  GOTO   16D
1892:  MOVF   58,W
1893:  SUBLW  02
1894:  BTFSS  03.2
1895:  GOTO   0C9
....................          afm_flag=1;                      //touche 2 pour commande mode  
1896:  BCF    03.5
1897:  BSF    6D.1
....................          m_flag=1;  
1898:  BSF    6D.7
....................          affi_mode();  
....................       }  
....................       else if (code==3){  
*
18C8:  GOTO   16D
18C9:  MOVF   58,W
18CA:  SUBLW  03
18CB:  BTFSS  03.2
18CC:  GOTO   100
....................          afm_flag=1;                      //touche 3 pour commande choix d'affichage  
18CD:  BCF    03.5
18CE:  BSF    6D.1
....................          a_flag=1;  
18CF:  BSF    03.5
18D0:  BSF    57.0
....................          affi_affi();  
....................       }  
....................       else if (code==4){  
*
18FF:  GOTO   16D
1900:  MOVF   58,W
1901:  SUBLW  04
1902:  BTFSS  03.2
1903:  GOTO   137
....................          afm_flag=1;                      //touche 4 pour commande deplacement  
1904:  BCF    03.5
1905:  BSF    6D.1
....................          d_flag=1;  
1906:  BSF    03.5
1907:  BSF    57.2
....................          affi_mot();  
....................       }  
....................       else if (code==5){  
*
1936:  GOTO   16D
1937:  MOVF   58,W
1938:  SUBLW  05
1939:  BTFSS  03.2
193A:  GOTO   16D
....................          afm_flag=1;                      //touche 5 pour commande correction  
193B:  BCF    03.5
193C:  BSF    6D.1
....................          c_flag=1;  
193D:  BSF    03.5
193E:  BSF    57.3
....................          affi_cor();  
....................       }  
....................    }  
....................    if (afm_flag==1){  
*
196E:  BTFSS  6D.1
196F:  GOTO   29D
....................   
....................       if ((code==4)&&(m_flag==1)){commande(1);}  
1970:  BSF    03.5
1971:  MOVF   58,W
1972:  SUBLW  04
1973:  BTFSS  03.2
1974:  GOTO   182
1975:  BCF    03.5
1976:  BTFSC  6D.7
1977:  GOTO   17A
1978:  BSF    03.5
1979:  GOTO   182
197A:  MOVLW  01
197B:  BSF    03.5
197C:  MOVWF  59
197D:  BCF    0A.3
197E:  BCF    03.5
197F:  CALL   000
1980:  BSF    0A.3
1981:  BSF    03.5
....................       if ((code==5)&&(m_flag==1)){commande(2);}  
1982:  MOVF   58,W
1983:  SUBLW  05
1984:  BTFSS  03.2
1985:  GOTO   193
1986:  BCF    03.5
1987:  BTFSC  6D.7
1988:  GOTO   18B
1989:  BSF    03.5
198A:  GOTO   193
198B:  MOVLW  02
198C:  BSF    03.5
198D:  MOVWF  59
198E:  BCF    0A.3
198F:  BCF    03.5
1990:  CALL   000
1991:  BSF    0A.3
1992:  BSF    03.5
....................   
....................       if ((code==2)&&(e_flag==1)){commande(3);}  
1993:  MOVF   58,W
1994:  SUBLW  02
1995:  BTFSS  03.2
1996:  GOTO   1A0
1997:  BTFSS  57.1
1998:  GOTO   1A0
1999:  MOVLW  03
199A:  MOVWF  59
199B:  BCF    0A.3
199C:  BCF    03.5
199D:  CALL   000
199E:  BSF    0A.3
199F:  BSF    03.5
....................       if ((code==3)&&(e_flag==1)){commande(4);}  
19A0:  MOVF   58,W
19A1:  SUBLW  03
19A2:  BTFSS  03.2
19A3:  GOTO   1AD
19A4:  BTFSS  57.1
19A5:  GOTO   1AD
19A6:  MOVLW  04
19A7:  MOVWF  59
19A8:  BCF    0A.3
19A9:  BCF    03.5
19AA:  CALL   000
19AB:  BSF    0A.3
19AC:  BSF    03.5
....................       if ((code==4)&&(e_flag==1)){commande(5);}  
19AD:  MOVF   58,W
19AE:  SUBLW  04
19AF:  BTFSS  03.2
19B0:  GOTO   1BA
19B1:  BTFSS  57.1
19B2:  GOTO   1BA
19B3:  MOVLW  05
19B4:  MOVWF  59
19B5:  BCF    0A.3
19B6:  BCF    03.5
19B7:  CALL   000
19B8:  BSF    0A.3
19B9:  BSF    03.5
....................       if ((code==5)&&(e_flag==1)){commande(6);}  
19BA:  MOVF   58,W
19BB:  SUBLW  05
19BC:  BTFSS  03.2
19BD:  GOTO   1C7
19BE:  BTFSS  57.1
19BF:  GOTO   1C7
19C0:  MOVLW  06
19C1:  MOVWF  59
19C2:  BCF    0A.3
19C3:  BCF    03.5
19C4:  CALL   000
19C5:  BSF    0A.3
19C6:  BSF    03.5
....................       if ((code==6)&&(e_flag==1)){commande(7);}  
19C7:  MOVF   58,W
19C8:  SUBLW  06
19C9:  BTFSS  03.2
19CA:  GOTO   1D4
19CB:  BTFSS  57.1
19CC:  GOTO   1D4
19CD:  MOVLW  07
19CE:  MOVWF  59
19CF:  BCF    0A.3
19D0:  BCF    03.5
19D1:  CALL   000
19D2:  BSF    0A.3
19D3:  BSF    03.5
....................       if ((code==7)&&(e_flag==1)){commande(8);}  
19D4:  MOVF   58,W
19D5:  SUBLW  07
19D6:  BTFSS  03.2
19D7:  GOTO   1E1
19D8:  BTFSS  57.1
19D9:  GOTO   1E1
19DA:  MOVLW  08
19DB:  MOVWF  59
19DC:  BCF    0A.3
19DD:  BCF    03.5
19DE:  CALL   000
19DF:  BSF    0A.3
19E0:  BSF    03.5
....................       if ((code==8)&&(e_flag==1)){commande(9);}  
19E1:  MOVF   58,W
19E2:  SUBLW  08
19E3:  BTFSS  03.2
19E4:  GOTO   1EE
19E5:  BTFSS  57.1
19E6:  GOTO   1EE
19E7:  MOVLW  09
19E8:  MOVWF  59
19E9:  BCF    0A.3
19EA:  BCF    03.5
19EB:  CALL   000
19EC:  BSF    0A.3
19ED:  BSF    03.5
....................       if ((code==9)&&(e_flag==1)){commande(10);}  
19EE:  MOVF   58,W
19EF:  SUBLW  09
19F0:  BTFSS  03.2
19F1:  GOTO   1FB
19F2:  BTFSS  57.1
19F3:  GOTO   1FB
19F4:  MOVLW  0A
19F5:  MOVWF  59
19F6:  BCF    0A.3
19F7:  BCF    03.5
19F8:  CALL   000
19F9:  BSF    0A.3
19FA:  BSF    03.5
....................   
....................       if ((code==4)&&(a_flag==1)){commande(11);}  
19FB:  MOVF   58,W
19FC:  SUBLW  04
19FD:  BTFSS  03.2
19FE:  GOTO   208
19FF:  BTFSS  57.0
1A00:  GOTO   208
1A01:  MOVLW  0B
1A02:  MOVWF  59
1A03:  BCF    0A.3
1A04:  BCF    03.5
1A05:  CALL   000
1A06:  BSF    0A.3
1A07:  BSF    03.5
....................       if ((code==5)&&(a_flag==1)){commande(12);}  
1A08:  MOVF   58,W
1A09:  SUBLW  05
1A0A:  BTFSS  03.2
1A0B:  GOTO   215
1A0C:  BTFSS  57.0
1A0D:  GOTO   215
1A0E:  MOVLW  0C
1A0F:  MOVWF  59
1A10:  BCF    0A.3
1A11:  BCF    03.5
1A12:  CALL   000
1A13:  BSF    0A.3
1A14:  BSF    03.5
....................       if ((code==6)&&(a_flag==1)){commande(13);}  
1A15:  MOVF   58,W
1A16:  SUBLW  06
1A17:  BTFSS  03.2
1A18:  GOTO   222
1A19:  BTFSS  57.0
1A1A:  GOTO   222
1A1B:  MOVLW  0D
1A1C:  MOVWF  59
1A1D:  BCF    0A.3
1A1E:  BCF    03.5
1A1F:  CALL   000
1A20:  BSF    0A.3
1A21:  BSF    03.5
....................       if ((code==7)&&(a_flag==1)){commande(14);}  
1A22:  MOVF   58,W
1A23:  SUBLW  07
1A24:  BTFSS  03.2
1A25:  GOTO   22F
1A26:  BTFSS  57.0
1A27:  GOTO   22F
1A28:  MOVLW  0E
1A29:  MOVWF  59
1A2A:  BCF    0A.3
1A2B:  BCF    03.5
1A2C:  CALL   000
1A2D:  BSF    0A.3
1A2E:  BSF    03.5
....................       if ((code==8)&&(a_flag==1)){commande(15);}  
1A2F:  MOVF   58,W
1A30:  SUBLW  08
1A31:  BTFSS  03.2
1A32:  GOTO   23C
1A33:  BTFSS  57.0
1A34:  GOTO   23C
1A35:  MOVLW  0F
1A36:  MOVWF  59
1A37:  BCF    0A.3
1A38:  BCF    03.5
1A39:  CALL   000
1A3A:  BSF    0A.3
1A3B:  BSF    03.5
....................   
....................       if ((code==1)&&(d_flag==1)){commande(21);}      //moteur off  
1A3C:  DECFSZ 58,W
1A3D:  GOTO   247
1A3E:  BTFSS  57.2
1A3F:  GOTO   247
1A40:  MOVLW  15
1A41:  MOVWF  59
1A42:  BCF    0A.3
1A43:  BCF    03.5
1A44:  CALL   000
1A45:  BSF    0A.3
1A46:  BSF    03.5
....................       if ((code==2)&&(d_flag==1)){commande(16);}      //parking  
1A47:  MOVF   58,W
1A48:  SUBLW  02
1A49:  BTFSS  03.2
1A4A:  GOTO   254
1A4B:  BTFSS  57.2
1A4C:  GOTO   254
1A4D:  MOVLW  10
1A4E:  MOVWF  59
1A4F:  BCF    0A.3
1A50:  BCF    03.5
1A51:  CALL   000
1A52:  BSF    0A.3
1A53:  BSF    03.5
....................       if ((code==6)&&(d_flag==1)){commande(17);}      //commande azimut horaire 5s  
1A54:  MOVF   58,W
1A55:  SUBLW  06
1A56:  BTFSS  03.2
1A57:  GOTO   261
1A58:  BTFSS  57.2
1A59:  GOTO   261
1A5A:  MOVLW  11
1A5B:  MOVWF  59
1A5C:  BCF    0A.3
1A5D:  BCF    03.5
1A5E:  CALL   000
1A5F:  BSF    0A.3
1A60:  BSF    03.5
....................       if ((code==7)&&(d_flag==1)){commande(18);}      //commande azimut antihoraire 5s  
1A61:  MOVF   58,W
1A62:  SUBLW  07
1A63:  BTFSS  03.2
1A64:  GOTO   26E
1A65:  BTFSS  57.2
1A66:  GOTO   26E
1A67:  MOVLW  12
1A68:  MOVWF  59
1A69:  BCF    0A.3
1A6A:  BCF    03.5
1A6B:  CALL   000
1A6C:  BSF    0A.3
1A6D:  BSF    03.5
....................       if ((code==8)&&(d_flag==1)){commande(19);}      //commande elevation montee 5s  
1A6E:  MOVF   58,W
1A6F:  SUBLW  08
1A70:  BTFSS  03.2
1A71:  GOTO   27B
1A72:  BTFSS  57.2
1A73:  GOTO   27B
1A74:  MOVLW  13
1A75:  MOVWF  59
1A76:  BCF    0A.3
1A77:  BCF    03.5
1A78:  CALL   000
1A79:  BSF    0A.3
1A7A:  BSF    03.5
....................       if ((code==9)&&(d_flag==1)){commande(20);}      //commande elevation descente 5s  
1A7B:  MOVF   58,W
1A7C:  SUBLW  09
1A7D:  BTFSS  03.2
1A7E:  GOTO   288
1A7F:  BTFSS  57.2
1A80:  GOTO   288
1A81:  MOVLW  14
1A82:  MOVWF  59
1A83:  BCF    0A.3
1A84:  BCF    03.5
1A85:  CALL   000
1A86:  BSF    0A.3
1A87:  BSF    03.5
....................   
....................       if ((code==1)&&(c_flag==1)){commande(22);}  
1A88:  DECFSZ 58,W
1A89:  GOTO   293
1A8A:  BTFSS  57.3
1A8B:  GOTO   293
1A8C:  MOVLW  16
1A8D:  MOVWF  59
1A8E:  BCF    0A.3
1A8F:  BCF    03.5
1A90:  CALL   000
1A91:  BSF    0A.3
1A92:  BSF    03.5
....................   
....................       if (code==12){commande(23);}                    //on quitte le mode menu par la touche #  
1A93:  MOVF   58,W
1A94:  SUBLW  0C
1A95:  BTFSS  03.2
1A96:  GOTO   29E
1A97:  MOVLW  17
1A98:  MOVWF  59
1A99:  BCF    0A.3
1A9A:  BCF    03.5
1A9B:  CALL   000
1A9C:  BSF    0A.3
1A9D:  BSF    03.5
....................    }  
....................    code=0;  
1A9E:  CLRF   58
.................... }  
....................   
.................... void commande(byte a){  
....................   
....................    if(a==1){      //passage en mode automatique  
*
1000:  BSF    03.5
1001:  DECFSZ 59,W
1002:  GOTO   01D
....................       normal=1;  
1003:  BCF    03.5
1004:  BSF    53.0
....................       manuel=0;  
1005:  BCF    53.1
....................       code_affi=00;  
1006:  BSF    03.5
1007:  CLRF   56
....................       affi_auto();  
1008:  BCF    0A.4
1009:  BCF    03.5
100A:  CALL   79A
100B:  BSF    0A.4
....................       delay_ms(500);  
100C:  MOVLW  02
100D:  BSF    03.5
100E:  MOVWF  5A
100F:  MOVLW  FA
1010:  MOVWF  5B
1011:  BCF    0A.4
1012:  BCF    03.5
1013:  CALL   430
1014:  BSF    0A.4
1015:  BSF    03.5
1016:  DECFSZ 5A,F
1017:  GOTO   00F
....................       afm_flag=0;  
1018:  BCF    03.5
1019:  BCF    6D.1
....................       m_flag=0;  
101A:  BCF    6D.7
....................    }  
....................    else if(a==2){ //passage en mode manuel  
101B:  GOTO   20A
101C:  BSF    03.5
101D:  MOVF   59,W
101E:  SUBLW  02
101F:  BTFSS  03.2
1020:  GOTO   03C
....................       normal=0;  
1021:  BCF    03.5
1022:  BCF    53.0
....................       manuel=1;  
1023:  BSF    53.1
....................       code_affi=01;  
1024:  MOVLW  01
1025:  BSF    03.5
1026:  MOVWF  56
....................       affi_manu();  
1027:  BCF    0A.4
1028:  BCF    03.5
1029:  CALL   7BB
102A:  BSF    0A.4
....................       delay_ms(500);  
102B:  MOVLW  02
102C:  BSF    03.5
102D:  MOVWF  5A
102E:  MOVLW  FA
102F:  MOVWF  5B
1030:  BCF    0A.4
1031:  BCF    03.5
1032:  CALL   430
1033:  BSF    0A.4
1034:  BSF    03.5
1035:  DECFSZ 5A,F
1036:  GOTO   02E
....................       afm_flag=0;  
1037:  BCF    03.5
1038:  BCF    6D.1
....................       m_flag=0;  
1039:  BCF    6D.7
....................    }  
....................    else if(a==3){ //on eteint tout !  
103A:  GOTO   20A
103B:  BSF    03.5
103C:  MOVF   59,W
103D:  SUBLW  03
103E:  BTFSS  03.2
103F:  GOTO   05B
....................       ec_com=0;  
1040:  BCF    03.5
1041:  CLRF   3F
....................       can_sd_ecl();  
1042:  BCF    0A.4
1043:  CALL   7DC
1044:  BSF    0A.4
....................       affi_ecl();  
1045:  BCF    0A.4
1046:  BSF    0A.3
1047:  CALL   6E2
1048:  BSF    0A.4
1049:  BCF    0A.3
....................       delay_ms(500);  
104A:  MOVLW  02
104B:  BSF    03.5
104C:  MOVWF  5A
104D:  MOVLW  FA
104E:  MOVWF  5B
104F:  BCF    0A.4
1050:  BCF    03.5
1051:  CALL   430
1052:  BSF    0A.4
1053:  BSF    03.5
1054:  DECFSZ 5A,F
1055:  GOTO   04D
....................       afm_flag=0;  
1056:  BCF    03.5
1057:  BCF    6D.1
....................       e_flag=0;  
1058:  BSF    03.5
1059:  BCF    57.1
....................    }  
....................    else if(a==4){ //on allume le pave  
105A:  GOTO   20B
105B:  MOVF   59,W
105C:  SUBLW  04
105D:  BTFSS  03.2
105E:  GOTO   07B
....................       ec_com=1;  
105F:  MOVLW  01
1060:  BCF    03.5
1061:  MOVWF  3F
....................       can_sd_ecl();  
1062:  BCF    0A.4
1063:  CALL   7DC
1064:  BSF    0A.4
....................       affi_ecl();  
1065:  BCF    0A.4
1066:  BSF    0A.3
1067:  CALL   6E2
1068:  BSF    0A.4
1069:  BCF    0A.3
....................       delay_ms(500);  
106A:  MOVLW  02
106B:  BSF    03.5
106C:  MOVWF  5A
106D:  MOVLW  FA
106E:  MOVWF  5B
106F:  BCF    0A.4
1070:  BCF    03.5
1071:  CALL   430
1072:  BSF    0A.4
1073:  BSF    03.5
1074:  DECFSZ 5A,F
1075:  GOTO   06D
....................       afm_flag=0;  
1076:  BCF    03.5
1077:  BCF    6D.1
....................       e_flag=0;  
1078:  BSF    03.5
1079:  BCF    57.1
....................    }  
....................    else if(a==5){ //on augmente le niveau  
107A:  GOTO   20B
107B:  MOVF   59,W
107C:  SUBLW  05
107D:  BTFSS  03.2
107E:  GOTO   09F
....................       if (ec_int!=15){ec_int=ec_int+3;}  
107F:  BCF    03.5
1080:  MOVF   40,W
1081:  SUBLW  0F
1082:  BTFSC  03.2
1083:  GOTO   086
1084:  MOVLW  03
1085:  ADDWF  40,F
....................       can_sd_ecl();  
1086:  BCF    0A.4
1087:  CALL   7DC
1088:  BSF    0A.4
....................       affi_ecl();  
1089:  BCF    0A.4
108A:  BSF    0A.3
108B:  CALL   6E2
108C:  BSF    0A.4
108D:  BCF    0A.3
....................       delay_ms(500);  
108E:  MOVLW  02
108F:  BSF    03.5
1090:  MOVWF  5A
1091:  MOVLW  FA
1092:  MOVWF  5B
1093:  BCF    0A.4
1094:  BCF    03.5
1095:  CALL   430
1096:  BSF    0A.4
1097:  BSF    03.5
1098:  DECFSZ 5A,F
1099:  GOTO   091
....................       afm_flag=0;  
109A:  BCF    03.5
109B:  BCF    6D.1
....................       e_flag=0;  
109C:  BSF    03.5
109D:  BCF    57.1
....................    }  
....................    else if(a==6){ //on diminue le niveau  
109E:  GOTO   20B
109F:  MOVF   59,W
10A0:  SUBLW  06
10A1:  BTFSS  03.2
10A2:  GOTO   0C2
....................       if (ec_int!=0){ec_int=ec_int-3;}  
10A3:  BCF    03.5
10A4:  MOVF   40,F
10A5:  BTFSC  03.2
10A6:  GOTO   0A9
10A7:  MOVLW  03
10A8:  SUBWF  40,F
....................       can_sd_ecl();  
10A9:  BCF    0A.4
10AA:  CALL   7DC
10AB:  BSF    0A.4
....................       affi_ecl();  
10AC:  BCF    0A.4
10AD:  BSF    0A.3
10AE:  CALL   6E2
10AF:  BSF    0A.4
10B0:  BCF    0A.3
....................       delay_ms(500);  
10B1:  MOVLW  02
10B2:  BSF    03.5
10B3:  MOVWF  5A
10B4:  MOVLW  FA
10B5:  MOVWF  5B
10B6:  BCF    0A.4
10B7:  BCF    03.5
10B8:  CALL   430
10B9:  BSF    0A.4
10BA:  BSF    03.5
10BB:  DECFSZ 5A,F
10BC:  GOTO   0B4
....................       afm_flag=0;  
10BD:  BCF    03.5
10BE:  BCF    6D.1
....................       e_flag=0;  
10BF:  BSF    03.5
10C0:  BCF    57.1
....................    }  
....................    else if(a==7){    //on allume bloc 1  
10C1:  GOTO   20B
10C2:  MOVF   59,W
10C3:  SUBLW  07
10C4:  BTFSS  03.2
10C5:  GOTO   0E2
....................       ec_com=2;  
10C6:  MOVLW  02
10C7:  BCF    03.5
10C8:  MOVWF  3F
....................       can_sd_ecl();  
10C9:  BCF    0A.4
10CA:  CALL   7DC
10CB:  BSF    0A.4
....................       affi_ecl();  
10CC:  BCF    0A.4
10CD:  BSF    0A.3
10CE:  CALL   6E2
10CF:  BSF    0A.4
10D0:  BCF    0A.3
....................       delay_ms(500);  
10D1:  MOVLW  02
10D2:  BSF    03.5
10D3:  MOVWF  5A
10D4:  MOVLW  FA
10D5:  MOVWF  5B
10D6:  BCF    0A.4
10D7:  BCF    03.5
10D8:  CALL   430
10D9:  BSF    0A.4
10DA:  BSF    03.5
10DB:  DECFSZ 5A,F
10DC:  GOTO   0D4
....................       afm_flag=0;  
10DD:  BCF    03.5
10DE:  BCF    6D.1
....................       e_flag=0;  
10DF:  BSF    03.5
10E0:  BCF    57.1
....................    }  
....................    else if(a==8){    //on allume bloc 2  
10E1:  GOTO   20B
10E2:  MOVF   59,W
10E3:  SUBLW  08
10E4:  BTFSS  03.2
10E5:  GOTO   102
....................       ec_com=3;  
10E6:  MOVLW  03
10E7:  BCF    03.5
10E8:  MOVWF  3F
....................       can_sd_ecl();  
10E9:  BCF    0A.4
10EA:  CALL   7DC
10EB:  BSF    0A.4
....................       affi_ecl();  
10EC:  BCF    0A.4
10ED:  BSF    0A.3
10EE:  CALL   6E2
10EF:  BSF    0A.4
10F0:  BCF    0A.3
....................       delay_ms(500);  
10F1:  MOVLW  02
10F2:  BSF    03.5
10F3:  MOVWF  5A
10F4:  MOVLW  FA
10F5:  MOVWF  5B
10F6:  BCF    0A.4
10F7:  BCF    03.5
10F8:  CALL   430
10F9:  BSF    0A.4
10FA:  BSF    03.5
10FB:  DECFSZ 5A,F
10FC:  GOTO   0F4
....................       afm_flag=0;  
10FD:  BCF    03.5
10FE:  BCF    6D.1
....................       e_flag=0;  
10FF:  BSF    03.5
1100:  BCF    57.1
....................    }  
....................    else if(a==9){    //on allume bloc 3  
1101:  GOTO   20B
1102:  MOVF   59,W
1103:  SUBLW  09
1104:  BTFSS  03.2
1105:  GOTO   122
....................       ec_com=4;  
1106:  MOVLW  04
1107:  BCF    03.5
1108:  MOVWF  3F
....................       can_sd_ecl();  
1109:  BCF    0A.4
110A:  CALL   7DC
110B:  BSF    0A.4
....................       affi_ecl();  
110C:  BCF    0A.4
110D:  BSF    0A.3
110E:  CALL   6E2
110F:  BSF    0A.4
1110:  BCF    0A.3
....................       delay_ms(500);  
1111:  MOVLW  02
1112:  BSF    03.5
1113:  MOVWF  5A
1114:  MOVLW  FA
1115:  MOVWF  5B
1116:  BCF    0A.4
1117:  BCF    03.5
1118:  CALL   430
1119:  BSF    0A.4
111A:  BSF    03.5
111B:  DECFSZ 5A,F
111C:  GOTO   114
....................       afm_flag=0;  
111D:  BCF    03.5
111E:  BCF    6D.1
....................       e_flag=0;  
111F:  BSF    03.5
1120:  BCF    57.1
....................    }  
....................    else if(a==10){   //on allume bloc 4  
1121:  GOTO   20B
1122:  MOVF   59,W
1123:  SUBLW  0A
1124:  BTFSS  03.2
1125:  GOTO   142
....................       ec_com=5;  
1126:  MOVLW  05
1127:  BCF    03.5
1128:  MOVWF  3F
....................       afm_flag=0;  
1129:  BCF    6D.1
....................       e_flag=0;  
112A:  BSF    03.5
112B:  BCF    57.1
....................       can_sd_ecl();  
112C:  BCF    0A.4
112D:  BCF    03.5
112E:  CALL   7DC
112F:  BSF    0A.4
....................       affi_ecl();  
1130:  BCF    0A.4
1131:  BSF    0A.3
1132:  CALL   6E2
1133:  BSF    0A.4
1134:  BCF    0A.3
....................       delay_ms(500);  
1135:  MOVLW  02
1136:  BSF    03.5
1137:  MOVWF  5A
1138:  MOVLW  FA
1139:  MOVWF  5B
113A:  BCF    0A.4
113B:  BCF    03.5
113C:  CALL   430
113D:  BSF    0A.4
113E:  BSF    03.5
113F:  DECFSZ 5A,F
1140:  GOTO   138
....................    }  
....................    else if(a==11){   //affichage batterie  
1141:  GOTO   20B
1142:  MOVF   59,W
1143:  SUBLW  0B
1144:  BTFSS  03.2
1145:  GOTO   14D
....................       code_affi=02;  
1146:  MOVLW  02
1147:  MOVWF  56
....................       afm_flag=0;  
1148:  BCF    03.5
1149:  BCF    6D.1
....................       a_flag=0;  
114A:  BSF    03.5
114B:  BCF    57.0
....................    }  
....................    else if(a==12){   //affichage luminosite  
114C:  GOTO   20B
114D:  MOVF   59,W
114E:  SUBLW  0C
114F:  BTFSS  03.2
1150:  GOTO   158
....................       code_affi=03;  
1151:  MOVLW  03
1152:  MOVWF  56
....................       afm_flag=0;  
1153:  BCF    03.5
1154:  BCF    6D.1
....................       a_flag=0;  
1155:  BSF    03.5
1156:  BCF    57.0
....................    }  
....................    else if(a==13){   //affichage eclairage  
1157:  GOTO   20B
1158:  MOVF   59,W
1159:  SUBLW  0D
115A:  BTFSS  03.2
115B:  GOTO   163
....................       code_affi=04;  
115C:  MOVLW  04
115D:  MOVWF  56
....................       afm_flag=0;  
115E:  BCF    03.5
115F:  BCF    6D.1
....................       a_flag=0;  
1160:  BSF    03.5
1161:  BCF    57.0
....................    }  
....................    else if(a==14){   //affichage mode  
1162:  GOTO   20B
1163:  MOVF   59,W
1164:  SUBLW  0E
1165:  BTFSS  03.2
1166:  GOTO   16E
....................       code_affi=05;  
1167:  MOVLW  05
1168:  MOVWF  56
....................       afm_flag=0;  
1169:  BCF    03.5
116A:  BCF    6D.1
....................       a_flag=0;  
116B:  BSF    03.5
116C:  BCF    57.0
....................    }  
....................    else if(a==15){   //affichage defilant  
116D:  GOTO   20B
116E:  MOVF   59,W
116F:  SUBLW  0F
1170:  BTFSS  03.2
1171:  GOTO   179
....................       code_affi=01;  
1172:  MOVLW  01
1173:  MOVWF  56
....................       afm_flag=0;  
1174:  BCF    03.5
1175:  BCF    6D.1
....................       a_flag=0;  
1176:  BSF    03.5
1177:  BCF    57.0
....................    }  
....................    else if(a==16){   //commande parking  
1178:  GOTO   20B
1179:  MOVF   59,W
117A:  SUBLW  10
117B:  BTFSS  03.2
117C:  GOTO   191
....................       cor_flag=0;    //pas de correction si parking  
117D:  BCF    03.5
117E:  BCF    53.7
....................       affi_park();  
117F:  BCF    0A.4
1180:  CALL   779
1181:  BSF    0A.4
....................       mot_a_sens=0;  
1182:  CLRF   47
....................       mot_a_dure=0;  
1183:  CLRF   48
....................       mot_e_sens=0;  
1184:  CLRF   45
....................       mot_e_dure=0;  
1185:  CLRF   46
....................       mot_off=0;  
1186:  CLRF   4B
....................       park=1;  
1187:  MOVLW  01
1188:  MOVWF  4A
....................       can_sd_mot();  
1189:  BCF    0A.4
118A:  CALL   75A
118B:  BSF    0A.4
....................       park=0;  
118C:  CLRF   4A
....................       afm_flag=0;  
118D:  BCF    6D.1
....................       d_flag=0;  
118E:  BSF    03.5
118F:  BCF    57.2
....................    }  
....................    else if(a==17){   //commande azimut horaire 5s  
1190:  GOTO   20B
1191:  MOVF   59,W
1192:  SUBLW  11
1193:  BTFSS  03.2
1194:  GOTO   1A5
....................       mot_a_sens=1;  
1195:  MOVLW  01
1196:  BCF    03.5
1197:  MOVWF  47
....................       mot_a_dure=5;  
1198:  MOVLW  05
1199:  MOVWF  48
....................       mot_e_sens=0;  
119A:  CLRF   45
....................       mot_e_dure=0;  
119B:  CLRF   46
....................       mot_off=0;  
119C:  CLRF   4B
....................       park=0;  
119D:  CLRF   4A
....................       can_sd_mot();  
119E:  BCF    0A.4
119F:  CALL   75A
11A0:  BSF    0A.4
....................       afm_flag=0;  
11A1:  BCF    6D.1
....................       d_flag=0;  
11A2:  BSF    03.5
11A3:  BCF    57.2
....................    }  
....................    else if(a==18){   //commande azimut antihoraire 5s  
11A4:  GOTO   20B
11A5:  MOVF   59,W
11A6:  SUBLW  12
11A7:  BTFSS  03.2
11A8:  GOTO   1B9
....................       mot_a_sens=2;  
11A9:  MOVLW  02
11AA:  BCF    03.5
11AB:  MOVWF  47
....................       mot_a_dure=5;  
11AC:  MOVLW  05
11AD:  MOVWF  48
....................       mot_e_sens=0;  
11AE:  CLRF   45
....................       mot_e_dure=0;  
11AF:  CLRF   46
....................       mot_off=0;  
11B0:  CLRF   4B
....................       park=0;  
11B1:  CLRF   4A
....................       can_sd_mot();  
11B2:  BCF    0A.4
11B3:  CALL   75A
11B4:  BSF    0A.4
....................       afm_flag=0;  
11B5:  BCF    6D.1
....................       d_flag=0;  
11B6:  BSF    03.5
11B7:  BCF    57.2
....................    }  
....................    else if(a==19){   //commande elevation montee 5s  
11B8:  GOTO   20B
11B9:  MOVF   59,W
11BA:  SUBLW  13
11BB:  BTFSS  03.2
11BC:  GOTO   1CD
....................       mot_a_sens=0;  
11BD:  BCF    03.5
11BE:  CLRF   47
....................       mot_a_dure=0;  
11BF:  CLRF   48
....................       mot_e_sens=1;  
11C0:  MOVLW  01
11C1:  MOVWF  45
....................       mot_e_dure=5;  
11C2:  MOVLW  05
11C3:  MOVWF  46
....................       mot_off=0;  
11C4:  CLRF   4B
....................       park=0;  
11C5:  CLRF   4A
....................       can_sd_mot();  
11C6:  BCF    0A.4
11C7:  CALL   75A
11C8:  BSF    0A.4
....................       afm_flag=0;  
11C9:  BCF    6D.1
....................       d_flag=0;  
11CA:  BSF    03.5
11CB:  BCF    57.2
....................    }  
....................    else if(a==20){   //commande elevation descente 5s  
11CC:  GOTO   20B
11CD:  MOVF   59,W
11CE:  SUBLW  14
11CF:  BTFSS  03.2
11D0:  GOTO   1E1
....................       mot_a_sens=0;  
11D1:  BCF    03.5
11D2:  CLRF   47
....................       mot_a_dure=0;  
11D3:  CLRF   48
....................       mot_e_sens=2;  
11D4:  MOVLW  02
11D5:  MOVWF  45
....................       mot_e_dure=5;  
11D6:  MOVLW  05
11D7:  MOVWF  46
....................       mot_off=0;  
11D8:  CLRF   4B
....................       park=0;  
11D9:  CLRF   4A
....................       can_sd_mot();  
11DA:  BCF    0A.4
11DB:  CALL   75A
11DC:  BSF    0A.4
....................       afm_flag=0;  
11DD:  BCF    6D.1
....................       d_flag=0;  
11DE:  BSF    03.5
11DF:  BCF    57.2
....................    }  
....................       else if(a==21){   //commande arret moteur  
11E0:  GOTO   20B
11E1:  MOVF   59,W
11E2:  SUBLW  15
11E3:  BTFSS  03.2
11E4:  GOTO   1F5
....................       mot_a_sens=0;  
11E5:  BCF    03.5
11E6:  CLRF   47
....................       mot_a_dure=0;  
11E7:  CLRF   48
....................       mot_e_sens=0;  
11E8:  CLRF   45
....................       mot_e_dure=0;  
11E9:  CLRF   46
....................       mot_off=1;  
11EA:  MOVLW  01
11EB:  MOVWF  4B
....................       park=0;  
11EC:  CLRF   4A
....................       can_sd_mot();  
11ED:  BCF    0A.4
11EE:  CALL   75A
11EF:  BSF    0A.4
....................       mot_off=0;  
11F0:  CLRF   4B
....................       afm_flag=0;  
11F1:  BCF    6D.1
....................       d_flag=0;  
11F2:  BSF    03.5
11F3:  BCF    57.2
....................    }  
....................    else if(a==22){   //commande de correction immediate  
11F4:  GOTO   20B
11F5:  MOVF   59,W
11F6:  SUBLW  16
11F7:  BTFSS  03.2
11F8:  GOTO   1FF
....................       cor_flag=1;  
11F9:  BCF    03.5
11FA:  BSF    53.7
....................       afm_flag=0;  
11FB:  BCF    6D.1
....................       c_flag=0;  
11FC:  BSF    03.5
11FD:  BCF    57.3
....................    }  
....................    else if(a==23){   //commande sortie du mode menu sans actions  
11FE:  GOTO   20B
11FF:  MOVF   59,W
1200:  SUBLW  17
1201:  BTFSS  03.2
1202:  GOTO   20B
....................       a_flag=0;  
1203:  BCF    57.0
....................       c_flag=0;  
1204:  BCF    57.3
....................       d_flag=0;  
1205:  BCF    57.2
....................       e_flag=0;  
1206:  BCF    57.1
....................       m_flag=0;  
1207:  BCF    03.5
1208:  BCF    6D.7
....................       afm_flag=0;  
1209:  BCF    6D.1
120A:  BSF    03.5
....................   
....................    }  
.................... }  
120B:  BCF    03.5
120C:  RETLW  00
....................   
....................  
....................   
.................... /* declaration des fonctions */  
.................... void init();  
....................   
.................... /* programme principal */  
.................... void main()  
.................... {  
*
1800:  MOVLW  1F
1801:  ANDWF  03,F
1802:  MOVLW  50
1803:  MOVWF  77
1804:  MOVLW  20
1805:  MOVWF  04
1806:  BCF    03.7
1807:  CLRF   00
1808:  INCF   04,F
1809:  CLRWDT
180A:  DECFSZ 77,F
180B:  GOTO   007
180C:  CLRF   71
180D:  CLRF   72
180E:  CLRF   73
180F:  CLRF   74
1810:  CLRF   75
1811:  CLRF   76
1812:  CLRF   78
1813:  CLRF   79
1814:  CLRF   7A
1815:  CLRF   7B
1816:  CLRF   7C
1817:  CLRF   7D
1818:  CLRF   7E
1819:  MOVLW  50
181A:  MOVWF  77
181B:  MOVLW  A0
181C:  MOVWF  04
181D:  BCF    03.7
181E:  CLRF   00
181F:  INCF   04,F
1820:  CLRWDT
1821:  DECFSZ 77,F
1822:  GOTO   01E
1823:  MOVLW  60
1824:  MOVWF  77
1825:  MOVLW  10
1826:  MOVWF  04
1827:  BSF    03.7
1828:  CLRF   00
1829:  INCF   04,F
182A:  CLRWDT
182B:  DECFSZ 77,F
182C:  GOTO   028
182D:  BCF    03.7
182E:  MOVLW  59
182F:  MOVWF  77
1830:  MOVLW  90
1831:  MOVWF  04
1832:  BSF    03.7
1833:  CLRF   00
1834:  INCF   04,F
1835:  CLRWDT
1836:  DECFSZ 77,F
1837:  GOTO   033
1838:  BCF    03.7
1839:  CLRF   20
183A:  CLRF   04
183B:  BCF    03.7
183C:  MOVLW  1F
183D:  ANDWF  03,F
183E:  BSF    03.5
183F:  BSF    1F.0
1840:  BSF    1F.1
1841:  BSF    1F.2
1842:  BCF    1F.3
1843:  MOVLW  07
1844:  BCF    03.5
1845:  MOVWF  1F
1846:  MOVLW  03
1847:  BSF    03.5
1848:  MOVWF  19
1849:  MOVLW  22
184A:  MOVWF  18
184B:  MOVLW  90
184C:  BCF    03.5
184D:  MOVWF  18
....................    init();  
*
1851:  BCF    0A.4
1852:  GOTO   000
1853:  BSF    0A.4
....................    port_b_pullups (TRUE);  
1854:  BSF    03.5
1855:  BCF    01.7
....................    while (1)  
....................    {  
....................       //output_high(pin_B7);  
....................       gest_mode();  
1856:  BCF    0A.4
1857:  BCF    03.5
1858:  GOTO   202
1859:  BSF    0A.4
....................       gest_clavier();  
....................       gest_affi();  
*
1A9F:  BCF    0A.3
1AA0:  BCF    03.5
1AA1:  GOTO   36D
1AA2:  BSF    0A.3
....................       gest_serie();  
1AA3:  BCF    0A.3
1AA4:  GOTO   56D
1AA5:  BSF    0A.3
....................       enable_interrupts(int_rda);         // autorisation interruption liaison serie  
1AA6:  BSF    03.5
1AA7:  BSF    0C.5
....................       //output_low(pin_B7);  
....................       //delay_cycles(2);  
....................    }  
1AA8:  GOTO   056
.................... }  
....................   
.................... /* definitions des fonctions */  
.................... void init(){  
....................    affi_init();                        // initialisation affichage LCD  
1AA9:  GOTO   2A9
....................    serie_init();                       // initialisation de la liaison serie  
....................    can_init();                         // initialisation controleur CAN  
....................    mode_init();                        // initialisation du mode de fonctionnement  
....................    time_init();                        // initialisation gestion du temps  
....................    enable_interrupts(global);          // autorisation des interruptions  
*
09F8:  MOVLW  C0
09F9:  BCF    03.5
09FA:  IORWF  0B,F
....................    enable_interrupts(INT_RB);  
09FB:  BSF    0B.3
....................    enable_interrupts(int_rda);         // autorisation interruption liaison serie  
09FC:  BSF    03.5
09FD:  BSF    0C.5
....................    //nouvelle_trame_serie = 0;  
....................   
.................... }  
09FE:  BCF    03.5
09FF:  BSF    0A.3
0A00:  BSF    0A.4
0A01:  GOTO   053 (RETURN)
....................   
....................  

Configuration Fuses:
   Word  1: 3731   XT NOWDT PUT DEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
